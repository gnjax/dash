# Codebase Summary

> Generated: 2025-09-27T15:08:18.535Z
> Commit: 04f69467a845543e5531f6f96218a14e5cdc9484
> Date: 2025-09-25 01:05:21 +0200
> Remote: git@github.com:gnjax/dash.git

This file concatenates important text/code files in the repo so a single raw URL can be shared.

---


---

## next.config.ts

```ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

```

---

## postcss.config.mjs

```js
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

```

---

## prisma/migrations/migration_lock.toml

```toml
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

```

---

## prisma/schema.prisma

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model FxRate {
  date      DateTime
  base      String
  quote     String
  rate      Decimal   @db.Decimal(20, 10)
  source    String    @default("frankfurter")
  fetchedAt DateTime  @default(now())

  @@id([date, base, quote])
  @@index([base, quote])
}

model ListingImageCache {
  listingId String   @id
  source    String?
  url       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// =====================
/// INVENTORY MODELS
/// =====================

enum InventoryOriginType {
  Scraped
  Manual
}

enum InventoryCondition {
  Loose
  Boxed
  CIB
  NIB
}

model InventoryItem {
  id            String               @id @default(uuid())
  name          String
  originType    InventoryOriginType
  scrapedItemId String?
  manualLineId  String?
  fillEntryId   String?
  ordinal       Int?
  createdAt     DateTime             @default(now())

  condition     InventoryCondition   @default(Loose)

  tags          InventoryItemTag[]

  @@index([scrapedItemId])
  @@index([manualLineId])
  @@index([fillEntryId])
  @@unique([fillEntryId, ordinal])
}

model InventoryItemTag {
  itemId      String
  tagId       String
  placementId String?

  item InventoryItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  tag  Tag           @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([itemId, tagId])
  @@index([tagId])
}

/// =====================
/// MANUAL PURCHASE INPUT
/// =====================

model ManualPurchase {
  id                       String   @id @default(uuid())
  currency                 String   @default("JPY")
  intlShippingTotalYen     Decimal  @default(0) @db.Decimal(12, 2)
  domesticShippingTotalYen Decimal  @default(0) @db.Decimal(12, 2)
  customsTotalYen          Decimal  @default(0) @db.Decimal(12, 2)
  subtotalYen              Decimal? @db.Decimal(12, 2)
  notes                    String?
  createdAt                DateTime @default(now())

  lines ManualLine[]
}

model ManualLine {
  id               String   @id @default(uuid())
  manualPurchaseId String
  title            String
  priceYen         Decimal  @db.Decimal(12, 2)

  purchase ManualPurchase @relation(fields: [manualPurchaseId], references: [id], onDelete: Cascade)

  @@index([manualPurchaseId])
}

/// =====================
/// FILL SESSION + INPUTS
/// =====================

enum FillSourceType {
  ScrapedPackage
  Manual
}

model InventoryFillSession {
  id               String        @id @default(uuid())
  sourceType       FillSourceType
  scrapedPackageId String?
  manualPurchaseId String?
  customsTotalYen  Decimal       @default(0) @db.Decimal(12, 2)
  createdAt        DateTime      @default(now())
  finalizedAt      DateTime?

  sourceItems InventoryFillSourceItem[]
  entries     InventoryFillEntry[]

  @@index([scrapedPackageId])
  @@index([manualPurchaseId])
}

model InventoryFillSourceItem {
  id            String   @id @default(uuid())
  sessionId     String
  scrapedItemId String?
  manualLineId  String?

  shippingWeightPpm Int @default(0)

  session InventoryFillSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  entries InventoryFillEntry[]

  @@index([sessionId])
  @@index([scrapedItemId])
  @@index([manualLineId])
}

model InventoryFillEntry {
  id                String   @id @default(uuid())
  sessionId         String
  sourceItemId      String
  nameOverride      String?
  quantity          Int      @default(1)

  priceWeightPpm    Int      @default(0)
  shippingWeightPpm Int      @default(0)

  // condition chosen at fill-time, copied to InventoryItem(s)
  condition InventoryCondition @default(Loose)

  entryTags InventoryFillEntryTag[]

  session    InventoryFillSession    @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sourceItem InventoryFillSourceItem @relation(fields: [sourceItemId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([sourceItemId])
}

model InventoryFillEntryTag {
  entryId     String
  tagId       String
  placementId String?

  entry InventoryFillEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  tag   Tag                @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([entryId, tagId])
  @@index([tagId])
}

model Tag {
  id          String  @id @default(uuid())
  name        String
  description String?

  // NEW: reference image for this tag (e.g., game box/cart art)
  photoUrl    String?

  placements    TagPlacement[]
  itemTags      InventoryItemTag[]
  fillEntryTags InventoryFillEntryTag[]

  @@unique([name])
  @@index([name])
}

model TagPlacement {
  id                String  @id @default(uuid())
  tagId             String
  parentPlacementId String?

  tag      Tag            @relation(fields: [tagId], references: [id], onDelete: Restrict)
  parent   TagPlacement?  @relation("TP_Children", fields: [parentPlacementId], references: [id])
  children TagPlacement[] @relation("TP_Children")

  asAncestor   PlacementClosure[] @relation("PC_Ancestor")
  asDescendant PlacementClosure[] @relation("PC_Descendant")

  @@unique([parentPlacementId, tagId])
  @@index([tagId])
}

model PlacementClosure {
  ancestorPlacementId   String
  descendantPlacementId String
  depth                 Int

  ancestor   TagPlacement @relation("PC_Ancestor", fields: [ancestorPlacementId], references: [id], onDelete: Cascade)
  descendant TagPlacement @relation("PC_Descendant", fields: [descendantPlacementId], references: [id], onDelete: Cascade)

  @@id([ancestorPlacementId, descendantPlacementId])
  @@index([descendantPlacementId, depth])
  @@index([ancestorPlacementId, depth])
}

enum PackageStatus {
  Todo
  Processed
  Blacklist
}

model ScrapedPackage {
  id      String @id @default(uuid())
  source  String @default("buyee")
  pageUrl String

  dateShipped        DateTime?
  packageNumber      String    @unique
  intlTrackingNumber String?
  intlTrackingUrl    String?

  internationalShippingFeeYen Decimal? @db.Decimal(12, 2)
  domesticShippingFeeYen      Decimal? @db.Decimal(12, 2)

  raw         Json?
  firstSeenAt DateTime @default(now())
  lastSeenAt  DateTime @default(now())

  status PackageStatus @default(Todo)

  items ScrapedItem[]

  @@index([dateShipped])
  @@index([intlTrackingNumber])
}

model ScrapedItem {
  id               String   @id @default(uuid())
  scrapedPackageId String
  orderNumber      String?
  titleJa          String?
  titleEn          String?
  itemUrl          String?
  listingId        String?
  priceYen         Decimal? @db.Decimal(12, 2)

  scrapedPackage ScrapedPackage @relation(fields: [scrapedPackageId], references: [id], onDelete: Cascade)

  @@index([scrapedPackageId])
  @@index([listingId])
}

```

---

## prisma/seed.ts

```ts
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();
async function main() {
  await prisma.category.createMany({
    data: ["Video game","Arcade"].map(name => ({ name })), skipDuplicates: true
  });
  await prisma.type.createMany({
    data: ["Console","Game","Controller","PCB"].map(name => ({ name })), skipDuplicates: true
  });
  await prisma.brand.createMany({
    data: ["Nintendo","Konami","SEGA","Sony","Taito","SNK","NEC"].map(name => ({ name })), skipDuplicates: true
  });
  await prisma.platform.createMany({
    data: ["Famicom", "Super Famicom","N64","GameBoy","GameBoy Advance", "Gamecube", "Wii", "Wii U", "DS", "3DS","PS1","PS2", "PS3", "PSP", "PSVita", "Mark3", "MegaDrive", "Saturn","Dreamcast", "GameGear", "Neo Geo", "NEC PC Engine"].map(name => ({ name })), skipDuplicates: true
  });
}
main().finally(()=>prisma.$disconnect());
```

---

## src/app/api/fill-sessions/[id]/finalize/route.ts

```ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { PPM_DENOM } from '@/lib/weights';
import { PackageStatus, Condition } from '@prisma/client'; // ✅ add Condition

export async function POST(
  _req: NextRequest,
  ctx: { params: Promise<{ id: string }> }
) {
  const { id } = await ctx.params;

  const result = await prisma.$transaction(async (db) => {
    // 1) lock session by flipping finalizedAt if null
    const setFinal = await db.inventoryFillSession.updateMany({
      where: { id, finalizedAt: null },
      data: { finalizedAt: new Date() },
    });

    if (setFinal.count === 0) {
      // already finalized → still ensure the scraped package is marked Processed
      const sess = await db.inventoryFillSession.findUnique({
        where: { id },
        select: { sourceType: true, scrapedPackageId: true },
      });
      if (sess?.sourceType === 'ScrapedPackage' && sess.scrapedPackageId) {
        await db.scrapedPackage.update({
          where: { id: sess.scrapedPackageId },
          data: { status: PackageStatus.Processed },
        });
      }
      return { created: 0, alreadyFinalized: true };
    }

    const session = await db.inventoryFillSession.findUnique({
      where: { id },
      include: {
        sourceItems: { include: { entries: { include: { entryTags: true } } } },
      },
    });
    if (!session) throw new Error('Session not found after lock');

    const isScraped = session.sourceType === 'ScrapedPackage';

    // package totals
    let intlShip = 0, domShip = 0, customs = Number(session.customsTotalYen ?? 0);
    if (isScraped) {
      const pkg = await db.scrapedPackage.findUnique({ where: { id: session.scrapedPackageId! } });
      intlShip = Number(pkg?.internationalShippingFeeYen ?? 0);
      domShip = Number(pkg?.domesticShippingFeeYen ?? 0);
    } else {
      const mp = await db.manualPurchase.findUnique({ where: { id: session.manualPurchaseId! } });
      intlShip = Number(mp?.intlShippingTotalYen ?? 0);
      domShip = Number(mp?.domesticShippingTotalYen ?? 0);
    }
    const pkgShippingTotal = intlShip + domShip;

    // load source prices/titles
    const priceByKey: Record<string, number> = {};
    const titleByKey: Record<string, string> = {};
    if (isScraped) {
      const sitems = await db.scrapedItem.findMany({
        where: { scrapedPackageId: session.scrapedPackageId! },
        select: { id: true, priceYen: true, titleEn: true, titleJa: true },
      });
      for (const s of sitems) {
        priceByKey[s.id] = Number(s.priceYen ?? 0);
        titleByKey[s.id] = s.titleEn ?? s.titleJa ?? '(untitled)';
      }
    } else {
      const lines = await db.manualLine.findMany({
        where: { manualPurchaseId: session.manualPurchaseId! },
        select: { id: true, priceYen: true, title: true },
      });
      for (const l of lines) {
        priceByKey[l.id] = Number(l.priceYen ?? 0);
        titleByKey[l.id] = l.title;
      }
    }

    const pkgSubtotal = session.sourceItems.reduce((a, si) => {
      const key = si.scrapedItemId ?? si.manualLineId!;
      return a + (priceByKey[key] ?? 0);
    }, 0);

    // 2) Create items idempotently per entry using (fillEntryId, ordinal) uniqueness
    let created = 0;

    for (const si of session.sourceItems) {
      const key = si.scrapedItemId ?? si.manualLineId!;
      const sourcePrice = priceByKey[key] ?? 0;
      const sourceShip = Math.round((pkgShippingTotal * si.shippingWeightPpm) / PPM_DENOM);

      for (const e of si.entries) {
        const qty = e.quantity;
        const baseName = e.nameOverride ?? titleByKey[key] ?? '(untitled)';
        const originType = isScraped ? 'Scraped' : 'Manual';

        // Insert N items with ordinals 1..qty (skip duplicates via unique)
        const rows = Array.from({ length: qty }, (_, i) => ({
          name: baseName,
          originType: originType as any,
          scrapedItemId: si.scrapedItemId ?? null,
          manualLineId: si.manualLineId ?? null,
          fillEntryId: e.id,
          ordinal: i + 1,
          condition: (e as any).condition ?? Condition.Loose, // ✅ set condition (default Loose)
        }));

        // create items; duplicates (same fillEntryId, ordinal) are ignored
        const result = await db.inventoryItem.createMany({
          data: rows,
          skipDuplicates: true,
        });
        created += result.count; // ✅ accurate number created this run

        // fetch ids of all items for this entry (for tagging)
        const items = await db.inventoryItem.findMany({
          where: { fillEntryId: e.id },
          select: { id: true, ordinal: true },
        });

        // upsert first tag (with placement) for each item if present
        const t = e.entryTags[0];
        if (t && items.length) {
          await db.inventoryItemTag.createMany({
            data: items.map(it => ({
              itemId: it.id,
              tagId: t.tagId,
              placementId: t.placementId ?? null,
            })),
            skipDuplicates: true,
          });
        }
      }
    }

    // ✅ Mark scraped package as Processed when finalizing
    if (isScraped && session.scrapedPackageId) {
      await db.scrapedPackage.update({
        where: { id: session.scrapedPackageId },
        data: { status: PackageStatus.Processed },
      });
    }

    return { created, alreadyFinalized: false };
  });

  return NextResponse.json({ ok: true, ...result });
}

```

---

## src/app/api/fill-sessions/[id]/route.ts

```ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { PPM_DENOM } from '@/lib/weights';

function toNum(d: any) {
  if (d == null) return 0;
  if (typeof d === 'number') return d;
  if (typeof d === 'string') return Number(d);
  if (typeof d.toNumber === 'function') return d.toNumber();
  return Number(d);
}

// ===================
// GET /api/fill-sessions/:id
// ===================
export async function GET(
  _req: NextRequest,
  ctx: { params: Promise<{ id: string }> }
) {
  const { id } = await ctx.params;

  const session = await prisma.inventoryFillSession.findUnique({
    where: { id },
    include: {
      sourceItems: { include: { entries: { include: { entryTags: true } } } },
    },
  });
  if (!session) return NextResponse.json({ error: 'Session not found' }, { status: 404 });

  const isScraped = session.sourceType === 'ScrapedPackage';

  type Meta = { title: string; priceYen: number; listingId?: string | null };
  const metaByKey: Record<string, Meta> = {};

  let intlShip = 0;
  let domShip = 0;
  let fxDateISO: string | null = null;

  if (isScraped) {
    const pkg = await prisma.scrapedPackage.findUnique({
      where: { id: session.scrapedPackageId! },
      include: { items: true },
    });
    if (!pkg) return NextResponse.json({ error: 'Scraped package not found' }, { status: 404 });

    for (const it of pkg.items) {
      metaByKey[it.id] = {
        title: it.titleEn ?? it.titleJa ?? '(untitled)',
        priceYen: toNum(it.priceYen ?? 0),
        listingId: it.listingId ?? null,
      };
    }

    intlShip = toNum(pkg.internationalShippingFeeYen ?? 0);
    domShip = toNum(pkg.domesticShippingFeeYen ?? 0);
    fxDateISO = pkg.dateShipped ? pkg.dateShipped.toISOString().slice(0, 10) : null;
  } else {
    const mp = await prisma.manualPurchase.findUnique({
      where: { id: session.manualPurchaseId! },
      include: { lines: true },
    });
    if (!mp) return NextResponse.json({ error: 'Manual purchase not found' }, { status: 404 });

    for (const ln of mp.lines) {
      metaByKey[ln.id] = {
        title: ln.title ?? '(untitled)',
        priceYen: toNum(ln.priceYen ?? 0),
        listingId: null,
      };
    }

    // keeping your manual totals field names
    intlShip = toNum((mp as any).intlShippingTotalYen ?? 0);
    domShip = toNum((mp as any).domShippingTotalYen ?? 0);
  }

  return NextResponse.json({
    session: {
      id: session.id,
      sourceType: session.sourceType,
      customsTotalYen: toNum(session.customsTotalYen ?? 0),
      finalizedAt: session.finalizedAt,
    },
    packageTotals: {
      intlShip,
      domShip,
      packageShippingTotal: intlShip + domShip,
    },
    fxDateISO,
    sourceItems: session.sourceItems.map((si) => {
      const key = si.scrapedItemId ?? si.manualLineId!;
      const meta = metaByKey[key] || { title: '(missing)', priceYen: 0, listingId: null };
      return {
        id: si.id,
        scrapedItemId: si.scrapedItemId,
        manualLineId: si.manualLineId,
        listingId: meta.listingId ?? null, // ✅ keep thumbs working
        title: meta.title,
        priceYen: meta.priceYen,
        shippingWeightPpm: si.shippingWeightPpm,
        entries: si.entries.map(e => ({
          id: e.id,
          nameOverride: e.nameOverride,
          quantity: e.quantity,
          priceWeightPpm: e.priceWeightPpm,
          shippingWeightPpm: e.shippingWeightPpm,
          tagId: e.entryTags[0]?.tagId ?? null,
          tagPlacementId: e.entryTags[0]?.placementId ?? null,
          condition: e.condition, // ✅ NEW
        })),
      };
    }),
  }, { status: 200 });
}

// ===================
// PATCH /api/fill-sessions/:id
// ===================
//
// body:
// {
//   customsTotalYen: number,
//   sourceItems: [{ id, shippingWeightPpm }],
//   entriesUpsert: [{
//     id?, sourceItemId, nameOverride, quantity, priceWeightPpm, shippingWeightPpm,
//     tagId, tagPlacementId, condition
//   }]
// }
export async function PATCH(
  req: NextRequest,
  ctx: { params: Promise<{ id: string }> }
) {
  const { id } = await ctx.params;
  const body = await req.json();

  await prisma.$transaction(async (db) => {
    if (typeof body.customsTotalYen === 'number' && Number.isFinite(body.customsTotalYen)) {
      await db.inventoryFillSession.update({
        where: { id },
        data: { customsTotalYen: body.customsTotalYen },
      });
    }

    if (Array.isArray(body.sourceItems)) {
      for (const si of body.sourceItems) {
        const ppm = Math.max(0, Math.min(PPM_DENOM, (si.shippingWeightPpm | 0)));
        await db.inventoryFillSourceItem.update({
          where: { id: si.id },
          data: { shippingWeightPpm: ppm },
        });
      }
    }

    const keepIds = new Set<string>();
    if (Array.isArray(body.entriesUpsert)) {
      for (const e of body.entriesUpsert) {
        const data = {
          sessionId: id,
          sourceItemId: e.sourceItemId,
          nameOverride: e.nameOverride ?? null,
          quantity: Math.max(1, Number(e.quantity || 1)) | 0,
          priceWeightPpm: Math.max(0, Math.min(PPM_DENOM, (e.priceWeightPpm | 0))),
          shippingWeightPpm: Math.max(0, Math.min(PPM_DENOM, (e.shippingWeightPpm | 0))),
          condition: e.condition ?? 'Loose', // ✅ NEW
        } as const;

        let entryId: string;
        if (e.id) {
          entryId = String(e.id);
          await db.inventoryFillEntry.update({ where: { id: entryId }, data });
          await db.inventoryFillEntryTag.deleteMany({ where: { entryId } });
        } else {
          const created = await db.inventoryFillEntry.create({ data });
          entryId = created.id;
        }
        keepIds.add(entryId);

        if (e.tagId) {
          await db.inventoryFillEntryTag.create({
            data: {
              entryId,
              tagId: e.tagId,
              placementId: e.tagPlacementId ?? null,
            },
          });
        }
      }

      const existing = await db.inventoryFillEntry.findMany({
        where: { sessionId: id },
        select: { id: true },
      });
      const toDelete = existing.map(x => x.id).filter(dbId => !keepIds.has(dbId));
      if (toDelete.length) {
        await db.inventoryFillEntry.deleteMany({ where: { id: { in: toDelete } } });
      }
    }
  });

  return NextResponse.json({ ok: true });
}

```

---

## src/app/api/fill-sessions/by-package/route.ts

```ts
// src/app/api/fill-sessions/by-package/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const pkgId = searchParams.get('packageId') ?? searchParams.get('scrapedPackageId');
  if (!pkgId) {
    return NextResponse.json({ error: 'packageId is required' }, { status: 400 });
  }

  const sess = await prisma.inventoryFillSession.findFirst({
    where: { sourceType: 'ScrapedPackage', scrapedPackageId: pkgId },
    orderBy: { createdAt: 'desc' }, // latest one
    select: { id: true, finalizedAt: true },
  });

  if (!sess) {
    return NextResponse.json({ error: 'not_found' }, { status: 404 });
  }

  return NextResponse.json({ sessionId: sess.id, finalized: !!sess.finalizedAt });
}

```

---

## src/app/api/fill-sessions/route.ts

```ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { PPM_DENOM } from '@/lib/weights';

// POST /api/fill-sessions
// body: { sourceType: 'ScrapedPackage'|'Manual', scrapedPackageId?, manualPurchaseId?, customsTotalYen? }
export async function POST(req: NextRequest) {
  const body = await req.json();
  const { sourceType, scrapedPackageId, manualPurchaseId, customsTotalYen } = body || {};

  if (sourceType === 'ScrapedPackage') {
    if (!scrapedPackageId) return NextResponse.json({ error: 'scrapedPackageId required' }, { status: 400 });

    // ✅ Reuse existing non-finalized session
    const existing = await prisma.inventoryFillSession.findFirst({
      where: { sourceType: 'ScrapedPackage', scrapedPackageId, finalizedAt: null },
      select: { id: true },
    });
    if (existing) return NextResponse.json({ sessionId: existing.id }, { status: 200 });

    const pkg = await prisma.scrapedPackage.findUnique({
      where: { id: scrapedPackageId },
      include: { items: true },
    });
    if (!pkg) return NextResponse.json({ error: 'ScrapedPackage not found' }, { status: 404 });

    const session = await prisma.inventoryFillSession.create({
      data: {
        sourceType: 'ScrapedPackage',
        scrapedPackageId,
        customsTotalYen: customsTotalYen ?? 0,
      },
    });

    // Default shipping split proportional to price (fallback equal)
    const total = pkg.items.reduce((a, s) => a + Number(s.priceYen ?? 0), 0);
    for (const s of pkg.items) {
      let ppm = 0;
      const v = Number(s.priceYen ?? 0);
      if (total > 0) ppm = Math.round((v / total) * PPM_DENOM);
      await prisma.inventoryFillSourceItem.create({
        data: { sessionId: session.id, scrapedItemId: s.id, shippingWeightPpm: ppm },
      });
    }

    return NextResponse.json({ sessionId: session.id }, { status: 201 });
  }

  if (sourceType === 'Manual') {
    if (!manualPurchaseId) return NextResponse.json({ error: 'manualPurchaseId required' }, { status: 400 });

    // ✅ Reuse existing non-finalized session
    const existing = await prisma.inventoryFillSession.findFirst({
      where: { sourceType: 'Manual', manualPurchaseId, finalizedAt: null },
      select: { id: true },
    });
    if (existing) return NextResponse.json({ sessionId: existing.id }, { status: 200 });

    const mp = await prisma.manualPurchase.findUnique({
      where: { id: manualPurchaseId },
      include: { lines: true },
    });
    if (!mp) return NextResponse.json({ error: 'ManualPurchase not found' }, { status: 404 });

    const session = await prisma.inventoryFillSession.create({
      data: {
        sourceType: 'Manual',
        manualPurchaseId,
        customsTotalYen: customsTotalYen ?? mp.customsTotalYen,
      },
    });

    const total = mp.lines.reduce((a, s) => a + Number(s.priceYen ?? 0), 0);
    for (const line of mp.lines) {
      let ppm = 0;
      const v = Number(line.priceYen ?? 0);
      if (total > 0) ppm = Math.round((v / total) * PPM_DENOM);
      await prisma.inventoryFillSourceItem.create({
        data: { sessionId: session.id, manualLineId: line.id, shippingWeightPpm: ppm },
      });
    }

    return NextResponse.json({ sessionId: session.id }, { status: 201 });
  }

  return NextResponse.json({ error: 'Invalid sourceType' }, { status: 400 });
}

```

---

## src/app/api/fx/route.ts

```ts
// src/app/api/fx/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// Normalize "YYYY-MM-DD" -> Date at 00:00:00 UTC
function toUtcDate(d: string) {
  const [y, m, day] = d.split('-').map(Number);
  return new Date(Date.UTC(y, m - 1, day, 0, 0, 0, 0));
}

// Fetch from Frankfurter and return numeric rate JPY->EUR for a given date
async function fetchFrankfurter(dateStr: string): Promise<{ date: string; rate: number } | null> {
  // Frankfurter: https://api.frankfurter.dev/2020-01-01?from=JPY&to=EUR
  const url = `https://api.frankfurter.app/${dateStr}?from=JPY&to=EUR`;
  try {
    const r = await fetch(url, { next: { revalidate: 60 * 60 * 24 } }); // cache at edge for a day
    if (!r.ok) return null;
    const j = await r.json();
    const rate = j?.rates?.EUR;
    const date = j?.date || dateStr;
    if (typeof rate !== 'number' || !Number.isFinite(rate)) return null;
    return { date, rate };
  } catch {
    return null;
  }
}

function toNum(d: any) {
  if (d == null) return 0;
  if (typeof d === 'number') return d;
  if (typeof d === 'string') return Number(d);
  if (typeof d.toNumber === 'function') return d.toNumber();
  return Number(d);
}

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const dateParam = (searchParams.get('date') || '').slice(0, 10); // "YYYY-MM-DD"
    const base = (searchParams.get('base') || '').toUpperCase();
    const quote = (searchParams.get('quote') || '').toUpperCase();

    if (!dateParam || !/^\d{4}-\d{2}-\d{2}$/.test(dateParam)) {
      return NextResponse.json({ error: 'Invalid date' }, { status: 400 });
    }
    if (base !== 'JPY' || quote !== 'EUR') {
      // You can lift this restriction later; for now we only support JPY->EUR
      return NextResponse.json({ error: 'Only JPY->EUR supported' }, { status: 400 });
    }

    const dateUTC = toUtcDate(dateParam);

    // 1) Try DB cache for exact day
    const cached = await prisma.fxRate.findUnique({
      where: { date_base_quote: { date: dateUTC, base, quote } },
    });
    if (cached) {
      return NextResponse.json({
        base,
        quote,
        date: dateParam,
        rate: toNum(cached.rate),
        source: cached.source || 'cache',
        cached: true,
      });
    }

    // 2) Try Frankfurter (will auto-shift to nearest business day)
    const remote = await fetchFrankfurter(dateParam);
    if (remote) {
      await prisma.fxRate.upsert({
        where: { date_base_quote: { date: toUtcDate(remote.date), base, quote } },
        update: { rate: remote.rate, source: 'frankfurter' },
        create: {
          date: toUtcDate(remote.date),
          base,
          quote,
          rate: remote.rate,
          source: 'frankfurter',
        },
      });
      return NextResponse.json({
        base,
        quote,
        date: dateParam,
        rate: remote.rate,
        source: 'frankfurter',
        cached: false,
        note: remote.date !== dateParam ? `using nearest business day ${remote.date}` : undefined,
      });
    }

    // 3) Fallback: use most recent cached rate for base/quote (if any)
    const latest = await prisma.fxRate.findFirst({
      where: { base, quote },
      orderBy: { date: 'desc' },
    });
    if (latest) {
      return NextResponse.json({
        base,
        quote,
        date: dateParam,
        rate: toNum(latest.rate),
        source: latest.source || 'cache',
        cached: true,
        note: `fallback to latest cached rate from ${latest.date.toISOString().slice(0,10)}`,
      });
    }

    // 4) Emergency fallback for fully-offline dev environments
    const emergency = 0.0062; // conservative placeholder; replace if you prefer
    return NextResponse.json({
      base,
      quote,
      date: dateParam,
      rate: emergency,
      source: 'emergency-fallback',
      cached: false,
      note: 'remote FX fetch failed and no cache exists; using placeholder',
    });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: 500 });
  }
}

```

---

## src/app/api/inventory/assign-tag/route.ts

```ts
// src/app/api/inventory/assign-tag/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

async function resolvePlacementId(
  tagId: string,
  ancestorPlacementId?: string | null,
  explicitPlacementId?: string | null
) {
  if (explicitPlacementId) return explicitPlacementId;

  if (!ancestorPlacementId) {
    // Any placement for this tag is acceptable if branch not specified
    const p = await prisma.tagPlacement.findFirst({ where: { tagId }, select: { id: true } });
    return p?.id ?? null;
  }

  // Find placement of tag that is a descendant of ancestorPlacementId
  const descendants = await prisma.placementClosure.findMany({
    where: { ancestorPlacementId },
    select: { descendantPlacementId: true },
  });
  const descIds = descendants.map(d => d.descendantPlacementId);
  if (!descIds.length) return null;

  const placement = await prisma.tagPlacement.findFirst({
    where: { id: { in: descIds }, tagId },
    select: { id: true },
  });

  return placement?.id ?? null;
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    // Keep the SAME input contract as before:
    const itemIds: string[] = Array.isArray(body?.itemIds) ? body.itemIds.filter(Boolean) : [];
    const tagId: string | undefined = body?.tagId;
    const ancestorPlacementId: string | undefined = body?.ancestorPlacementId || undefined;
    const placementIdOverride: string | undefined = body?.placementId || undefined;

    if (!itemIds.length) return NextResponse.json({ error: 'itemIds[] required' }, { status: 400 });
    if (!tagId) return NextResponse.json({ error: 'tagId required' }, { status: 400 });

    // Resolve placement the same way you already had it
    const placementId = await resolvePlacementId(tagId, ancestorPlacementId, placementIdOverride);
    if (!placementId) {
      return NextResponse.json(
        { error: 'No placement found for tag under the selected branch.' },
        { status: 400 }
      );
    }

    // NEW behavior: replace existing tags for these items
    await prisma.$transaction([
      prisma.inventoryItemTag.deleteMany({ where: { itemId: { in: itemIds } } }),
      prisma.inventoryItemTag.createMany({
        data: itemIds.map(id => ({ itemId: id, tagId, placementId })),
        skipDuplicates: true,
      }),
    ]);

    return NextResponse.json({ ok: true, placementId });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Failed to assign tag.' }, { status: 400 });
  }
}

```

---

## src/app/api/inventory/route.ts

```ts
// src/app/api/inventory/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { PPM_DENOM } from '@/lib/weights';

function toNum(d: any) {
  if (d == null) return 0;
  if (typeof d === 'number') return d;
  if (typeof d === 'string') return Number(d);
  if (typeof (d as any).toNumber === 'function') return (d as any).toNumber();
  return Number(d);
}

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const limit = Math.max(1, Math.min(100, Number(searchParams.get('limit') ?? '50')));
  const cursor = searchParams.get('cursor') || undefined;

  // Support stacked filters: multiple ?q= values -> AND across terms
  const terms = searchParams.getAll('q').map(s => s.trim()).filter(Boolean);
  const singleQ = (searchParams.get('q') || '').trim();
  if (!terms.length && singleQ) terms.push(singleQ);

  // Helper to build a where-clause for ONE term
  async function buildWhereForTerm(q: string) {
    // Package number -> entryIds
    let entryIdsFromPackageQuery: string[] = [];
    {
      const pkgs = await prisma.scrapedPackage.findMany({
        where: { packageNumber: { contains: q, mode: 'insensitive' } },
        select: { id: true },
      });
      if (pkgs.length) {
        const sess = await prisma.inventoryFillSession.findMany({
          where: { scrapedPackageId: { in: pkgs.map(p => p.id) } },
          select: { id: true },
        });
        if (sess.length) {
          const entryIds = await prisma.inventoryFillEntry.findMany({
            where: { sessionId: { in: sess.map(s => s.id) } },
            select: { id: true },
          });
          entryIdsFromPackageQuery = entryIds.map(e => e.id);
        }
      }
    }

    // Match any segment in placement chain
    // tags (name ~ q) -> placements -> closure descendants -> InventoryItemTag.placementId
    let itemIdsFromPlacementQuery: string[] = [];
    {
      const tagHits = await prisma.tag.findMany({
        where: { name: { contains: q, mode: 'insensitive' } },
        select: { id: true },
      });
      const tagIds = tagHits.map(t => t.id);

      if (tagIds.length) {
        const ancPlacements = await prisma.tagPlacement.findMany({
          where: { tagId: { in: tagIds } },
          select: { id: true },
        });
        const ancIds = ancPlacements.map(p => p.id);

        let descIds: string[] = [];
        if (ancIds.length) {
          const closures = await prisma.placementClosure.findMany({
            where: { ancestorPlacementId: { in: ancIds } },
            select: { descendantPlacementId: true },
          });
          descIds = Array.from(new Set(closures.map(c => c.descendantPlacementId)));
        }

        const invTags = await prisma.inventoryItemTag.findMany({
          where: {
            OR: [
              { tagId: { in: tagIds } },
              ...(descIds.length ? [{ placementId: { in: descIds } }] as const : []),
            ],
          },
          select: { itemId: true },
        });
        itemIdsFromPlacementQuery = Array.from(new Set(invTags.map(it => it.itemId)));
      }
    }

    // OR group for this term; the final WHERE will AND these groups for all terms
    const clause: any = {
      OR: [
        { name: { contains: q, mode: 'insensitive' } },
        { tags: { some: { tag: { name: { contains: q, mode: 'insensitive' } } } } },
        ...(itemIdsFromPlacementQuery.length ? [{ id: { in: itemIdsFromPlacementQuery } }] : []),
        ...(entryIdsFromPackageQuery.length ? [{ fillEntryId: { in: entryIdsFromPackageQuery } }] : []),
      ],
    };
    return clause;
  }

  // Compose WHERE across terms (AND)
  let where: any = undefined;
  if (terms.length) {
    const clauses = [];
    for (const t of terms) {
      clauses.push(await buildWhereForTerm(t));
    }
    where = { AND: clauses };
  }

  // 1) Page of items
  const items = await prisma.inventoryItem.findMany({
    take: limit,
    ...(cursor ? { skip: 1, cursor: { id: cursor } } : {}),
    orderBy: { id: 'desc' },
    where,
    select: {
      id: true,
      name: true,
      ordinal: true,
      scrapedItemId: true,
      manualLineId: true,
      fillEntryId: true,
      createdAt: true,
      condition: true, // ✅ added
      tags: {
        select: {
          tag: { select: { id: true, name: true } },
          placementId: true,
        },
      },
    },
  });

  // 2) Batch lookups for allocations (same logic as before)
  const fillEntryIds = Array.from(new Set(items.map(i => i.fillEntryId).filter(Boolean) as string[]));
  const entries = fillEntryIds.length
    ? await prisma.inventoryFillEntry.findMany({
        where: { id: { in: fillEntryIds } },
        select: {
          id: true,
          quantity: true,
          priceWeightPpm: true,
          shippingWeightPpm: true,
          sourceItemId: true,
          sessionId: true,
        },
      })
    : [];
  const entriesById = new Map(entries.map(e => [e.id, e]));

  const sourceItemIds = Array.from(new Set(entries.map(e => e.sourceItemId)));
  const sourceItems = sourceItemIds.length
    ? await prisma.inventoryFillSourceItem.findMany({
        where: { id: { in: sourceItemIds } },
        select: {
          id: true,
          sessionId: true,
          shippingWeightPpm: true,
          scrapedItemId: true,
          manualLineId: true,
        },
      })
    : [];
  const sourceItemsById = new Map(sourceItems.map(s => [s.id, s]));

  const sessionIds = Array.from(new Set(entries.map(e => e.sessionId)));
  const sessions = sessionIds.length
    ? await prisma.inventoryFillSession.findMany({
        where: { id: { in: sessionIds } },
        select: {
          id: true,
          sourceType: true,
          customsTotalYen: true,
          scrapedPackageId: true,
          manualPurchaseId: true,
        },
      })
    : [];
  const sessionsById = new Map(sessions.map(s => [s.id, s]));

  const allSessSourceItems = sessionIds.length
    ? await prisma.inventoryFillSourceItem.findMany({
        where: { sessionId: { in: sessionIds } },
        select: { sessionId: true, scrapedItemId: true, manualLineId: true },
      })
    : [];
  const sessToSourceItems = new Map<
    string,
    { scrapedItemId: string | null; manualLineId: string | null }[]
  >();
  for (const si of allSessSourceItems) {
    const arr = sessToSourceItems.get(si.sessionId) ?? [];
    arr.push({ scrapedItemId: si.scrapedItemId ?? null, manualLineId: si.manualLineId ?? null });
    sessToSourceItems.set(si.sessionId, arr);
  }

  // Prices
  const scrapedIds = Array.from(new Set(allSessSourceItems.map(si => si.scrapedItemId).filter(Boolean) as string[]));
  const manualIds = Array.from(new Set(allSessSourceItems.map(si => si.manualLineId).filter(Boolean) as string[]));
  const scrapedItems = scrapedIds.length
    ? await prisma.scrapedItem.findMany({
        where: { id: { in: scrapedIds } },
        select: { id: true, priceYen: true, scrapedPackageId: true },
      })
    : [];
  const manualLines = manualIds.length
    ? await prisma.manualLine.findMany({
        where: { id: { in: manualIds } },
        select: { id: true, priceYen: true },
      })
    : [];
  const scrapedPriceById = new Map(scrapedItems.map(si => [si.id, toNum(si.priceYen)]));
  const manualPriceById = new Map(manualLines.map(ml => [ml.id, toNum(ml.priceYen)]));

  // Shipping & dates
  const scrapedPkgIds = Array.from(new Set(sessions.map(s => s.scrapedPackageId).filter(Boolean) as string[]));
  const manualPurchaseIds = Array.from(new Set(sessions.map(s => s.manualPurchaseId).filter(Boolean) as string[]));
  const scrapedPkgs = scrapedPkgIds.length
    ? await prisma.scrapedPackage.findMany({
        where: { id: { in: scrapedPkgIds } },
        select: {
          id: true,
          packageNumber: true,
          dateShipped: true,
          internationalShippingFeeYen: true,
          domesticShippingFeeYen: true,
        },
      })
    : [];
  const scrapedPkgById = new Map(scrapedPkgs.map(p => [p.id, p]));

  const manualPurchases = manualPurchaseIds.length
    ? await prisma.manualPurchase.findMany({
        where: { id: { in: manualPurchaseIds } },
        select: {
          id: true,
          datePurchased: true,
          intlShippingTotalYen: true,
          domesticShippingTotalYen: true,
        },
      })
    : [];
  const manualById = new Map(manualPurchases.map(m => [m.id, m]));

  // Build placement labels (Root > ... > Leaf) with leaf last
  const placementIds = Array.from(
    new Set(items.flatMap(i => i.tags?.map(t => t.placementId).filter(Boolean) as string[] ?? [])),
  );
  const placementLabels = new Map<string, string>();
  if (placementIds.length) {
    const closures = await prisma.placementClosure.findMany({
      where: { descendantPlacementId: { in: placementIds } },
      select: {
        descendantPlacementId: true,
        depth: true,
        ancestor: { select: { tag: { select: { name: true } } } },
      },
    });

    const byDesc = new Map<string, { depth: number; name: string }[]>();
    for (const c of closures) {
      const nm = (c as any).ancestor.tag?.name ?? '';
      if (!nm) continue;
      const arr = byDesc.get(c.descendantPlacementId) ?? [];
      arr.push({ depth: c.depth, name: nm });
      byDesc.set(c.descendantPlacementId, arr);
    }
    for (const [desc, arr] of byDesc) {
      // depth: 0=leaf, >0 ancestors. For root → ... → leaf order, sort DESC by depth.
      arr.sort((a, b) => b.depth - a.depth);
      placementLabels.set(desc, arr.map(x => x.name).join(' > '));
    }
  }

  // 3) Rows
  const rows: any[] = [];
  for (const it of items) {
    const entry = it.fillEntryId ? entriesById.get(it.fillEntryId) : null;

    // even if no entry (should be rare), still render tags & minimal fields
    if (!entry) {
      const tagParts = (it.tags || []).map(tp => {
        const t = tp.tag?.name ?? '';
        const pname = tp.placementId ? (placementLabels.get(tp.placementId) || '') : '';
        return pname ? `${t} (${pname})` : t;
      });
      rows.push({
        id: it.id,
        name: it.name,
        condition: it.condition, // ✅ added
        tagChain: tagParts.join(' • '),
        fxDateISO: null,
        packageNumber: null,
        purchaseDateISO: null,
        jpy: { basePerUnit: 0, shipPerUnit: 0, customsPerUnit: 0, totalPerUnit: 0 },
      });
      continue;
    }

    const qty = Math.max(1, toNum(entry.quantity));
    const entryPricePPM = toNum(entry.priceWeightPpm);
    const entryShipPPM = toNum(entry.shippingWeightPpm);

    const src = sourceItemsById.get(entry.sourceItemId)!;
    const sourceItemShipPPM = toNum(src.shippingWeightPpm);

    // Source price (JPY)
    let sourcePriceYen = 0;
    if (src.scrapedItemId) sourcePriceYen = scrapedPriceById.get(src.scrapedItemId) ?? 0;
    else if (src.manualLineId) sourcePriceYen = manualPriceById.get(src.manualLineId) ?? 0;

    // Package subtotal (JPY)
    let packageSubtotal = 0;
    for (const s of (sessToSourceItems.get(entry.sessionId) ?? [])) {
      if (s.scrapedItemId) packageSubtotal += scrapedPriceById.get(s.scrapedItemId) ?? 0;
      else if (s.manualLineId) packageSubtotal += manualPriceById.get(s.manualLineId) ?? 0;
    }

    // Session meta
    const sess = sessionsById.get(entry.sessionId)!;
    let pkgShipTotal = 0;
    let fxDateISO: string | null = null;
    let packageNumber: string | null = null;
    let purchaseDateISO: string | null = null;

    if (sess.sourceType === 'ScrapedPackage' && sess.scrapedPackageId) {
      const pkg = scrapedPkgById.get(sess.scrapedPackageId) || null;
      const intl = toNum(pkg?.internationalShippingFeeYen ?? 0);
      const dom = toNum(pkg?.domesticShippingFeeYen ?? 0);
      pkgShipTotal = intl + dom;
      fxDateISO = pkg?.dateShipped ? pkg.dateShipped.toISOString().slice(0, 10) : null;
      packageNumber = (pkg as any)?.packageNumber ?? null;
      purchaseDateISO = fxDateISO;
    } else if (sess.sourceType === 'Manual' && sess.manualPurchaseId) {
      const mp = manualById.get(sess.manualPurchaseId) || null;
      const intl = toNum((mp as any)?.intlShippingTotalYen ?? 0);
      const dom = toNum((mp as any)?.domesticShippingTotalYen ?? 0);
      pkgShipTotal = intl + dom;
      purchaseDateISO = (mp as any)?.datePurchased
        ? new Date((mp as any).datePurchased).toISOString().slice(0, 10)
        : null;
      fxDateISO = purchaseDateISO;
    }

    // Allocations (same as filler)
    const baseAllocJPY = Math.round(sourcePriceYen * (entryPricePPM / PPM_DENOM));
    const sourceShipAllocJPY = Math.round(pkgShipTotal * (sourceItemShipPPM / PPM_DENOM));
    const entryShipAllocJPY = Math.round(sourceShipAllocJPY * (entryShipPPM / PPM_DENOM));

    let entryCustomsJPY = 0;
    if (packageSubtotal > 0) {
      const customsTotal = toNum(sess.customsTotalYen ?? 0);
      const sourceShare = sourcePriceYen / packageSubtotal;
      entryCustomsJPY = Math.round(customsTotal * sourceShare * (entryPricePPM / PPM_DENOM));
    }

    const basePerUnitJPY = Math.round(baseAllocJPY / qty);
    const shipPerUnitJPY = Math.round(entryShipAllocJPY / qty);
    const customsPerUnitJPY = Math.round(entryCustomsJPY / qty);
    const totalPerUnitJPY = basePerUnitJPY + shipPerUnitJPY + customsPerUnitJPY;

    const tagParts = (it.tags || []).map(tp => {
      const t = tp.tag?.name ?? '';
      const pname = tp.placementId ? (placementLabels.get(tp.placementId) || '') : '';
      return pname ? `${t} (${pname})` : t;
    });

    rows.push({
      id: it.id,
      name: it.name,
      condition: it.condition, // ✅ added
      tagChain: tagParts.join(' • '),
      fxDateISO,
      packageNumber,
      purchaseDateISO,
      jpy: {
        basePerUnit: basePerUnitJPY,
        shipPerUnit: shipPerUnitJPY,
        customsPerUnit: customsPerUnitJPY,
        totalPerUnit: totalPerUnitJPY,
      },
    });
  }

  const nextCursor = items.length === limit ? items[items.length - 1].id : null;
  return NextResponse.json({ items: rows, nextCursor });
}

```

---

## src/app/api/manual-purchase/route.ts

```ts
// src/app/api/manual-purchases/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// POST: { currency?, intlShippingTotalYen?, domesticShippingTotalYen?, customsTotalYen?, subtotalYen?, notes?, lines: [{ title, priceYen }] }
export async function POST(req: NextRequest) {
  const b = await req.json();
  if (!Array.isArray(b.lines) || b.lines.length === 0) {
    return NextResponse.json({ error: 'lines required' }, { status: 400 });
  }
  const mp = await prisma.manualPurchase.create({
    data: {
      currency: b.currency ?? 'JPY',
      intlShippingTotalYen: b.intlShippingTotalYen ?? 0,
      domesticShippingTotalYen: b.domesticShippingTotalYen ?? 0,
      customsTotalYen: b.customsTotalYen ?? 0,
      subtotalYen: b.subtotalYen ?? null,
      notes: b.notes ?? null,
      lines: {
        create: b.lines.map((l: any) => ({ title: l.title, priceYen: l.priceYen })),
      },
    },
  });

  return NextResponse.json({ manualPurchaseId: mp.id }, { status: 201 });
}

```

---

## src/app/api/profile/refresh/confirm/route.ts

```ts
// src/app/api/profile/refresh/confirm/route.ts
import { NextResponse } from 'next/server';
import { confirmRefresh, getRunning } from '@/lib/refresh-runner';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const body = await req.json().catch(() => ({}));
  const source = String(body?.source || '').toLowerCase();
  if (!['buyee','zenmarket','fromjapan'].includes(source)) {
    return NextResponse.json({ ok: false, error: 'invalid_source' }, { status: 400 });
  }
  if (!getRunning(source)) {
    return NextResponse.json({ ok: false, error: 'no_process' }, { status: 409 });
  }
  const out = await confirmRefresh(source);
  return NextResponse.json(out);
}

```

---

## src/app/api/profile/refresh/start/route.ts

```ts
// src/app/api/profile/refresh/start/route.ts
import { NextResponse } from 'next/server';
import { startRefresh, getRunning } from '@/lib/refresh-runner';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const body = await req.json().catch(() => ({}));
  const source = String(body?.source || '').toLowerCase();
  if (!['buyee','zenmarket','fromjapan'].includes(source)) {
    return NextResponse.json({ ok: false, error: 'invalid_source' }, { status: 400 });
  }
  if (getRunning(source)) {
    return NextResponse.json({ ok: true, alreadyRunning: true });
  }
  const { pid } = startRefresh(source);
  // tiny delay so the singleton map is definitely populated before a fast Confirm
  await new Promise(r => setTimeout(r, 100));
  return NextResponse.json({ ok: true, pid });
}

```

---

## src/app/api/scrape/buyee-crawl/route.ts

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { scrapeBuyeeShippedList } from '@/scrapers/buyee';
import { translateJaToEn } from '@/lib/translate';

function buildPageUrl(page: number): string {
  // fixed path; vary ?page=
  return `https://buyee.jp/mybaggages/shipped/1?term=0&page=${page}`;
}

export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const { startPage = 1, maxPages = 10 } = await req.json().catch(() => ({}));
  let pagesCrawled = 0, inserted = 0, updated = 0, stopReason = '';

  try {
    for (let pageNum = Number(startPage); pageNum < Number(startPage) + Number(maxPages); pageNum++) {
      const url = buildPageUrl(pageNum);
      const { packages } = await scrapeBuyeeShippedList(url);
      pagesCrawled++;

      // keep only entries with a packageNumber (should be all)
      const pagePkgs = packages.filter(p => p.packageNumber);
      if (!pagePkgs.length) { stopReason = 'empty_or_invalid_page'; break; }

      // === STOP CONDITION ===
      // Only stop if:
      //  (1) page has 10 entries
      //  (2) every entry has dateShipped (i.e., shipped)
      //  (3) every entry is already in DB (seen)
      const isFullPage = pagePkgs.length === 10;
      const allHaveDate = pagePkgs.every(p => !!p.dateShipped);
      let allSeen = false;
      if (isFullPage && allHaveDate) {
        const keys = pagePkgs.map(p => p.packageNumber!);
        const already = await prisma.scrapedPackage.findMany({
          where: { packageNumber: { in: keys } },
          select: { packageNumber: true, dateShipped: true },
        });
        allSeen = already.length === pagePkgs.length;
        const allSeenWithDate = allSeen && already.every(row => row.dateShipped != null);
        if (allSeenWithDate) { stopReason = 'all_10_shipped_on_page_already_seen'; break; }
      }
      // ======================

      // Upsert every entry (shipped or not)
      for (const p of pagePkgs) {
        const ja = (p.items || []).map(i => i.title || '');
        const en = await translateJaToEn(ja);

        const existing = await prisma.scrapedPackage.findUnique({
          where: { packageNumber: p.packageNumber! },
          select: { id: true, packageNumber: true }
        });

        const up = await prisma.scrapedPackage.upsert({
          where: { packageNumber: p.packageNumber! },
          update: {
            pageUrl: url,
            dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
            intlTrackingNumber: p.intlTrackingNumber || null,
            intlTrackingUrl: p.intlTrackingUrl || null,
            internationalShippingFeeYen: p.internationalShippingFeeYen ?? null,
            domesticShippingFeeYen: p.domesticShippingFeeYen ?? null,
            raw: p,
            lastSeenAt: new Date(),
          },
          create: {
            source: 'buyee',
            pageUrl: url,
            packageNumber: p.packageNumber!, // unique
            dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
            intlTrackingNumber: p.intlTrackingNumber || null,
            intlTrackingUrl: p.intlTrackingUrl || null,
            internationalShippingFeeYen: p.internationalShippingFeeYen ?? null,
            domesticShippingFeeYen: p.domesticShippingFeeYen ?? null,
            raw: p,
          },
          select: { id: true, packageNumber: true },
        });

        // Replace items
        await prisma.scrapedItem.deleteMany({ where: { scrapedPackageId: up.id } });
        if (p.items?.length) {
          await prisma.scrapedItem.createMany({
            data: p.items.map((it, idx) => ({
              scrapedPackageId: up.id,
              orderNumber: it.orderNumber || null,
              titleJa: it.title || null,
              titleEn: en[idx] || it.title || null,
              itemUrl: it.itemUrl || null,
              listingId: it.listingId || null,
              priceYen: typeof it.priceYen === 'number' ? it.priceYen : null,
            })),
            skipDuplicates: true,
          });
        }

        if (existing) updated++; else inserted++;
      }
    }

    return NextResponse.json({ pagesCrawled, inserted, updated, stopReason }, { status: 200 });
  } catch (e: any) {
    console.error('CRAWL_ERROR', e);
    return NextResponse.json({ error: e?.message || 'crawl failed', pagesCrawled, inserted, updated }, { status: 500 });
  }
}
```

---

## src/app/api/scrape/fromjapan-crawl/route.ts

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { scrapeFromJapanShippedList } from '@/scrapers/fromjapan';
import { translateJaToEn } from '@/lib/translate';

// Always use base list URL; paging is done via POST { currentPage } inside the scraper.
function baseUrl(): string {
  return 'https://www.fromjapan.co.jp/japan/en/member/history/ship/list';
}

export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const { startPage = 1, maxPages = 1 } = await req.json().catch(() => ({})); // default: just page 1
  let pagesCrawled = 0, inserted = 0, updated = 0, stopReason = '';

  try {
    for (let pageNum = Number(startPage); pageNum < Number(startPage) + Number(maxPages); pageNum++) {
      const url = baseUrl();
      const { packages } = await scrapeFromJapanShippedList(url, pageNum);
      pagesCrawled++;

      if (!packages.length) { stopReason = 'empty_page'; break; }

      // Stop when EVERYTHING on the page is already in DB (they are all shipped pages)
      const keys = packages.map(p => p.packageNumber);
      const already = await prisma.scrapedPackage.findMany({
        where: { packageNumber: { in: keys } },
        select: { packageNumber: true },
      });
      if (already.length === packages.length) { stopReason = 'all_seen_on_page'; break; }

      for (const p of packages) {
        // Translate item titles
        const ja = (p.items || []).map(i => i.title || '');
        const en = await translateJaToEn(ja);

        const existing = await prisma.scrapedPackage.findUnique({
          where: { packageNumber: p.packageNumber },
          select: { id: true, packageNumber: true }
        });

        const up = await prisma.scrapedPackage.upsert({
          where: { packageNumber: p.packageNumber },
          update: {
            pageUrl: url,
            dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
            intlTrackingNumber: p.trackingNumbers?.[0] || null,
            intlTrackingUrl: null,
            internationalShippingFeeYen: p.internationalShippingFeeYen ?? null,
            domesticShippingFeeYen: p.domesticShippingFeeYen ?? null,
            raw: p,
            lastSeenAt: new Date(),
          },
          create: {
            source: 'fromjapan',
            pageUrl: url,
            packageNumber: p.packageNumber,
            dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
            intlTrackingNumber: p.trackingNumbers?.[0] || null,
            intlTrackingUrl: null,
            internationalShippingFeeYen: p.internationalShippingFeeYen ?? null,
            domesticShippingFeeYen: p.domesticShippingFeeYen ?? null,
            raw: p,
          },
          select: { id: true, packageNumber: true },
        });

        // Replace items (idempotent)
        await prisma.scrapedItem.deleteMany({ where: { scrapedPackageId: up.id } });
        if (p.items?.length) {
          await prisma.scrapedItem.createMany({
            data: p.items.map((it, idx) => ({
              scrapedPackageId: up.id,
              orderNumber: it.orderNumber || null,
              titleJa: it.title || null,
              titleEn: en[idx] || it.title || null,
              itemUrl: it.itemUrl || null,
              listingId: it.listingId || null,
              priceYen: typeof it.priceYen === 'number' ? it.priceYen : null,
            })),
            skipDuplicates: true,
          });
        }

        if (existing) updated++; else inserted++;
      }
    }

    return NextResponse.json({ pagesCrawled, inserted, updated, stopReason }, { status: 200 });
  } catch (e: any) {
    console.error('FJ_CRAWL_ERROR', e);
    return NextResponse.json({ error: e?.message || 'crawl failed', pagesCrawled, inserted, updated }, { status: 500 });
  }
}

```

---

## src/app/api/scrape/route.ts

```ts
import { NextResponse } from 'next/server';
import { scrapeBuyeeShippedList } from '@/scrapers/buyee';

export const dynamic = 'force-dynamic';

export async function POST(request: Request) {
  const { url } = await request.json();
  if (!url || typeof url !== 'string') {
    return NextResponse.json({ error: 'Missing url' }, { status: 400 });
  }

  try {
    const data = await scrapeBuyeeShippedList(url);
    return NextResponse.json(data);
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Scrape failed' }, { status: 500 });
  }
}
```

---

## src/app/api/scrape/zenmarket-crawl/route.ts

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { scrapeZenMarketParcels } from '@/scrapers/zenmarket';

export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  try {
    const { pageUrl } = await req.json().catch(() => ({}));
    const url =
      pageUrl || 'https://zenmarket.jp/en/profile/parcel.aspx?state=5';

    const pkgs = await scrapeZenMarketParcels(url);

    let inserted = 0;
    let updated = 0;

    for (const p of pkgs) {
      const now = new Date();

      // Upsert package WITHOUT nested items to avoid duplicate-creates on reruns
      const existing = await prisma.scrapedPackage.findUnique({
        where: { packageNumber: p.packageNumber },
        select: { id: true, packageNumber: true },
      });

      const up = await prisma.scrapedPackage.upsert({
        where: { packageNumber: p.packageNumber },
        update: {
          source: 'zenmarket',
          pageUrl: p.pageUrl,
          dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
          intlTrackingNumber: p.trackingNumber ?? null,
          intlTrackingUrl: p.trackingUrl ?? null,
          internationalShippingFeeYen: p.internationalShippingFeeYen ?? null,
          domesticShippingFeeYen: p.domesticShippingFeeYen ?? null,
          raw: p.raw,
          lastSeenAt: now,
        },
        create: {
          source: 'zenmarket',
          pageUrl: p.pageUrl,
          packageNumber: p.packageNumber,
          dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
          intlTrackingNumber: p.trackingNumber ?? null,
          intlTrackingUrl: p.trackingUrl ?? null,
          internationalShippingFeeYen: p.internationalShippingFeeYen ?? null,
          domesticShippingFeeYen: p.domesticShippingFeeYen ?? null,
          raw: p.raw,
          firstSeenAt: now,
          lastSeenAt: now,
        },
        select: { id: true },
      });

      // Replace items for this package idempotently
      await prisma.scrapedItem.deleteMany({
        where: { scrapedPackageId: up.id },
      });

      const items = p.items?.create ?? [];
      if (items.length) {
        await prisma.scrapedItem.createMany({
          data: items.map((it) => ({
            scrapedPackageId: up.id,
            orderNumber: it.orderNumber ?? null,
            titleJa: it.titleJa ?? null,
            titleEn: (it.titleEn ?? it.titleJa) ?? null, // JP duplicated to EN upstream
            itemUrl: it.itemUrl ?? null,
            listingId: it.listingId ?? null,
            // Prisma Decimal accepts numbers here
            priceYen:
              typeof it.priceYen === 'number' ? it.priceYen : null,
          })),
          skipDuplicates: true,
        });
      }

      if (existing) updated++;
      else inserted++;
    }

    return NextResponse.json({
      pagesCrawled: 1,
      inserted,
      updated,
      stopReason: '',
    });
  } catch (err: any) {
    return NextResponse.json(
      {
        error: String(err?.message || err) || 'unknown error',
        pagesCrawled: 0,
        inserted: 0,
        updated: 0,
      },
      { status: 500 }
    );
  }
}

```

---

## src/app/api/scraped-packages/[id]/status/route.ts

```ts
// src/app/api/scraped-packages/[id]/status/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

type Status = 'Todo' | 'Processed' | 'Blacklist';

export async function POST(
  req: Request,
  ctx: { params: Promise<{ id: string }> }
) {
  const { id } = await ctx.params;
  const { status } = await req.json().catch(() => ({})) as { status?: Status };

  if (!id || !status || !['Todo','Processed','Blacklist'].includes(status)) {
    return NextResponse.json({ ok: false, error: 'invalid_input' }, { status: 400 });
  }

  try {
    const row = await prisma.scrapedPackage.update({
      where: { id },
      data: { status },
      select: { id: true, status: true },
    });
    return NextResponse.json({ ok: true, id: row.id, status: row.status });
  } catch (e:any) {
    return NextResponse.json({ ok: false, error: e?.message || 'update_failed' }, { status: 500 });
  }
}

```

---

## src/app/api/scraped-packages/route.ts

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

function toNum(d: any) {
  if (!d) return 0;
  if (typeof d === 'number') return d;
  if (typeof d === 'string') return Number(d);
  if (typeof (d as any).toNumber === 'function') return (d as any).toNumber();
  return Number(d);
}

// Accept UI labels or enum strings and normalize to Prisma enum
function normalizeStatus(raw: string | null): 'Todo' | 'Processed' | 'Blacklist' | null {
  if (!raw) return null;
  const s = raw.trim().toLowerCase();
  if (s === 'todo' || s === 'to process' || s === 'to_process' || s === 'to-process' || s === 'toprocess') return 'Todo';
  if (s === 'processed') return 'Processed';
  if (s === 'blacklist' || s === 'blacklisted') return 'Blacklist';
  return null;
}

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);

  const q = searchParams.get('q')?.trim() || '';
  const sort = (searchParams.get('sort') || 'date_desc') as
    | 'date_desc'
    | 'date_asc'
    | 'intl_desc'
    | 'intl_asc'
    | 'dom_desc'
    | 'dom_asc'
    | 'items_desc'
    | 'items_asc';
  const source = searchParams.get('source') || '';
  const statusParam = searchParams.get('status') || '';

  const where: any = {};

  if (q) {
    where.OR = [
      { packageNumber: { contains: q, mode: 'insensitive' } },
      { intlTrackingNumber: { contains: q, mode: 'insensitive' } },
      { pageUrl: { contains: q, mode: 'insensitive' } },
      {
        items: {
          some: {
            OR: [
              { titleJa: { contains: q, mode: 'insensitive' } },
              { titleEn: { contains: q, mode: 'insensitive' } },
              { listingId: { contains: q, mode: 'insensitive' } },
            ],
          },
        },
      },
    ];
  }

  if (source) where.source = source;

  // ✅ status filter (supports UI labels or enum string)
  const status = normalizeStatus(statusParam);
  if (status) where.status = status;

  const orderBy =
    sort === 'date_asc' ? [{ dateShipped: 'asc' }] :
    sort === 'intl_desc' ? [{ internationalShippingFeeYen: 'desc' }] :
    sort === 'intl_asc' ? [{ internationalShippingFeeYen: 'asc' }] :
    sort === 'dom_desc' ? [{ domesticShippingFeeYen: 'desc' }] :
    sort === 'dom_asc' ? [{ domesticShippingFeeYen: 'asc' }] :
    sort === 'items_desc' ? [{ _count: { items: 'desc' } }] :
    sort === 'items_asc' ? [{ _count: { items: 'asc' } }] :
    // default
    [{ dateShipped: 'desc' as const }, { lastSeenAt: 'desc' as const }];

  const data = await prisma.scrapedPackage.findMany({
    where,
    orderBy,
    include: {
      items: {
        select: {
          id: true,
          titleJa: true,
          titleEn: true,
          itemUrl: true,
          listingId: true,
          priceYen: true,
        },
        take: 20,
      },
      _count: { select: { items: true } },
    },
    take: 9999,
  });

  return NextResponse.json(
    data.map((p) => ({
      id: p.id,
      source: p.source,
      pageUrl: p.pageUrl,
      dateShipped: p.dateShipped?.toISOString().slice(0, 10) ?? null,
      packageNumber: p.packageNumber,
      intlTrackingNumber: p.intlTrackingNumber,
      intlTrackingUrl: p.intlTrackingUrl,
      internationalShippingFeeYen: toNum(p.internationalShippingFeeYen),
      domesticShippingFeeYen: toNum(p.domesticShippingFeeYen),
      itemsCount: (p as any)._count.items,
      items: p.items.map((it) => ({
        id: it.id,
        title: it.titleEn || it.titleJa,
        listingId: it.listingId,
        itemUrl: it.itemUrl,
        priceYen: it.priceYen ? toNum(it.priceYen) : null,
      })),
      status: p.status, // 'Todo' | 'Processed' | 'Blacklist'
    }))
  );
}

```

---

## src/app/api/tags/route.ts

```ts
// src/app/api/tags/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

type PlacementRow = {
  id: string;
  tagId: string;
  parentPlacementId: string | null;
  tag: { id: string; name: string; description: string | null };
};

function buildTree(rows: PlacementRow[]) {
  const byParent = new Map<string | null, PlacementRow[]>();
  for (const r of rows) {
    const k = r.parentPlacementId;
    const arr = byParent.get(k);
    if (arr) arr.push(r);
    else byParent.set(k, [r]);
  }
  const makeNode = (r: PlacementRow): any => ({
    placementId: r.id,
    tagId: r.tagId,
    name: r.tag.name,
    description: r.tag.description,
    parentPlacementId: r.parentPlacementId,
    children: (byParent.get(r.id) || [])
      .sort((a, b) => a.tag.name.localeCompare(b.tag.name))
      .map(makeNode),
  });
  const roots = (byParent.get(null) || []).sort((a, b) => a.tag.name.localeCompare(b.tag.name)).map(makeNode);
  return roots;
}

async function rebuildPlacementClosureAll() {
  await prisma.placementClosure.deleteMany({});
  const placements = await prisma.tagPlacement.findMany({ select: { id: true, parentPlacementId: true } });

  // self links
  if (placements.length) {
    await prisma.placementClosure.createMany({
      data: placements.map(p => ({ ancestorPlacementId: p.id, descendantPlacementId: p.id, depth: 0 })),
      skipDuplicates: true,
    });
  }

  // adjacency
  const childrenByParent = new Map<string, string[]>();
  for (const p of placements) {
    if (p.parentPlacementId) {
      const arr = childrenByParent.get(p.parentPlacementId);
      if (arr) arr.push(p.id);
      else childrenByParent.set(p.parentPlacementId, [p.id]);
    }
  }

  // BFS from every node as ancestor (small datasets → simple + correct)
  const pairs: { ancestorPlacementId: string; descendantPlacementId: string; depth: number }[] = [];
  for (const anc of placements) {
    const q: Array<{ id: string; depth: number }> = [{ id: anc.id, depth: 0 }];
    const seen = new Set<string>([anc.id]);
    while (q.length) {
      const { id, depth } = q.shift()!;
      const kids = childrenByParent.get(id) ?? [];
      for (const child of kids) {
        if (!seen.has(child)) {
          seen.add(child);
          pairs.push({ ancestorPlacementId: anc.id, descendantPlacementId: child, depth: depth + 1 });
          q.push({ id: child, depth: depth + 1 });
        }
      }
    }
  }
  if (pairs.length) {
    await prisma.placementClosure.createMany({ data: pairs, skipDuplicates: true });
  }
}

export async function GET(req: NextRequest) {
  const rows = await prisma.tagPlacement.findMany({
    select: {
      id: true,
      tagId: true,
      parentPlacementId: true,
      tag: { select: { id: true, name: true, description: true } },
    },
  });

  const tree = buildTree(rows);

  // parentCounts = how many placements each tag has (for 🔗 icon logic)
  const parentCounts: Record<string, number> = {};
  for (const r of rows) {
    parentCounts[r.tagId] = (parentCounts[r.tagId] || 0) + 1;
  }

  // tags list for client-side name lookup (case-insensitive)
  const tags = await prisma.tag.findMany({ select: { id: true, name: true, description: true } });

  return NextResponse.json({ tree, parentCounts, tags });
}

export async function POST(req: NextRequest) {
  try {
    const { name, description, parentPlacementId } = await req.json();
    if (!name || typeof name !== 'string') {
      return NextResponse.json({ error: 'Name is required.' }, { status: 400 });
    }

    // find tag by name (case-insensitive)
    let tag = await prisma.tag.findFirst({
      where: { name: { equals: name, mode: 'insensitive' } },
      select: { id: true, name: true },
    });

    if (!tag) {
      tag = await prisma.tag.create({ data: { name, description } });
    }

    // create placement under given parent (or root)
    const placement = await prisma.tagPlacement.create({
      data: { tagId: tag.id, parentPlacementId: parentPlacementId ?? null },
      select: {
        id: true,
        tagId: true,
        parentPlacementId: true,
        tag: { select: { id: true, name: true, description: true } },
      },
    });

    await rebuildPlacementClosureAll();
    return NextResponse.json({ placement }, { status: 201 });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Failed to create/link placement.' }, { status: 400 });
  }
}

export async function PATCH(req: NextRequest) {
  try {
    const { tagId, name, description } = await req.json();
    if (!tagId) return NextResponse.json({ error: 'tagId is required.' }, { status: 400 });

    const tag = await prisma.tag.update({
      where: { id: tagId },
      data: { name: name ?? undefined, description: description ?? undefined },
      select: { id: true, name: true, description: true },
    });

    return NextResponse.json({ tag });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Failed to update tag.' }, { status: 400 });
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const { placementId } = await req.json();
    if (!placementId) return NextResponse.json({ error: 'placementId is required.' }, { status: 400 });

    // get tagId of placement
    const placement = await prisma.tagPlacement.findUnique({
      where: { id: placementId },
      select: { id: true, tagId: true, parentPlacementId: true },
    });
    if (!placement) return NextResponse.json({ error: 'Placement not found.' }, { status: 404 });

    // delete this placement
    await prisma.tagPlacement.delete({ where: { id: placementId } });

    // if tag has no more placements and is unused by items, delete the tag too
    const [remainingPlacements, inUse] = await Promise.all([
      prisma.tagPlacement.findFirst({ where: { tagId: placement.tagId }, select: { id: true } }),
      prisma.itemTag.findFirst({ where: { tagId: placement.tagId }, select: { itemId: true } }),
    ]);

    let deletedTag = false;
    if (!remainingPlacements && !inUse) {
      await prisma.tag.delete({ where: { id: placement.tagId } });
      deletedTag = true;
    }

    await rebuildPlacementClosureAll();
    return NextResponse.json({ ok: true, deletedPlacement: true, deletedTag });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Failed to delete placement.' }, { status: 400 });
  }
}

```

---

## src/app/api/tags/serial-lookup/route.ts

```ts
// src/app/api/tags/serial-lookup/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// Basic OCR normalization/corrections for cartridge serials
function normalizeCandidates(input: string): string[] {
  const raw = (input || '').toUpperCase();
  // Extract chunks that look like serial-ish strings
  const tokens = Array.from(new Set(raw.match(/[A-Z0-9\-]{3,}/g) || []));
  const swaps: Record<string, string> = { O: '0', I: '1', Z: '2', S: '5', B: '8', '—': '-', '–': '-' };

  const cands = new Set<string>();
  for (const t of tokens) {
    const base = t.replace(/[–—]/g, '-').replace(/\s+/g, '').trim();
    if (base.length) cands.add(base);
    // swap lookalikes
    let alt = base;
    for (const [k, v] of Object.entries(swaps)) alt = alt.split(k).join(v);
    if (alt !== base) cands.add(alt);
  }
  // Only keep strings that actually include a dash (your rule)
  return Array.from(cands).filter(s => s.includes('-'));
}

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const q = searchParams.get('q') || '';
  const ancestorPlacementId = searchParams.get('ancestorPlacementId') || null;

  const candidates = normalizeCandidates(q);
  if (candidates.length === 0) {
    return NextResponse.json({ matches: [] });
  }

  // If a branch is provided, constrain to tags present under that branch
  let tagIdsScoped: Set<string> | null = null;
  let placementByTagId: Map<string, string> | null = null;

  if (ancestorPlacementId) {
    const desc = await prisma.placementClosure.findMany({
      where: { ancestorPlacementId },
      select: { descendantPlacementId: true },
    });
    const descendantIds = desc.map(d => d.descendantPlacementId);

    if (descendantIds.length) {
      const placements = await prisma.tagPlacement.findMany({
        where: { id: { in: descendantIds } },
        select: { id: true, tagId: true },
      });
      tagIdsScoped = new Set(placements.map(p => p.tagId));
      placementByTagId = new Map(placements.map(p => [p.tagId, p.id]));
    }
  }

  // Find exact name matches first (case-insensitive)
  const exact = await prisma.tag.findMany({
    where: {
      AND: [
        { name: { in: candidates, mode: 'insensitive' } },
        ...(tagIdsScoped ? [{ id: { in: Array.from(tagIdsScoped) } }] : []),
      ],
    },
    select: { id: true, name: true, description: true, photoUrl: true },
    take: 10,
  });

  // If nothing, try contains (still filtered to branch if provided)
  const fallbackNeeded = exact.length === 0;
  const fuzzy = fallbackNeeded
    ? await prisma.tag.findMany({
        where: {
          AND: [
            {
              OR: candidates.map(c => ({ name: { contains: c, mode: 'insensitive' } })),
            },
            ...(tagIdsScoped ? [{ id: { in: Array.from(tagIdsScoped) } }] : []),
          ],
        },
        select: { id: true, name: true, description: true, photoUrl: true },
        take: 10,
      })
    : [];

  const rows = (exact.length ? exact : fuzzy).map(t => ({
    tagId: t.id,
    placementIdUnderBranch: placementByTagId?.get(t.id) ?? null,
    serial: t.name,
    title: t.description,
    photoUrl: t.photoUrl || null,
  }));

  return NextResponse.json({ matches: rows });
}

```

---

## src/app/api/thumb/[listingId]/route.ts

```ts
// app/api/thumb/[listingId]/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

function buyeeAuctionUrl(listingId: string) {
  return `https://buyee.jp/item/jdirectitems/auction/${listingId}`;
}
function rakutenDetailUrl(listingIdRaw: string) {
  // Next params may decode %3A to ':' — ensure it's encoded for the URL path segment
  const encoded = listingIdRaw.includes(':') ? encodeURIComponent(listingIdRaw) : listingIdRaw;
  return `https://buyee.jp/rakuten/detail/${encoded}`;
}
function abs(url: string, base: string) {
  try { return new URL(url, base).toString(); } catch { return url; }
}

// Buyee (Yahoo) extractor
function extractBuyeeImage(html: string, pageUrl: string): string | null {
  const i = html.indexOf('id="itemPhoto_sec"');
  if (i === -1) return null;
  const slice = html.slice(i, i + 120_000); // wider window

  let m = slice.match(/<li[^>]*\sdata-thumb\s*=\s*["']([^"']+)["'][^>]*>/i);
  if (m?.[1]) return abs(m[1], pageUrl);

  m = slice.match(/<a[^>]*\shref\s*=\s*["']([^"']+\.(?:jpg|jpeg|png))(?:\?[^"']*)?["']/i);
  if (m?.[1]) return abs(m[1], pageUrl);

  m = slice.match(/<img[^>]*\sdata-src\s*=\s*["']([^"']+\.(?:jpg|jpeg|png))(?:\?[^"']*)?["']/i);
  if (m?.[1]) return abs(m[1], pageUrl);

  return null;
}

// Rakuten extractor (more forgiving)
function extractRakutenImage(html: string, pageUrl: string): string | null {
  const i = html.indexOf('id="shopping_item_main_image"');
  if (i !== -1) {
    const slice = html.slice(i, i + 120_000);
    // Prefer data-src
    let m = slice.match(/<img[^>]*\sdata-src\s*=\s*["']([^"']+\.(?:jpg|jpeg|png)(?:\?[^"']*)?)["']/i);
    if (m?.[1]) return abs(m[1], pageUrl);
    // Fallback to src
    m = slice.match(/<img[^>]*\ssrc\s*=\s*["']([^"']+\.(?:jpg|jpeg|png)(?:\?[^"']*)?)["'][^>]*>/i);
    if (m?.[1]) {
      const url = m[1];
      // Skip obvious placeholders
      if (!/loading-spacer\.gif/i.test(url)) return abs(url, pageUrl);
    }
  }
  // Last resort: first cdnrakuten image anywhere on page
  const any = html.match(/https?:\/\/[^"'<>]+cdnrakuten\.buyee\.jp[^"'<>]+?\.(?:jpg|jpeg|png)(?:\?[^"'<>]*)?/i);
  if (any?.[0]) return abs(any[0], pageUrl);
  return null;
}

async function fetchText(url: string) {
  const res = await fetch(url, {
    headers: {
      'User-Agent':
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36',
      'Accept-Language': 'en-US,en;q=0.9,ja;q=0.8',
    },
    cache: 'no-store',
  });
  if (!res.ok) throw new Error(`html_fetch_${res.status}`);
  return res.text();
}
async function fetchImage(url: string) {
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`img_fetch_${res.status}`);
  const contentType = res.headers.get('content-type') || 'image/jpeg';
  const buf = Buffer.from(await res.arrayBuffer());
  return { buf, contentType };
}

const MERCARI_RE = /^m\d{11}$/i;

export async function GET(
  req: Request,
  ctx: { params: Promise<{ listingId: string }> }
) {
  const { listingId } = await ctx.params;
  const origin = new URL(req.url).origin;

  const servePlaceholder = async () => {
    const ph = await fetch(new URL('/placeholder-item.png', origin));
    const b = await ph.arrayBuffer();
    return new NextResponse(b, {
      status: 200,
      headers: { 'Content-Type': 'image/png', 'Cache-Control': 'no-store' },
    });
  };

  if (!/^[A-Za-z0-9_%:.-]+$/.test(listingId)) return servePlaceholder();

  // DB cache
  let cachedUrl: string | null = null;
  try {
    const cached = await prisma.listingImageCache.findUnique({ where: { listingId } });
    if (cached?.url) cachedUrl = cached.url;
  } catch {}

  // Resolve if not cached
  if (!cachedUrl) {
    try {
      if (MERCARI_RE.test(listingId)) {
        // Mercari -> direct CDN
        cachedUrl = `https://static.mercdn.net/item/detail/orig/photos/${listingId}_1.jpg`;
        await prisma.listingImageCache.upsert({
          where: { listingId },
          update: { url: cachedUrl, source: 'mercari' },
          create: { listingId, url: cachedUrl, source: 'mercari' },
        });
      } else if (listingId.includes('%3A') || listingId.includes(':')) {
        // Rakuten
        const detailUrl = rakutenDetailUrl(listingId);
        const html = await fetchText(detailUrl);
        cachedUrl = extractRakutenImage(html, detailUrl);
        await prisma.listingImageCache.upsert({
          where: { listingId },
          update: { url: cachedUrl, source: 'rakuten' },
          create: { listingId, url: cachedUrl, source: 'rakuten' },
        });
      } else {
        // Buyee (Yahoo Auctions)
        const pageUrl = buyeeAuctionUrl(listingId);
        const html = await fetchText(pageUrl);
        cachedUrl = extractBuyeeImage(html, pageUrl);
        await prisma.listingImageCache.upsert({
          where: { listingId },
          update: { url: cachedUrl, source: 'buyee' },
          create: { listingId, url: cachedUrl, source: 'buyee' },
        });
      }
    } catch {
      // ignore, fallback below
    }
  }

  // Stream image or placeholder
  try {
    if (cachedUrl) {
      const { buf, contentType } = await fetchImage(cachedUrl);
      return new NextResponse(buf, {
        status: 200,
        headers: { 'Content-Type': contentType, 'Cache-Control': 'no-store' },
      });
    }
  } catch {}

  return servePlaceholder();
}

```

---

## src/app/dashboard/page.tsx

```tsx
export default function DashboardPage() {
  return (
    <div className="rounded-xl border border-gray-800 bg-gray-950 p-6">
      <div className="text-gray-400">Dashboard coming soon…</div>
    </div>
  );
}
```

---

## src/app/globals.css

```css
@import "tailwindcss";

@theme {
  --color-bg:        #0b0f16;
  --color-surface:   color-mix(in oklab, white 6%, var(--color-bg));
  --color-border:    color-mix(in oklab, white 8%, var(--color-bg));
  --color-muted:     #8b9bb3;
  --color-text:      #e6ebf1;
  --color-accent:    #3b82f6;  /* blue-500 */
  --color-success:   #10b981;  /* emerald-500 */
  --radius:          12px;
}

:root { color-scheme: dark; }

body {
  background: var(--color-bg);
  color: var(--color-text);
}

/* nice low-contrast containers */
.card {
  @apply rounded-xl border;
  background: var(--color-surface);
  border-color: color-mix(in oklab, var(--color-border) 100%, transparent);
  box-shadow: 0 10px 30px -20px rgba(0,0,0,.6), inset 0 1px 0 0 rgba(255,255,255,.03);
}

/* inputs */
.field {
  @apply rounded-lg px-3 py-2 text-sm;
  background: color-mix(in oklab, white 5%, var(--color-bg));
  border: 1px solid var(--color-border);
}
.field:focus-visible {
  outline: none;
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--color-accent) 40%, transparent);
}

/* buttons */
.btn {
  @apply rounded-md px-3 py-1.5 text-sm font-medium;
}
.btn-outline {
  @apply border;
  border-color: var(--color-border);
  background: color-mix(in oklab, white 4%, var(--color-bg));
}
.btn-outline:hover { background: color-mix(in oklab, white 7%, var(--color-bg)); }
.btn-primary { background: var(--color-accent); color: white; }
.btn-primary:hover { filter: brightness(1.05); }
.btn-success { background: var(--color-success); color: white; }
.btn-success:hover { filter: brightness(1.05); }

/* subtle separator */
.hr { border-top: 1px solid var(--color-border); }

/* scrollbar */
::-webkit-scrollbar { width: 10px; height: 10px; }
::-webkit-scrollbar-thumb { background: #1f2733; border-radius: 8px; }
::-webkit-scrollbar-track { background: var(--color-bg); }

/* Responsive cards grid: never let a card go below 320px wide */
.cards-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 1.25rem; /* ~= gap-5 */
}

/* somewhere global (e.g., globals.css) */
.btn { cursor: pointer; }

```

---

## src/app/inventory-filler/page.tsx

```tsx
// src/app/inventory-filler/page.tsx
'use client';

import { useEffect, useMemo, useState } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import WeightSliders, { type WeightRow } from '@/components/WeightSliders';
import { percentToPpm, ppmToPercent, PPM_DENOM } from '@/lib/weights';
import { getJpyToEurRate, yenToEuro } from '@/lib/fx.client';
import SingleTagPicker from '@/components/SingleTagPicker';

type Condition = 'Loose' | 'Boxed' | 'CIB' | 'NIB';

type SourceEntry = {
  id?: string;
  nameOverride: string | null;
  quantity: number;
  priceWeightPpm: number;
  shippingWeightPpm: number;
  tagId: string | null;
  tagPlacementId: string | null;
  condition?: Condition; // ✅ new (defaults to 'Loose' in UI)
};

type SourceItem = {
  id: string;
  scrapedItemId?: string | null;
  manualLineId?: string | null;
  /** Optional listing id (needed for /api/thumb/[listingId]) */
  listingId?: string | null;
  title: string;
  priceYen: number;
  shippingWeightPpm: number;
  entries: SourceEntry[];
};

type SessionPayload = {
  session: {
    id: string;
    sourceType: 'ScrapedPackage' | 'Manual';
    customsTotalYen: number;
    finalizedAt?: string | null;
    dateShipped?: string | null;
  };
  fxDateISO?: string | null;
  packageTotals: { intlShip: number; domShip: number; packageShippingTotal: number };
  sourceItems: SourceItem[];
};

type TagFlat = { id: string; name: string; description: string | null };

// Build thumbnail URL if we have a listingId; otherwise null
function thumbUrlFor(item: SourceItem): string | null {
  const lid = (item as any)?.listingId;
  if (lid && typeof lid === 'string' && lid.length > 0) {
    return `/api/thumb/${encodeURIComponent(lid)}`;
  }
  return null;
}

/** Floating image preview that follows the cursor on hover */
function HoverFloat(props: { url: string | null; size?: number; children: React.ReactNode }) {
  const { url, size = 320, children } = props;
  const [show, setShow] = useState(false);
  const [pos, setPos] = useState<{ x: number; y: number }>({ x: 0, y: 0 });

  return (
    <>
      <span
        className="inline-flex items-center"
        onMouseEnter={() => url && setShow(true)}
        onMouseLeave={() => setShow(false)}
        onMouseMove={(e) => setPos({ x: e.clientX, y: e.clientY })}
        style={{ cursor: url ? 'zoom-in' : undefined }}
      >
        {children}
      </span>
      {url && show && (
        <div
          className="fixed z-[9999] pointer-events-none"
          style={{ left: pos.x + 12, top: pos.y + 12 }}
        >
          <div className="rounded-lg border border-white/10 bg-black/90 p-1 shadow-2xl">
            {/* eslint-disable-next-line @next/next/no-img-element */}
            <img
              src={url}
              alt=""
              width={size}
              height={size}
              className="block object-contain max-w-none"
              loading="eager"
            />
          </div>
        </div>
      )}
    </>
  );
}

function fmtEUR(v: number | null | undefined) {
  if (v == null || !isFinite(v)) return '€0.00';
  return v.toLocaleString(undefined, { style: 'currency', currency: 'EUR', minimumFractionDigits: 2, maximumFractionDigits: 2 });
}
function fmtJPY(v: number | null | undefined) {
  if (v == null || !isFinite(v)) return '¥0';
  return `¥${Math.round(v).toLocaleString()}`;
}

async function fetchTags(): Promise<TagFlat[]> {
  const r = await fetch('/api/tags?format=flat', { cache: 'no-store' });
  const j = await r.json();
  return (j.tags || []) as TagFlat[];
}

export default function InventoryFillerPage() {
  const sp = useSearchParams();
  const router = useRouter();

  const [data, setData] = useState<SessionPayload | null>(null);
  const [tags, setTags] = useState<TagFlat[]>([]);
  const [busy, setBusy] = useState(false);

  // FX state
  const [fxRate, setFxRate] = useState<number | null>(null);
  const [fxDateISO, setFxDateISO] = useState<string>('');

  // Customs input: user edits in EUR; we convert to JPY for preview/save
  const [customsEuro, setCustomsEuro] = useState<string>('');
  const [customsDirty, setCustomsDirty] = useState<boolean>(false); // ✅ prevents overwriting user input

  const sessionId = sp.get('sessionId');
  const packageId = sp.get('packageId');

  // Create/reuse session from packageId
  useEffect(() => {
  (async () => {
    if (!sessionId && packageId) {
      // 1) try existing
      const r = await fetch(`/api/fill-sessions/by-package?packageId=${encodeURIComponent(packageId)}`, { cache: 'no-store' });
      if (r.ok) {
        const j = await r.json();
        router.replace(`/inventory-filler?sessionId=${j.sessionId}`);
        return;
      }
      // 2) else create new
      const res = await fetch('/api/fill-sessions', {
        method: 'POST',
        body: JSON.stringify({ sourceType: 'ScrapedPackage', scrapedPackageId: packageId }),
      });
      const j = await res.json();
      if (res.ok) {
        router.replace(`/inventory-filler?sessionId=${j.sessionId}`);
      } else {
        alert(j.error || 'Failed to start session');
      }
    }
  })();
}, [sessionId, packageId, router]);

  // Load session + tags + FX by package shipping date
  useEffect(() => {
    (async () => {
      if (!sessionId) return;
      const res = await fetch(`/api/fill-sessions/${sessionId}`, { cache: 'no-store' });
      const j = await res.json();
      if (!res.ok) {
        alert(j.error || 'Failed to load');
        return;
      }
      setData(j);
      setTags(await fetchTags());

      // Prefer backend-provided date, else other fields, else today
      const shippedISO =
        (j?.fxDateISO && String(j.fxDateISO)) ||
        (j?.scrapedPackage?.dateShipped && new Date(j.scrapedPackage.dateShipped).toISOString().slice(0,10)) ||
        (j?.package?.dateShipped && new Date(j.package.dateShipped).toISOString().slice(0,10)) ||
        (j?.session?.dateShipped && new Date(j.session.dateShipped).toISOString().slice(0,10)) ||
        new Date().toISOString().slice(0, 10);

      setFxDateISO(shippedISO);
      const rate = await getJpyToEurRate(shippedISO);
      setFxRate(rate);
    })();
  }, [sessionId]);

  const packageSubtotal = useMemo(() => {
    if (!data) return 0;
    return data.sourceItems.reduce((a, s) => a + s.priceYen, 0);
  }, [data]);

  const shippingSumOK = useMemo(() => {
    if (!data) return true;
    const sum = data.sourceItems.reduce((a, s) => a + s.shippingWeightPpm, 0);
    return sum === PPM_DENOM;
  }, [data]);

  const finalized = !!data?.session.finalizedAt;

  // Seed customsEuro from DB **only when user hasn't edited yet**
  useEffect(() => {
    if (!data || !fxRate) return;
    if (customsDirty) return; // ✅ don't clobber user's input
    const jpy = Number(data.session.customsTotalYen || 0);
    const eur = yenToEuro(jpy, fxRate);
    setCustomsEuro(Number.isFinite(eur) ? eur.toFixed(2) : '');
  }, [data, fxRate, customsDirty]);

  // Computed JPY value used for previews (current input if available, else saved)
  const customsTotalJPYPreview = useMemo(() => {
    const savedJPY = Number(data?.session.customsTotalYen || 0);
    if (fxRate && isFinite(fxRate)) {
      const eur = Number(customsEuro || '0');
      if (Number.isFinite(eur)) {
        // round to 2 decimals to match storage style
        return Math.round((eur / fxRate) * 100) / 100;
      }
    }
    return savedJPY;
  }, [customsEuro, fxRate, data?.session.customsTotalYen]);

  const onSave = async () => {
    if (!data || finalized) return;
    setBusy(true);
    try {
      const eur = Number(customsEuro || '0');
      const customsJPY = fxRate ? Math.round((eur / (fxRate || 1)) * 100) / 100 : 0;

      const body = {
        customsTotalYen: customsJPY,
        sourceItems: data.sourceItems.map(s => ({ id: s.id, shippingWeightPpm: s.shippingWeightPpm })),
        entriesUpsert: data.sourceItems.flatMap(s =>
          s.entries.map(e => ({
            ...(e.id ? { id: e.id } : {}),
            sourceItemId: s.id,
            nameOverride: e.nameOverride,
            quantity: e.quantity,
            priceWeightPpm: e.priceWeightPpm,
            shippingWeightPpm: e.shippingWeightPpm,
            tagId: e.tagId,
            tagPlacementId: e.tagPlacementId,
            condition: (e.condition ?? 'Loose') as Condition, // ✅ send condition
          }))
        ),
      };

      const res = await fetch(`/api/fill-sessions/${data.session.id}`, {
        method: 'PATCH',
        body: JSON.stringify(body),
      });
      const j = await res.json();
      if (!res.ok) throw new Error(j.error || 'Save failed');

      // ✅ Keep local state in sync so it doesn't "snap back"
      setData(d => d ? { ...d, session: { ...d.session, customsTotalYen: customsJPY } } as SessionPayload : d);
      setCustomsDirty(false);
    } catch (e: any) {
      alert(e.message || 'Save failed');
    } finally {
      setBusy(false);
    }
  };

  const onFinalize = async () => {
    if (!data || finalized) return;
    const sourceOK = data.sourceItems.reduce((a, s) => a + s.shippingWeightPpm, 0) === PPM_DENOM;
    const entrySplitsOK = data.sourceItems.every(s => {
      const priceSum = s.entries.reduce((a, e) => a + e.priceWeightPpm, 0);
      const shipSum = s.entries.reduce((a, e) => a + e.shippingWeightPpm, 0);
      return priceSum === PPM_DENOM && shipSum === PPM_DENOM;
    });
    if (!sourceOK || !entrySplitsOK) {
      alert('Weights must sum to 100% at each level.');
      return;
    }
    setBusy(true);
    try {
      const res = await fetch(`/api/fill-sessions/${data.session.id}/finalize`, { method: 'POST' });
      const j = await res.json();
      if (!res.ok) throw new Error(j.error || 'Finalize failed');
      alert(j.alreadyFinalized ? 'Already finalized (no changes).' : `Created ${j.created} InventoryItems`);
      const res2 = await fetch(`/api/fill-sessions/${data.session.id}`, { cache: 'no-store' });
      setData(await res2.json());
    } catch (e: any) {
      alert(e.message || 'Finalize failed');
    } finally {
      setBusy(false);
    }
  };

  if (!sessionId) {
    return (
      <div className="card p-5">
        Open via a Scraped Package’s “Proceed” (it will take you here with <code>?packageId=…</code>),
        or pass <code>?sessionId=…</code> to continue an existing session.
      </div>
    );
  }
  if (!data) return <div className="card p-6">Loading…</div>;

  return (
    <div className="space-y-5">
      {finalized && (
        <div className="card p-3 bg-emerald-900/20 border border-emerald-700/30 text-emerald-200">
          This session was finalized on <span className="font-mono">{new Date(data.session.finalizedAt!).toLocaleString()}</span>. Editing is disabled.
        </div>
      )}

      {/* Header / package totals */}
      <div className="card p-4">
        <div className="grid sm:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
          <div>
            <div className="text-xs text-gray-400">Session</div>
            <div className="font-medium">{data.session.id}</div>
            <div className="text-xs text-gray-500">{data.session.sourceType}</div>
          </div>
          <div>
            <div className="text-xs text-gray-400">Package subtotal</div>
            <div className="font-medium">
              {fmtEUR(yenToEuro(packageSubtotal, fxRate ?? 0))}{' '}
              <span className="text-gray-500">({fmtJPY(packageSubtotal)})</span>
            </div>
          </div>
          <div>
            <div className="text-xs text-gray-400">Shipping total (intl+dom)</div>
            <div className="font-medium">
              {fmtEUR(yenToEuro(data.packageTotals.packageShippingTotal, fxRate ?? 0))}{' '}
              <span className="text-gray-500">({fmtJPY(data.packageTotals.packageShippingTotal)})</span>
            </div>
          </div>
          <div>
            <label className="text-xs text-gray-400">Customs (EUR)</label>
            <div className="flex items-center gap-2 mt-1">
              <input
                className="field w-full"
                type="number"
                step="0.01"
                inputMode="decimal"
                placeholder="0.00"
                value={customsEuro}
                onChange={e => { setCustomsDirty(true); setCustomsEuro(e.target.value); }} // ✅ mark as dirty
                disabled={finalized}
              />
              <span className="text-xs text-gray-500">
                ({fmtJPY(customsTotalJPYPreview)})
              </span>
            </div>
          </div>

          {/* FX badge */}
          <div className="sm:col-span-2 lg:col-span-4 flex justify-end text-xs">
            <div className="rounded-lg border border-white/10 px-2 py-1">
              FX JPY→EUR {fxDateISO ? `@ ${fxDateISO}` : ''}: <span className="font-medium">{fxRate ? fxRate.toFixed(6) : '—'}</span>
            </div>
          </div>
        </div>

        <div className="mt-3 text-xs">
          Source shipping weights sum:{' '}
          <span className={shippingSumOK ? 'text-emerald-400' : 'text-amber-400'}>
            {ppmToPercent(data.sourceItems.reduce((a, s) => a + s.shippingWeightPpm, 0)).toFixed(1)}%
          </span>
        </div>
      </div>

      {/* Top-level shipping split across source items */}
      <div className="card p-4">
        <WeightSliders
          title="Package → source items shipping split"
          help="Distribute the total package shipping (intl + domestic) across items. Locks keep a row fixed while others redistribute."
          rows={data.sourceItems.map(s => ({
            id: s.id,
            // Wrap the label with a hover preview of the item image
            label: (
              <HoverFloat url={thumbUrlFor(s)} size={320}>
                <span className="cursor-zoom-in underline decoration-dotted decoration-white/30">
                  {s.title}
                </span>
              </HoverFloat>
            ) as any, // cast keeps TS happy if label is typed as string
            ppm: s.shippingWeightPpm,
            rightHint: (
              <span>
                {fmtEUR(yenToEuro(data.packageTotals.packageShippingTotal * (s.shippingWeightPpm / PPM_DENOM), fxRate ?? 0))}{' '}
                <span className="text-gray-500">
                  ({fmtJPY(data.packageTotals.packageShippingTotal * (s.shippingWeightPpm / PPM_DENOM))})
                </span>
              </span>
            ),
          }))}
          onChange={(rows) => {
            if (finalized) return;
            setData(d => !d ? d : ({
              ...d,
              sourceItems: d.sourceItems.map(s => {
                const r = rows.find(x => x.id === s.id)!;
                return { ...s, shippingWeightPpm: r.ppm };
              }),
            }));
          }}
        />
      </div>

      {/* Source items */}
      {data.sourceItems.map((s) => (
        <SourceItemCard
          key={s.id}
          item={s}
          onChange={(next) => {
            if (finalized) return;
            setData(d => !d ? d : ({ ...d, sourceItems: d.sourceItems.map(x => x.id === s.id ? next : x) }));
          }}
          packageShippingTotal={data.packageTotals.packageShippingTotal}
          customsTotalPreview={customsTotalJPYPreview}  // ✅ live preview value
          packageSubtotal={packageSubtotal}
          allTags={tags}
          disabled={finalized}
          fxRate={fxRate ?? 0}
        />
      ))}

      {/* actions */}
      <div className="flex gap-3">
        <button className="btn btn-outline" onClick={onSave} disabled={busy || finalized}>
          {busy ? 'Saving…' : 'Save'}
        </button>
        <button className="btn btn-outline" onClick={onFinalize} disabled={busy || finalized}>
          Finalize → Inventory
        </button>
      </div>
    </div>
  );
}

function SourceItemCard(props: {
  item: SourceItem;
  onChange: (next: SourceItem) => void;
  packageShippingTotal: number;
  customsTotalPreview: number; // ✅ use preview (EUR input converted to JPY)
  packageSubtotal: number;
  allTags: TagFlat[];
  disabled?: boolean;
  fxRate: number;
}) {
  const { item, onChange, packageShippingTotal, customsTotalPreview, packageSubtotal, allTags, disabled, fxRate } = props;

  const sourceShipAlloc = Math.round(packageShippingTotal * (item.shippingWeightPpm / PPM_DENOM));

  const priceRows: WeightRow[] =
    item.entries.length > 0
      ? item.entries.map((e, i) => ({
          id: e.id ?? `new-${i}`,
          label: e.nameOverride || `Entry ${i + 1}`,
          ppm: e.priceWeightPpm,
          rightHint: (
            <span>
              {fmtEUR(yenToEuro(item.priceYen * (e.priceWeightPpm / PPM_DENOM), fxRate))}{' '}
              <span className="text-gray-500">({fmtJPY(item.priceYen * (e.priceWeightPpm / PPM_DENOM))})</span>
            </span>
          ),
        }))
      : [];

  const shipRows: WeightRow[] =
    item.entries.length > 0
      ? item.entries.map((e, i) => ({
          id: e.id ?? `new-${i}`,
          label: e.nameOverride || `Entry ${i + 1}`,
          ppm: e.shippingWeightPpm,
          rightHint: (
            <span>
              {fmtEUR(yenToEuro(sourceShipAlloc * (e.shippingWeightPpm / PPM_DENOM), fxRate))}{' '}
              <span className="text-gray-500">({fmtJPY(sourceShipAlloc * (e.shippingWeightPpm / PPM_DENOM))})</span>
            </span>
          ),
        }))
      : [];

  const entryCustomsPreview = (e: SourceEntry) => {
    if (packageSubtotal <= 0 || customsTotalPreview <= 0) return 0;
    const sourceShare = item.priceYen / packageSubtotal;
    return Math.round(customsTotalPreview * sourceShare * (e.priceWeightPpm / PPM_DENOM));
  };

  return (
    <div className="card p-4 space-y-4">
      <div className="flex items-start justify-between gap-3">
        <div className="flex items-start gap-3">
          {/* Thumbnail (uses /api/thumb/[listingId]) with hover preview */}
          {(() => {
            const url = thumbUrlFor(item);
            return url ? (
              <HoverFloat url={url} size={320}>
                {/* eslint-disable-next-line @next/next/no-img-element */}
                <img
                  src={url}
                  alt={item.title || 'thumbnail'}
                  className="w-16 h-16 rounded-md object-cover border border-white/10"
                  loading="lazy"
                  referrerPolicy="no-referrer"
                />
              </HoverFloat>
            ) : (
              <div className="w-16 h-16 rounded-md border border-white/10 bg-white/5 grid place-items-center text-[10px] text-gray-500">
                no img
              </div>
            );
          })()}
          <div>
            <div className="font-semibold">{item.title}</div>
            <div className="text-xs text-gray-400">
              {fmtEUR(yenToEuro(item.priceYen, fxRate))}{' '}
              <span className="text-gray-500">({fmtJPY(item.priceYen)})</span>
            </div>
            <div className="text-xs text-gray-400">
              This item’s shipping pool:{' '}
              {fmtEUR(yenToEuro(sourceShipAlloc, fxRate))}{' '}
              <span className="text-gray-500">({fmtJPY(sourceShipAlloc)})</span>
            </div>
          </div>
        </div>
        <div>
          <button
            className="btn btn-outline text-xs"
            onClick={() => {
              if (disabled) return;
              const newEntry: SourceEntry = {
                id: undefined,
                nameOverride: null,
                quantity: 1,
                priceWeightPpm: 0,
                shippingWeightPpm: 0,
                tagId: null,
                tagPlacementId: null,
                condition: 'Loose', // ✅ default
              };
              onChange({ ...item, entries: [...item.entries, newEntry] });
            }}
            disabled={disabled}
          >
            + Add entry
          </button>
        </div>
      </div>

      {/* Price split within this source item */}
      {priceRows.length > 0 ? (
        <WeightSliders
          title="Entries → price split"
          help="Split this source item’s base price across its entries. Locks keep an entry fixed while the others redistribute."
          rows={priceRows}
          onChange={(rows) => {
            if (disabled) return;
            onChange({
              ...item,
              entries: item.entries.map(e => {
                const rid = e.id ?? rows.find(r => r.label === (e.nameOverride || ''))?.id;
                const r = rows.find(x => x.id === (e.id ?? rid));
                if (!r) return e;
                return { ...e, priceWeightPpm: r.ppm };
              }),
            });
          }}
        />
      ) : (
        <div className="rounded-xl border border-white/10 p-3 text-xs text-gray-400">Add entries to split price and shipping.</div>
      )}

      {/* Shipping split within this source item */}
      {shipRows.length > 0 && (
        <WeightSliders
          title="Entries → shipping split"
          help="Split this source item’s shipping share across its entries. Locks keep an entry fixed while the others redistribute."
          rows={shipRows}
          onChange={(rows) => {
            if (disabled) return;
            onChange({
              ...item,
              entries: item.entries.map(e => {
                const rid = e.id ?? rows.find(r => r.label === (e.nameOverride || ''))?.id;
                const r = rows.find(x => x.id === (e.id ?? rid));
                if (!r) return e;
                return { ...e, shippingWeightPpm: r.ppm };
              }),
            });
          }}
        />
      )}

      {/* Entries editor */}
      <div className="rounded-lg border border-white/10 divide-y divide-white/10">
        {item.entries.map((e, i) => (
          <div key={e.id || i} className="p-3 grid md:grid-cols-7 gap-3 items-center">
            <div className="md:col-span-2">
              <input
                className="field w-full"
                placeholder="Name (optional override)"
                value={e.nameOverride ?? ''}
                onChange={ev => onChange({ ...item, entries: item.entries.map(x => x === e ? { ...e, nameOverride: ev.target.value } : x) })}
                disabled={disabled}
              />
              <div className="mt-2 flex flex-wrap gap-1">
                <SingleTagPicker
                  value={e.tagId ?? null}
                  onChange={(sel) => {
                    const tagId = sel?.tagId ?? null;
                    const placementId = sel?.placementId ?? null;
                    // Auto-fill name only if blank: prefer tag description, then name
                    let nextName = e.nameOverride ?? '';
                    const isBlank = !nextName || nextName.trim().length === 0;
                    if (isBlank && tagId) {
                      const t = allTags.find(t => t.id === tagId);
                      const candidate = (t?.description?.trim() || t?.name || '').trim();
                      if (candidate) nextName = candidate;
                    }
                    onChange({
                      ...item,
                      entries: item.entries.map(x =>
                        x === e ? { ...e, tagId, tagPlacementId: placementId, nameOverride: nextName } : x
                      ),
                    });
                  }}
                />
              </div>
            </div>

            <div>
              <label className="block text-xs text-gray-400">Qty</label>
              <input
                type="number"
                className="field w-20"
                min={1}
                value={e.quantity}
                onChange={ev => onChange({
                  ...item,
                  entries: item.entries.map(x => x === e ? { ...e, quantity: Math.max(1, parseInt(ev.target.value || '1', 10)) } : x),
                })}
                disabled={disabled}
              />
            </div>

            {/* ✅ Condition selector (kept compact) */}
            <div>
              <label className="block text-xs text-gray-400">Condition</label>
              <select
                className="field w-28"
                value={e.condition ?? 'Loose'}
                onChange={ev =>
                  onChange({
                    ...item,
                    entries: item.entries.map(x => x === e ? { ...e, condition: ev.target.value as Condition } : x),
                  })
                }
                disabled={disabled}
              >
                <option value="Loose">Loose</option>
                <option value="Boxed">Boxed</option>
                <option value="CIB">CIB</option>
                <option value="NIB">NIB</option>
              </select>
            </div>

            <div>
              <div className="text-xs text-gray-400">Base preview</div>
              <div className="text-sm">
                {fmtEUR(yenToEuro(item.priceYen * (e.priceWeightPpm / PPM_DENOM), fxRate))}
                <div className="text-xs text-gray-500">
                  {fmtJPY(item.priceYen * (e.priceWeightPpm / PPM_DENOM))}
                </div>
              </div>
            </div>

            <div>
              <div className="text-xs text-gray-400">Ship + customs preview</div>
              <div className="text-sm">
                {fmtEUR(yenToEuro(sourceShipAlloc * (e.shippingWeightPpm / PPM_DENOM), fxRate))}
                {' + '}
                {fmtEUR(yenToEuro(entryCustomsPreview(e), fxRate))}
                <div className="text-xs text-gray-500">
                  {fmtJPY(sourceShipAlloc * (e.shippingWeightPpm / PPM_DENOM))} + {fmtJPY(entryCustomsPreview(e))}
                </div>
              </div>
            </div>

            <div>
              <div className="text-xs text-gray-400">Est. total / unit</div>
              <div className="text-sm">
                {(() => {
                  const basePartJPY = Math.round(item.priceYen * (e.priceWeightPpm / PPM_DENOM));
                  const shipPartJPY = Math.round(sourceShipAlloc * (e.shippingWeightPpm / PPM_DENOM));
                  const customsPartJPY = entryCustomsPreview(e); // already in JPY
                  const totalJPY = basePartJPY + shipPartJPY + customsPartJPY;
                  const perUnitJPY = Math.round(totalJPY / Math.max(1, e.quantity));
                  return (
                    <div>
                      {fmtEUR(yenToEuro(perUnitJPY, fxRate))}
                      <div className="text-xs text-gray-500">{fmtJPY(perUnitJPY)}</div>
                    </div>
                  );
                })()}
              </div>
            </div>

            <div className="md:col-span-7 flex justify-end">
              <button
                className="btn btn-outline text-xs"
                onClick={() => onChange({ ...item, entries: item.entries.filter(x => x !== e) })}
                disabled={disabled}
              >
                🗑️ Remove
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

```

---

## src/app/inventory/page.tsx

```tsx
// src/app/inventory/page.tsx
'use client';

import { useEffect, useMemo, useState } from 'react';
import { getJpyToEurRate, yenToEuro } from '@/lib/fx.client';

type Row = {
  id: string;
  name: string;
  condition: string; // Loose | Boxed | CIB | NIB
  tagChain: string;  // "Foo (Root > Branch > Leaf) • Bar (…)”
  fxDateISO: string | null;
  packageNumber: string | null;
  purchaseDateISO: string | null;
  jpy: {
    basePerUnit: number;
    shipPerUnit: number;
    customsPerUnit: number;
    totalPerUnit: number;
  };
};

type ApiResp = { items: Row[]; nextCursor: string | null };

function fmtEUR(v: number | null | undefined) {
  if (v == null || !isFinite(v)) return '€0.00';
  return v.toLocaleString(undefined, {
    style: 'currency',
    currency: 'EUR',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  });
}
function fmtJPY(v: number | null | undefined) {
  if (v == null || !isFinite(v)) return '¥0';
  return `¥${Math.round(v).toLocaleString()}`;
}

export default function InventoryPage() {
  // filters
  const [filters, setFilters] = useState<string[]>([]);
  const [draft, setDraft] = useState('');

  // data
  const [rows, setRows] = useState<Row[]>([]);
  const [cursor, setCursor] = useState<string | null>(null);
  const [busy, setBusy] = useState(false);

  // selection
  const [selected, setSelected] = useState<Record<string, boolean>>({});

  // FX cache
  const [rates, setRates] = useState<Record<string, number>>({});
  const todayISO = useMemo(() => new Date().toISOString().slice(0, 10), []);

  // URL sync for filters
  useEffect(() => {
    const params = new URLSearchParams();
    for (const f of filters) params.append('q', f);
    const qs = params.toString();
    const url = qs ? `/inventory?${qs}` : '/inventory';
    window.history.replaceState(null, '', url);
  }, [filters]);

  async function ensureRates(dates: (string | null)[]) {
    const unique = Array.from(
      new Set(
        dates.map(d => (d && d.length ? d : todayISO)).filter(Boolean) as string[],
      ),
    ).filter(d => rates[d] == null);

    if (!unique.length) return;

    const fetched = await Promise.all(
      unique.map(async (d) => {
        try {
          const r = await getJpyToEurRate(d);
          return [d, r] as const;
        } catch {
          return [d, NaN] as const;
        }
      }),
    );

    setRates(prev => {
      const next = { ...prev };
      for (const [d, r] of fetched) next[d] = r;
      return next;
    });
  }

  async function load(opts: { reset?: boolean; cursor?: string | null } = {}) {
    const { reset = false, cursor: cur = null } = opts;
    setBusy(true);
    try {
      const url = new URL('/api/inventory', window.location.origin);
      url.searchParams.set('limit', '50');
      if (cur) url.searchParams.set('cursor', cur);
      for (const f of filters) url.searchParams.append('q', f);

      const r = await fetch(url.toString(), { cache: 'no-store' });
      const j: ApiResp = await r.json();
      if (!r.ok) throw new Error((j as any)?.error || 'load_failed');

      const page = j.items || [];
      setRows(prev => (reset ? page : [...prev, ...page]));
      setCursor(j.nextCursor ?? null);
      await ensureRates(page.map(x => x.fxDateISO));

      // if we reset, clear selection (only selected on current page)
      if (reset) setSelected({});
    } catch (e: any) {
      alert(e.message || 'Load failed');
    } finally {
      setBusy(false);
    }
  }

  // initial load + hydrate filters from URL
  useEffect(() => {
    const sp = new URLSearchParams(window.location.search);
    const qs = sp.getAll('q').map(s => s.trim()).filter(Boolean);
    if (qs.length) setFilters(qs);
    load({ reset: true });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // reload when filters change
  useEffect(() => {
    load({ reset: true });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [filters.join('\u0001')]);

  function addFilter() {
    const v = draft.trim();
    if (!v) return;
    if (!filters.includes(v)) setFilters(prev => [...prev, v]);
    setDraft('');
  }
  function removeFilter(f: string) { setFilters(prev => prev.filter(x => x !== f)); }

  function eurFor(jpy: number, d: string | null) {
    const key = d && d.length ? d : todayISO;
    const rate = rates[key];
    if (!Number.isFinite(rate)) return 0;
    return yenToEuro(jpy, rate);
  }

  // selection helpers
  const selectedIds = useMemo(() => Object.keys(selected).filter(id => selected[id]), [selected]);
  const allOnPageSelected = rows.length > 0 && rows.every(r => selected[r.id]);
  function toggleRow(id: string) {
    setSelected(prev => ({ ...prev, [id]: !prev[id] }));
  }
  function toggleAllOnPage() {
    if (allOnPageSelected) {
      const next = { ...selected };
      for (const r of rows) delete next[r.id];
      setSelected(next);
    } else {
      const next = { ...selected };
      for (const r of rows) next[r.id] = true;
      setSelected(next);
    }
  }
  function goScan() {
    const ids = selectedIds.join(',');
    if (!ids) return;
    // Serial uniqueness: no branch is required; scan page can operate without ancestorPlacementId
    window.location.href = `/inventory/scan?ids=${encodeURIComponent(ids)}`;
  }

  return (
    <div className="space-y-4">
      <h1 className="text-xl font-semibold">Inventory</h1>
      <p className="text-xs text-gray-400">
        Per-unit prices computed from session splits and FX on package date.
      </p>

      {/* Filters + actions */}
      <div className="rounded-lg border border-white/10 p-2">
        <div className="flex flex-wrap items-center gap-2">
          {filters.map(f => (
            <span
              key={f}
              className="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/5 px-2 py-1 text-xs"
            >
              {f}
              <button className="hover:text-red-300" onClick={() => removeFilter(f)} title="Remove filter">✕</button>
            </span>
          ))}

          <input
            className="field min-w-[14rem] flex-1"
            placeholder="Search by name, tag, or package # …"
            value={draft}
            onChange={e => setDraft(e.target.value)}
            onKeyDown={e => {
              if (e.key === 'Enter' || e.key === ',') { e.preventDefault(); addFilter(); }
              if (e.key === 'Escape') setDraft('');
            }}
          />
          <button className="btn btn-outline" onClick={addFilter}>Add</button>
          {filters.length > 0 && (
            <button className="btn btn-outline" onClick={() => setFilters([])}>Clear</button>
          )}

          {/* Right-side actions */}
          <div className="ml-auto flex items-center gap-2">
            <button className="btn btn-outline" onClick={toggleAllOnPage} disabled={rows.length === 0}>
              {allOnPageSelected ? 'Unselect page' : 'Select page'}
            </button>
            <button
              className="btn btn-primary disabled:opacity-50"
              onClick={goScan}
              disabled={selectedIds.length === 0}
              title={selectedIds.length ? `${selectedIds.length} selected` : 'Select items first'}
            >
              📱 Scan selected
            </button>
          </div>
        </div>
      </div>

      {/* Table */}
      <div className="rounded-lg border border-white/10 overflow-hidden">
        <table className="w-full text-sm">
          <thead className="bg-white/5 text-xs text-gray-400">
            <tr>
              <th className="px-3 py-2 text-left w-10">
                <input
                  type="checkbox"
                  aria-label="Select all on page"
                  checked={allOnPageSelected}
                  onChange={toggleAllOnPage}
                />
              </th>
              <th className="px-3 py-2 text-left">Name</th>
              <th className="px-3 py-2 text-left">Tags</th>
              <th className="px-3 py-2 text-left">Condition</th>
              <th className="px-3 py-2 text-left">Item price</th>
              <th className="px-3 py-2 text-left">Real price</th>
              <th className="px-3 py-2 text-left">Package #</th>
              <th className="px-3 py-2 text-left">Purchase date</th>
            </tr>
          </thead>
          <tbody>
            {rows.map((r) => {
              const baseEUR = eurFor(r.jpy.basePerUnit, r.fxDateISO);
              const totalEUR = eurFor(r.jpy.totalPerUnit, r.fxDateISO);
              return (
                <tr key={r.id} className="border-t border-white/10">
                  <td className="px-3 py-2">
                    <input
                      type="checkbox"
                      checked={!!selected[r.id]}
                      onChange={() => toggleRow(r.id)}
                      aria-label={`Select ${r.name || r.id}`}
                    />
                  </td>
                  <td className="px-3 py-2">{r.name || '—'}</td>
                  <td className="px-3 py-2">{r.tagChain || '—'}</td>
                  <td className="px-3 py-2">{r.condition || '—'}</td>
                  <td className="px-3 py-2">
                    <div>{fmtEUR(baseEUR)}</div>
                    <div className="text-xs text-gray-500">{fmtJPY(r.jpy.basePerUnit)}</div>
                  </td>
                  <td className="px-3 py-2">
                    <div>{fmtEUR(totalEUR)}</div>
                    <div className="text-xs text-gray-500">{fmtJPY(r.jpy.totalPerUnit)}</div>
                  </td>
                  <td className="px-3 py-2">{r.packageNumber ?? '—'}</td>
                  <td className="px-3 py-2">{r.purchaseDateISO ?? '—'}</td>
                </tr>
              );
            })}
          </tbody>
        </table>

        {rows.length === 0 && !busy && (
          <div className="p-6 text-center text-sm text-gray-400">No items yet.</div>
        )}

        <div className="flex items-center justify-between px-3 py-2 text-xs text-gray-400">
          <div>{rows.length} items • {selectedIds.length} selected</div>
          <button
            className="btn btn-outline"
            onClick={() => load({ cursor })}
            disabled={!cursor || busy}
          >
            {busy ? 'Loading…' : (cursor ? 'Load more' : 'No more')}
          </button>
        </div>
      </div>
    </div>
  );
}

```

---

## src/app/inventory/scan/page.tsx

```tsx
'use client';

import { useEffect, useMemo, useRef, useState } from 'react';
import { useSearchParams } from 'next/navigation';

type Match = {
  tagId: string;
  placementIdUnderBranch: string | null;
  serial: string;
  title: string | null;
  photoUrl: string | null;
};

async function serialLookup(text: string): Promise<Match[]> {
  const sp = new URLSearchParams();
  sp.set('q', text);
  const r = await fetch(`/api/tags/serial-lookup?${sp.toString()}`, { cache: 'no-store' });
  const j = await r.json();
  return (j.matches || []) as Match[];
}

async function assignTag(itemId: string, tagId: string, placementId?: string | null) {
  const r = await fetch('/api/inventory/assign-tag', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      itemIds: [itemId],
      tagId,
      placementId: placementId ?? undefined,
    }),
  });
  if (!r.ok) {
    const j = await r.json().catch(() => ({}));
    throw new Error(j.error || 'assign_failed');
  }
}

/* ------------------------ OCR (static, no workers) ------------------------ */

let tMod: any = null;
async function recognizeText(dataUrl: string, psm: '7'|'6' = '7'): Promise<string> {
  if (!tMod) tMod = await import('tesseract.js');
  const recognize = tMod?.recognize || tMod?.default?.recognize || tMod?.Tesseract?.recognize;
  if (typeof recognize !== 'function') throw new Error('tesseract_unavailable');

  const opts = {
    tessedit_pageseg_mode: psm,                           // 7 = single line (preferred)
    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-',
    tessedit_char_blacklist: 'abcdefghijklmnopqrstuvwxyz_~`!@#$%^&*()+=[]{}|\\;:\'",.<>/?',
    load_system_dawg: '0',
    load_freq_dawg: '0',
    preserve_interword_spaces: '1',
    classify_bln_numeric_mode: '0',
    user_defined_dpi: '300',
  } as any;

  const res = await recognize(dataUrl, 'eng', opts);
  return ((res?.data?.text || (res as any)?.text || '') as string).toUpperCase();
}

/* ---------------------- Candidate extraction (light) ---------------------- */

function extractSerialCandidates(text: string): string[] {
  const up = text.toUpperCase().replace(/[–—]/g, '-');
  // Only allow A–Z, 0–9, dash and spaces to be safe
  const cleaned = up.replace(/[^A-Z0-9\-\s]/g, ' ').replace(/\s+/g, ' ').trim();
  const tokens = Array.from(new Set((cleaned.match(/[A-Z0-9\-]{3,}/g) || []).map(t => t.trim())));
  // serial-like: must contain at least one dash, reasonable length
  return tokens.filter(s => s.includes('-') && s.length >= 5 && s.length <= 28);
}

function bestCandidate(cands: string[]): string | null {
  if (!cands.length) return null;
  const score = (s: string) => {
    const dashCount = (s.match(/-/g) || []).length;
    const dashInside = (s.indexOf('-') > 0 && s.lastIndexOf('-') < s.length - 1) ? 2 : 0;
    return s.length * 2 + dashCount + dashInside;
  };
  return cands.sort((a, b) => score(b) - score(a))[0] || null;
}

/* --------------------------- Light preprocessing -------------------------- */

// 1) crop a small center band from video/canvas, scale to target width
function cropBand(videoOrCanvas: HTMLVideoElement | HTMLCanvasElement, targetW = 640) : HTMLCanvasElement {
  const vw = (videoOrCanvas as any).videoWidth || (videoOrCanvas as HTMLCanvasElement).width || 1280;
  const vh = (videoOrCanvas as any).videoHeight || (videoOrCanvas as HTMLCanvasElement).height || 720;

  const bandH = Math.floor(vh * 0.24);
  const bandY = Math.floor((vh - bandH) / 2);
  const bandW = Math.floor(vw * 0.76);
  const bandX = Math.floor((vw - bandW) / 2);

  const outH = Math.round(targetW * (bandH / bandW));
  const c = document.createElement('canvas');
  c.width = targetW; c.height = outH;
  const ctx = c.getContext('2d', { willReadFrequently: true })!;
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(videoOrCanvas as any, bandX, bandY, bandW, bandH, 0, 0, targetW, outH);
  return c;
}

// 2) very light grayscale + contrast stretch (clip 2%)
function toGrayscaleContrast(src: HTMLCanvasElement): HTMLCanvasElement {
  const c = document.createElement('canvas');
  c.width = src.width; c.height = src.height;
  const ctx = c.getContext('2d', { willReadFrequently: true })!;
  ctx.drawImage(src, 0, 0);
  const img = ctx.getImageData(0, 0, c.width, c.height);
  const d = img.data;

  const hist = new Uint32Array(256);
  for (let i = 0; i < d.length; i += 4) {
    const y = (d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114) | 0;
    d[i] = d[i+1] = d[i+2] = y;
    hist[y]++;
  }
  const total = d.length / 4;
  const clip = Math.floor(total * 0.02);
  let min = 0, max = 255, acc = 0;
  for (let i = 0; i < 256; i++) { acc += hist[i]; if (acc > clip) { min = i; break; } }
  acc = 0;
  for (let i = 255; i >= 0; i--) { acc += hist[i]; if (acc > clip) { max = i; break; } }
  const rng = Math.max(1, max - min);
  for (let i = 0; i < d.length; i += 4) {
    const y = Math.max(0, Math.min(255, Math.round((d[i] - min) * 255 / rng)));
    d[i] = d[i+1] = d[i+2] = y;
  }
  ctx.putImageData(img, 0, 0);
  return c;
}

// 3) mild binarization (global threshold based on mid gray)
function toMildBinary(src: HTMLCanvasElement): HTMLCanvasElement {
  const c = document.createElement('canvas');
  c.width = src.width; c.height = src.height;
  const ctx = c.getContext('2d', { willReadFrequently: true })!;
  ctx.drawImage(src, 0, 0);
  const img = ctx.getImageData(0, 0, c.width, c.height);
  const d = img.data;

  // compute mean gray
  let sum = 0, cnt = 0;
  for (let i = 0; i < d.length; i += 4) { sum += d[i]; cnt++; }
  const mean = sum / Math.max(1, cnt);
  const T = Math.min(220, Math.max(80, Math.round(mean * 0.95))); // gentle

  for (let i = 0; i < d.length; i += 4) {
    const v = d[i] > T ? 255 : 0;
    d[i] = d[i+1] = d[i+2] = v;
  }
  ctx.putImageData(img, 0, 0);
  return c;
}

/* --------------------------------- Page ---------------------------------- */

export default function ScanInventoryPage() {
  const sp = useSearchParams();
  const idsParam = sp.get('ids') || '';
  const itemIds = useMemo(() => idsParam.split(',').map(s => s.trim()).filter(Boolean), [idsParam]);

  const [idx, setIdx] = useState(0);
  const currentItemId = itemIds[idx] || null; // single declaration

  const videoRef = useRef<HTMLVideoElement | null>(null);

  const [live, setLive] = useState(true);          // auto-scan loop
  const [scanning, setScanning] = useState(false); // throttle
  const [locked, setLocked] = useState<Match | null>(null);

  const [lastText, setLastText] = useState('');
  const [matches, setMatches] = useState<Match[]>([]);
  const [manualSerial, setManualSerial] = useState('');
  const [err, setErr] = useState<string | null>(null);

  // start camera (small preview)
  useEffect(() => {
    let stream: MediaStream | null = null;
    (async () => {
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: 'environment' },
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
          audio: false,
        });
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          await videoRef.current.play();
        }
      } catch (e: any) {
        setErr(e?.message || 'camera_error');
      }
    })();
    return () => { if (stream) stream.getTracks().forEach(t => t.stop()); };
  }, []);

  // live loop — every ~1s, try light passes until we get a candidate; lock if DB match
  useEffect(() => {
    if (!live || locked) return;
    const id = setInterval(async () => {
      if (scanning) return;
      try {
        setScanning(true);
        const v = videoRef.current;
        if (!v || v.readyState < 2) return;

        // 1) raw crop
        const band = cropBand(v, 640);

        // Try variants in order: raw → gray/contrast → mild binary
        const variants: string[] = [];
        variants.push(band.toDataURL('image/png'));

        const gray = toGrayscaleContrast(band);
        variants.push(gray.toDataURL('image/png'));

        const bin = toMildBinary(gray);
        variants.push(bin.toDataURL('image/png'));

        let bestTextLocal = '';
        let topCandidate: string | null = null;

        for (const durl of variants) {
          // First with PSM 7 (single line), then fallback PSM 6 if needed
          let text = await recognizeText(durl, '7');
          if (!text || !text.includes('-')) {
            const t6 = await recognizeText(durl, '6');
            if ((t6?.length || 0) > (text?.length || 0)) text = t6;
          }
          if (text && text.length > bestTextLocal.length) bestTextLocal = text;

          const cands = extractSerialCandidates(text);
          const top = bestCandidate(cands);
          if (top) { topCandidate = top; break; }
        }

        setLastText(bestTextLocal);

        if (!topCandidate) return;

        const ms = await serialLookup(topCandidate);
        setMatches(ms);

        if (ms.length) {
          setLive(false);
          setLocked(ms[0]);
          // @ts-ignore
          if (navigator.vibrate) navigator.vibrate(25);
        }
      } catch (e: any) {
        setErr(e?.message || 'scan_failed');
      } finally {
        setScanning(false);
      }
    }, 1000);
    return () => clearInterval(id);
  }, [live, locked, scanning]);

  // manual override live lookup when paused
  useEffect(() => {
    if (!manualSerial.trim() || live) return;
    const t = setTimeout(async () => {
      try {
        const ms = await serialLookup(manualSerial.trim().toUpperCase());
        setMatches(ms);
      } catch {}
    }, 200);
    return () => clearTimeout(t);
  }, [manualSerial, live]);

  async function confirm(m: Match) {
    if (!currentItemId) return;
    try {
      await assignTag(currentItemId, m.tagId, m.placementIdUnderBranch);
      // move to next and resume scanning
      setLocked(null);
      setMatches([]);
      setManualSerial('');
      if (idx < itemIds.length - 1) {
        setIdx(idx + 1);
        setLive(true);
      } else {
        alert('All selected items processed.');
      }
    } catch (e: any) {
      alert(e?.message || 'Failed to assign tag.');
    }
  }

  function resume() {
    setLocked(null);
    setMatches([]);
    setManualSerial('');
    setLive(true);
  }

  return (
    <div className="space-y-4">
      <h1 className="text-lg font-semibold">Scan & Match Game Serials</h1>
      <div className="text-sm text-gray-400">
        Items: {itemIds.length} • Current: {idx + 1}/{itemIds.length}
      </div>

      {!currentItemId ? (
        <div className="text-gray-400">No items left. Pass <code>?ids=ID1,ID2</code> in the URL.</div>
      ) : (
        <>
          {/* Compact camera header */}
          <div className="rounded-xl border border-white/10 p-3">
            <div className="flex items-center gap-3">
              <div className="relative w-56 h-32 shrink-0 overflow-hidden rounded-lg border border-white/10 bg-black">
                <video ref={videoRef} playsInline muted className="h-full w-full object-cover" />
                <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
                  <div className="w-[78%] h-[34%] border border-white/60 rounded-md" />
                </div>
              </div>
              <div className="flex-1">
                <label className="inline-flex items-center gap-2 text-sm">
                  <input type="checkbox" checked={live && !locked} onChange={(e) => setLive(e.target.checked)} disabled={!!locked} />
                  Live scan
                </label>
                {scanning && <span className="ml-3 text-xs text-gray-400">scanning…</span>}
                {err && <span className="ml-3 text-xs text-red-400">{err}</span>}
                <div className="mt-2 text-xs text-gray-400">Keep the serial inside the box. It will lock when detected.</div>
              </div>
            </div>
          </div>

          {/* Results & manual override */}
          <div className="rounded-xl border border-white/10 p-3 space-y-3">
            <div className="text-xs text-gray-400">Manual override (optional):</div>
            <input
              className="field w-full"
              placeholder="Type serial (e.g., DMG-XXXX-JPN)…"
              value={manualSerial}
              onChange={(e) => setManualSerial(e.target.value)}
              autoCapitalize="characters"
              autoCorrect="off"
              spellCheck={false}
              disabled={!!locked}
            />

            <div className="text-xs text-gray-400">Matches:</div>
            {matches.length === 0 && <div className="text-gray-400 text-sm">No matches yet.</div>}

            <div className="space-y-3">
              {matches.map((m, i) => (
                <div key={m.tagId + i} className={`flex items-center gap-3 rounded border p-2 ${locked?.tagId === m.tagId ? 'border-green-500/60' : 'border-white/10'}`}>
                  {/* eslint-disable-next-line @next/next/no-img-element */}
                  {m.photoUrl ? <img src={m.photoUrl} alt="" className="w-16 h-16 object-contain rounded" /> : <div className="w-16 h-16 grid place-items-center text-xs text-gray-500">No img</div>}
                  <div className="flex-1">
                    <div className="font-mono text-sm">{m.serial}</div>
                    <div className="text-xs text-gray-400">{m.title || '—'}</div>
                  </div>
                  <button className="btn btn-outline" onClick={() => confirm(m)}>✅ Confirm</button>
                </div>
              ))}
            </div>

            {!!locked && (
              <div className="pt-2 flex items-center gap-2">
                <button className="btn btn-outline" onClick={resume}>↻ Resume</button>
              </div>
            )}
          </div>

          <div className="text-xs text-gray-400">
            Current itemId: <code className="text-gray-300">{currentItemId}</code>
          </div>
        </>
      )}
    </div>
  );
}

```

---

## src/app/layout.tsx

```tsx
// src/app/layout.tsx
import './globals.css';
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import AppShell from '@/components/AppShell';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: process.env.NEXT_PUBLIC_APP_NAME || 'Proxy Dashboard',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" className="h-full">
      <body className={`${inter.className} h-full bg-[#0b0f16] text-gray-100 antialiased`}>
        <AppShell>{children}</AppShell>
      </body>
    </html>
  );
}

```

---

## src/app/page.tsx

```tsx
import { redirect } from 'next/navigation';
export default function Home() { redirect('/dashboard'); }
```

---

## src/app/scraped-packages/page.tsx

```tsx
// src/app/scraped-packages/page.tsx
import ScrapedPackagesClient from './scraped-packages.client';

export const dynamic = 'force-dynamic';

export default async function ScrapedPackagesPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | string[] | undefined>>;
}) {
  const sp = await searchParams; // <-- important

  const initialQuery = Object.fromEntries(
    Object.entries(sp || {}).map(([k, v]) => [k, String(v ?? '')])
  );

  return <ScrapedPackagesClient initialQuery={initialQuery} />;
}

```

---

## src/app/scraped-packages/scraped-packages.client.tsx

```tsx
'use client';
import { useEffect, useMemo, useState, useCallback } from 'react';
import ScrapedPackageCard from './ui/ScrapedPackageCard';
import ScrapedToolbar from './ui/ScrapedToolbar';
import ScrapersBar from './ui/ScrapersBar';

type ScrapedItemPreview = {
  id: string;
  title: string | null;
  listingId: string | null;
  itemUrl: string | null;
  priceYen: number | null;
};

export type ScrapedPackageRow = {
  id: string;
  source: string;
  pageUrl: string;
  dateShipped: string | null;
  packageNumber: string;
  intlTrackingNumber: string | null;
  intlTrackingUrl: string | null;
  internationalShippingFeeYen: number;
  domesticShippingFeeYen: number;
  itemsCount: number;
  items: ScrapedItemPreview[];
  status: 'Todo' | 'Processed' | 'Blacklist';
};

export default function ScrapedPackagesClient({ initialQuery }: { initialQuery: Record<string,string> }) {
  const [q, setQ] = useState(initialQuery.q || '');
  const [source, setSource] = useState(initialQuery.source || '');
  const [sort, setSort] = useState((initialQuery.sort as any) || 'date_desc');
  const [status, setStatus] = useState(initialQuery.status || '');
  const [data, setData] = useState<ScrapedPackageRow[] | null>(null);
  const [loading, setLoading] = useState(false);

  // block refetches while a run is happening
  const [isRunning, setIsRunning] = useState(false);

  const params = useMemo(() => {
    const sp = new URLSearchParams();
    if (q) sp.set('q', q);
    if (source) sp.set('source', source);
    if (status) sp.set('status', status);
    if (sort) sp.set('sort', sort);
    return sp.toString();
  }, [q, source, status, sort]);

  const load = useCallback(async () => {
    setLoading(true);
    try {
      const r = await fetch(`/api/scraped-packages?${params}`);
      const j = await r.json();
      setData(j);
    } finally {
      setLoading(false);
    }
  }, [params]);

  // normal refetch on params change, but NOT while a run is happening
  useEffect(() => {
    if (!isRunning) load();
  }, [load, isRunning]);

  const handleRunStart = () => setIsRunning(true);
  const handleRunDone = async () => {
    setIsRunning(false);
    await load(); // single fetch after everything is done
  };

  return (
    <div className="space-y-4">
      <ScrapersBar onRunStart={handleRunStart} onRunDone={handleRunDone} />

      <ScrapedToolbar
        q={q} onQ={setQ}
        source={source} onSource={setSource}
        status={status} onStatus={setStatus}
        sort={sort as any} onSort={setSort as any}
        loading={loading}
      />

      {!data?.length && !loading && (
        <div className="card p-8 text-center text-gray-400">No scraped packages.</div>
      )}

      <div className="cards-grid">
        {data?.map(pkg => (
          <ScrapedPackageCard key={pkg.id} pkg={pkg} />
        ))}
      </div>
    </div>
  );
}

```

---

## src/app/scraped-packages/ui/ScrapedPackageCard.tsx

```tsx
'use client';
import Link from 'next/link';
import { useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import type { ScrapedPackageRow } from '../scraped-packages.client';

function ItemsHover({ names }: { names: string[] }) {
  const [open, setOpen] = useState(false);
  return (
    <div
      className="relative inline-flex"
      onMouseEnter={() => setOpen(true)}
      onMouseLeave={() => setOpen(false)}
    >
      <span className="cursor-default underline decoration-dotted underline-offset-4">
        Items: {names.length}
      </span>
      {open && (
        <div
          className="absolute right-0 top-full z-20 mt-2 w-72 max-w-[80vw] rounded-lg border p-2 text-xs shadow-xl"
          style={{ background: 'var(--color-surface)', borderColor: 'var(--color-border)' }}
        >
          <ul className="space-y-1">
            {names.map((n, i) => (
              <li key={i} className="text-gray-300 leading-snug">• {n}</li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

export default function ScrapedPackageCard({ pkg }: { pkg: ScrapedPackageRow }) {
  const router = useRouter();
  const itemNames = useMemo(() => pkg.items.map(i => i.title || '').filter(Boolean), [pkg.items]);

  const [status, setStatus] = useState(pkg.status);
  const [saving, setSaving] = useState(false);
  const [opening, setOpening] = useState(false);

  const isBlacklisted = status === 'Blacklist';
  const isProcessed = status === 'Processed';

  async function toggleBlacklist() {
    if (saving) return;
    setSaving(true);
    const prev = status;
    const next = isBlacklisted ? 'Todo' : 'Blacklist';
    setStatus(next); // optimistic UI

    try {
      const res = await fetch(`/api/scraped-packages/${pkg.id}/status`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status: next }),
      });
      if (!res.ok) throw new Error('save_failed');
    } catch {
      setStatus(prev); // rollback on error
    } finally {
      setSaving(false);
    }
  }

  async function openSessionForPackage() {
    if (opening) return;
    setOpening(true);
    try {
      // 1) Try to find an existing session for this package
      const findRes = await fetch(`/api/fill-sessions/by-package?packageId=${encodeURIComponent(pkg.id)}`, { cache: 'no-store' });
      if (findRes.ok) {
        const j = await findRes.json();
        router.push(`/inventory-filler?sessionId=${j.sessionId}`);
        return;
      }

      // 2) If none found and package is not Processed, create one
      if (!isProcessed) {
        const createRes = await fetch('/api/fill-sessions', {
          method: 'POST',
          body: JSON.stringify({ sourceType: 'ScrapedPackage', scrapedPackageId: pkg.id }),
        });
        const cj = await createRes.json();
        if (!createRes.ok) throw new Error(cj.error || 'Failed to create session');
        router.push(`/inventory-filler?sessionId=${cj.sessionId}`);
        return;
      }

      // 3) If Processed and still no session, inform
      alert('No existing session found for this processed package.');
    } catch (e: any) {
      alert(e?.message || 'Failed to open session');
    } finally {
      setOpening(false);
    }
  }

  return (
    <div className="card flex h-full flex-col overflow-hidden">
      {/* header */}
      <div className="flex items-center justify-between border-b px-3 py-2" style={{ borderColor: 'var(--color-border)' }}>
        <div className="text-xs uppercase tracking-wide text-gray-400">{pkg.source}</div>
        <div className="text-xs text-gray-400">{pkg.dateShipped ?? '—'}</div>
      </div>

      {/* body now fills remaining height */}
      <div className="flex flex-1 flex-col space-y-3 p-3">
        <div className="flex items-center justify-between">
          <div className="font-mono text-sm tracking-tight">{pkg.packageNumber}</div>
          <div className="text-xs text-gray-400">
            <ItemsHover names={itemNames} />
          </div>
        </div>

        {pkg.intlTrackingNumber && (
          <div className="truncate text-xs">
            <span className="text-gray-400">Tracking:</span>{' '}
            {pkg.intlTrackingUrl ? (
              <a className="text-blue-400 hover:underline" href={pkg.intlTrackingUrl} target="_blank" rel="noreferrer">
                {pkg.intlTrackingNumber}
              </a>
            ) : (
              <span className="font-mono">{pkg.intlTrackingNumber}</span>
            )}
          </div>
        )}

        {/* thumbnails */}
        <div className="grid grid-cols-3 md:grid-cols-4 gap-2">
          {pkg.items.slice(0, 8).map((it, i) => {
            const href = it.listingId
              ? `https://buyee.jp/item/jdirectitems/auction/${it.listingId}`
              : undefined;
            const img = it.listingId ? `/api/thumb/${it.listingId}` : '/placeholder-item.png';
            const el = (
              // eslint-disable-next-line @next/next/no-img-element
              <img
                src={img}
                alt={it.title || ''}
                className="h-full w-full object-cover"
                loading={i > 1 ? 'lazy' : undefined}
              />
            );
            return (
              <div
                key={it.id}
                className="relative aspect-square overflow-hidden rounded-md ring-1"
                style={{ background: '#0f1522', borderColor: 'transparent', boxShadow: 'inset 0 0 0 1px rgba(255,255,255,.04)' }}
              >
                {href ? (
                  <a href={href} target="_blank" rel="noreferrer" title={it.title || ''}>
                    {el}
                  </a>
                ) : el}
              </div>
            );
          })}
        </div>

        {/* footer pinned to bottom */}
        <div className="mt-auto flex items-center justify-end gap-2 pt-1">
          <button
            onClick={toggleBlacklist}
            disabled={saving}
            className={
              isBlacklisted
                ? 'btn bg-red-600 hover:bg-red-500 disabled:opacity-50'
                : 'btn disabled:opacity-50'
            }
            title={isBlacklisted ? 'Click to unblacklist (back to To-do)' : 'Blacklist this package'}
          >
            {isBlacklisted ? 'Blacklisted' : 'Blacklist'}
          </button>

          <button
            onClick={openSessionForPackage}
            disabled={opening}
            className="btn btn-success cursor-pointer disabled:opacity-50"
            title={isProcessed ? 'View existing fill session' : 'Start or resume fill session'}
          >
            {isProcessed ? 'View session' : 'Proceed'}
          </button>
        </div>
      </div>
    </div>
  );
}

```

---

## src/app/scraped-packages/ui/ScrapedToolbar.tsx

```tsx
'use client';

export default function ScrapedToolbar({
  q, onQ, source, onSource, status, onStatus, sort, onSort, loading,
}: {
  q: string; onQ: (v: string) => void;
  source: string; onSource: (v: string) => void;
  status: string; onStatus: (v: string) => void;
  sort: 'date_desc'|'date_asc'|'intl_desc'|'intl_asc'|'dom_desc'|'dom_asc'|'items_desc'|'items_asc';
  onSort: (v: any) => void;
  loading: boolean;
}) {
  return (
    <div className="card p-3">
      <div className="flex flex-col gap-3 sm:flex-row sm:items-center">
        <input
          value={q}
          onChange={e => onQ(e.target.value)}
          placeholder="Search package #, tracking, title, listing id…"
          className="field flex-1"
        />
        <select value={source} onChange={e=>onSource(e.target.value)} className="field">
          <option value="">All proxies</option>
          <option value="zenmarket">zenmarket</option>
          <option value="buyee">buyee</option>
          <option value="fromjapan">fromjapan</option>
        </select>
        <select value={status} onChange={e=>onStatus(e.target.value)} className="field">
          <option value="">All</option>
          <option value="todo">To process</option>
          <option value="processed">Processed</option>
          <option value="blacklisted">Blacklisted</option>
        </select>
        <select value={sort} onChange={e=>onSort(e.target.value as any)} className="field">
          <option value="date_desc">Date ↓</option>
          <option value="date_asc">Date ↑</option>
          <option value="items_desc">Items ↓</option>
          <option value="items_asc">Items ↑</option>
        </select>
        <button disabled={loading} className="btn btn-outline disabled:opacity-50">
          {loading ? 'Loading…' : 'Refresh'}
        </button>
      </div>
    </div>
  );
}

```

---

## src/app/scraped-packages/ui/ScrapersBar.tsx

```tsx
'use client';

import { useState } from 'react';

type Props = {
  onRunStart?: () => void;
  onRunDone?: () => void; // called exactly once after confirm+scrape finishes
};

async function post(url: string, body: any) {
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body ?? {}),
  });
  const json = await res.json().catch(() => ({}));
  return { ok: res.ok, json };
}

export default function ScrapersBar({ onRunStart, onRunDone }: Props) {
  const [maxPages, setMaxPages] = useState<number>(9999);
  const [zmUrl, setZmUrl] = useState<string>('https://zenmarket.jp/fr/profile/parcel.aspx?state=5');
  const [busy, setBusy] = useState<null | 'buyee' | 'fromjapan' | 'zenmarket'>(null);
  const [phase, setPhase] = useState<'idle'|'waiting'|'running'|'done'>('idle');
  const [current, setCurrent] = useState<null | 'buyee' | 'fromjapan' | 'zenmarket'>(null);
  const [msg, setMsg] = useState('');

  const endpoints = {
    buyee:     '/api/scrape/buyee-crawl',
    fromjapan: '/api/scrape/fromjapan-crawl',
    zenmarket: '/api/scrape/zenmarket-crawl',
  } as const;

  const payloadFor = (src: 'buyee'|'fromjapan'|'zenmarket') =>
    src === 'zenmarket' ? { pageUrl: zmUrl } : { startPage: 1, maxPages: Math.max(1, Number(maxPages) || 1) };

  const start = async (src: 'buyee'|'fromjapan'|'zenmarket') => {
    if (busy) return;
    onRunStart?.();                 // 🔹 mark running (prevents page refetch)
    setBusy(src); setCurrent(src); setMsg('Starting profile refresh…'); setPhase('waiting');

    const s = await post('/api/profile/refresh/start', { source: src });
    if (!s.ok) {
      setMsg(`Failed to start refresh: ${s.json?.error || 'error'}`);
      setBusy(null); setPhase('idle');
      onRunDone?.();                // unblock UI despite failure
      return;
    }
    setMsg('Profile refresh running. Complete login in the opened window, then click Confirm.');
  };

  const confirm = async () => {
    const src = current!;
    setMsg('Confirming refresh…');
    const c = await post('/api/profile/refresh/confirm', { source: src });
    if (!c.ok || !c.json?.ok) {
      setMsg(`Refresh confirm failed${c.json?.code !== undefined ? ` (code ${c.json.code})` : ''}.`);
      setBusy(null); setPhase('idle');
      onRunDone?.();
      return;
    }
    // 2) run scraper
    setPhase('running'); setMsg('Running scraper…');
    const run = await post(endpoints[src], payloadFor(src));

    if (run.ok && (run.json?.ok ?? true)) {
      setMsg('Done.'); setPhase('done');
    } else {
      setMsg(`Scraper failed${run.json?.error ? ` — ${run.json.error}` : ''}.`);
      setPhase('idle');
    }

    setBusy(null);
    onRunDone?.();                  // 🔹 fetch once now that we’re done
  };

  return (
    <div className="card p-3">
      <div className="flex flex-col gap-3 xl:flex-row xl:items-center">
        <div className="flex flex-1 items-center gap-2">
          <label className="text-xs text-gray-400 min-w-[6rem]">ZenMarket URL</label>
          <input className="field w-full" value={zmUrl} onChange={e => setZmUrl(e.target.value)} spellCheck={false}/>
        </div>
        <div className="flex items-center gap-2">
          <label className="text-xs text-gray-400">Max pages</label>
          <input type="number" min={1} className="field w-24"
                 value={maxPages} onChange={e => setMaxPages(Number(e.target.value || 1))}/>
        </div>
        <div className="flex flex-wrap items-center gap-2">
          <button className="btn btn-outline disabled:opacity-50" disabled={!!busy} onClick={() => start('buyee')}>
            {busy === 'buyee' && phase !== 'idle' ? 'Buyee…' : 'Refresh+Run Buyee'}
          </button>
          <button className="btn btn-outline disabled:opacity-50" disabled={!!busy} onClick={() => start('fromjapan')}>
            {busy === 'fromjapan' && phase !== 'idle' ? 'FromJapan…' : 'Refresh+Run FromJapan'}
          </button>
          <button className="btn btn-outline disabled:opacity-50" disabled={!!busy} onClick={() => start('zenmarket')}>
            {busy === 'zenmarket' && phase !== 'idle' ? 'ZenMarket…' : 'Refresh+Run ZenMarket'}
          </button>
          {phase === 'waiting' && (
            <button className="btn btn-primary" onClick={confirm}>I’ve logged in — Confirm</button>
          )}
        </div>
      </div>
      {msg && <div className="hr mt-3 pt-3 text-xs text-gray-400">{msg}</div>}
    </div>
  );
}

```

---

## src/app/tags/page.tsx

```tsx
// src/app/tags/page.tsx
export const dynamic = 'force-dynamic';

import TagsClient from './tags.client';

export default function TagsPage() {
  return <TagsClient />;
}

```

---

## src/app/tags/tags.client.tsx

```tsx
'use client';

import { useEffect, useMemo, useState } from 'react';

type TagNode = {
  placementId: string;
  tagId: string;
  name: string;
  description: string | null;
  parentPlacementId: string | null;
  children: TagNode[];
};

type TreePayload = {
  tree: TagNode[];
  parentCounts: Record<string, number>; // number of placements per tagId
  tags: Array<{ id: string; name: string; description: string | null }>;
};

async function fetchTreePayload(): Promise<TreePayload> {
  const res = await fetch('/api/tags?format=tree', { cache: 'no-store' });
  if (!res.ok) throw new Error('Failed to load tags');
  return res.json();
}

async function apiCreate(payload: { name: string; description?: string; parentPlacementId?: string | null }) {
  const res = await fetch('/api/tags', { method: 'POST', body: JSON.stringify(payload) });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error || 'Create failed');
  return data.placement as { id: string; tagId: string; parentPlacementId: string | null };
}
async function apiDeletePlacement(placementId: string) {
  const res = await fetch('/api/tags', { method: 'DELETE', body: JSON.stringify({ placementId }) });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error || 'Delete failed');
  return data as { ok: true; deletedPlacement: boolean; deletedTag: boolean };
}
async function apiPatchTag(payload: { tagId: string; name?: string; description?: string }) {
  const res = await fetch('/api/tags', { method: 'PATCH', body: JSON.stringify(payload) });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error || 'Update failed');
  return data.tag as { id: string; name: string; description: string | null };
}

export default function TagsClient() {
  const [tree, setTree] = useState<TagNode[] | null>(null);
  const [parentCounts, setParentCounts] = useState<Record<string, number>>({});
  const [nameIndex, setNameIndex] = useState<Map<string, string>>(new Map()); // lower(name) -> tagId
  const [expanded, setExpanded] = useState<Record<string, boolean>>({});
  const [selectedPlacementId, setSelectedPlacementId] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  const selected = useMemo(() => {
    if (!tree || !selectedPlacementId) return null;
    const stack = [...tree];
    while (stack.length) {
      const n = stack.pop()!;
      if (n.placementId === selectedPlacementId) return n;
      stack.push(...n.children);
    }
    return null;
  }, [tree, selectedPlacementId]);

  // helpers
  function idsInTree(nodes: TagNode[]): Set<string> {
    const s = new Set<string>();
    const st = [...nodes];
    while (st.length) {
      const n = st.pop()!;
      s.add(n.placementId);
      for (const c of n.children) st.push(c);
    }
    return s;
  }
  function findPath(nodes: TagNode[], targetPid: string): string[] | null {
    const stack: Array<{ node: TagNode; path: string[] }> = nodes.map(n => ({ node: n, path: [n.placementId] }));
    while (stack.length) {
      const { node, path } = stack.pop()!;
      if (node.placementId === targetPid) return path;
      for (const c of node.children) stack.push({ node: c, path: [...path, c.placementId] });
    }
    return null;
  }

  async function load(opts?: { preserveExpanded?: boolean; ensureExpandedPids?: string[]; selectPid?: string | null }) {
    setLoading(true);
    setErr(null);
    try {
      const payload = await fetchTreePayload();
      setTree(payload.tree);
      setParentCounts(payload.parentCounts || {});

      const idx = new Map<string, string>();
      for (const t of payload.tags || []) idx.set(t.name.toLowerCase(), t.id);
      setNameIndex(idx);

      const next: Record<string, boolean> = {};
      const existing = idsInTree(payload.tree);

      if (opts?.preserveExpanded) {
        for (const pid of Object.keys(expanded)) if (expanded[pid] && existing.has(pid)) next[pid] = true;
      } else {
        for (const r of payload.tree) next[r.placementId] = true; // expand roots initially
      }

      if (opts?.ensureExpandedPids) {
        for (const pid of opts.ensureExpandedPids) {
          const path = pid ? findPath(payload.tree, pid) : null;
          if (path) for (const anc of path.slice(0, -1)) next[anc] = true;
        }
      }

      setExpanded(next);

      if (opts?.selectPid !== undefined) {
        setSelectedPlacementId(opts.selectPid);
      } else if (selectedPlacementId && existing.has(selectedPlacementId)) {
        setSelectedPlacementId(selectedPlacementId);
      } else {
        setSelectedPlacementId(null);
      }
    } catch (e: any) {
      setErr(e.message || 'Load failed');
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    load({ preserveExpanded: false });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Top + : create root placement (new tag or existing by name warning)
  const addRoot = async () => {
    const raw = prompt('New root tag name:');
    const name = (raw || '').trim();
    if (!name) return;

    // If a tag already exists with this name, we still create a placement at root (link).
    try {
      const placement = await apiCreate({ name, parentPlacementId: null });
      await load({ preserveExpanded: true, ensureExpandedPids: [placement.id], selectPid: placement.id });
    } catch (e: any) {
      alert(e.message || 'Create failed');
    }
  };

  // + on a node: link existing by name or create new tag + placement — scoped to this branch
  const addChild = async (parent: TagNode) => {
    const raw = prompt(`Add under “${parent.name}”:\nEnter tag name (links if it already exists):`);
    const name = (raw || '').trim();
    if (!name) return;

    try {
      const placement = await apiCreate({ name, parentPlacementId: parent.placementId });
      await load({ preserveExpanded: true, ensureExpandedPids: [parent.placementId, placement.id], selectPid: placement.id });
    } catch (e: any) {
      alert(e.message || 'Add failed');
    }
  };

  // Delete placement. If it was the last placement of that tag and it's unused, server deletes the tag as well.
  const deleteNode = async (node: TagNode) => {
    const placementsForTag = parentCounts[node.tagId] ?? 0;
    const msg = placementsForTag > 1
      ? `Unlink “${node.name}” from this branch?`
      : `Delete “${node.name}” entirely? (It is not used elsewhere)`;
    if (!confirm(msg)) return;

    try {
      await apiDeletePlacement(node.placementId);
      const anchor = node.parentPlacementId ?? null;
      await load({ preserveExpanded: true, ensureExpandedPids: anchor ? [anchor] : [], selectPid: anchor });
    } catch (e: any) {
      alert(e.message || 'Delete failed');
    }
  };

  const saveDetails = async (payload: { name?: string; description?: string | null }) => {
    if (!selected) return;
    try {
      await apiPatchTag({ tagId: selected.tagId, ...payload });
      await load({ preserveExpanded: true, ensureExpandedPids: [selected.placementId], selectPid: selected.placementId });
    } catch (e: any) {
      alert(e.message || 'Save failed');
    }
  };

  return (
    <div>
      {/* Toolbar */}
      <div className="card p-3 mb-5">
        <div className="flex items-center gap-3">
          <div className="text-sm text-gray-400 flex-1">
            Add with <span className="font-medium">+</span> (links by name or creates new), delete removes this placement. Actions appear on row hover.
          </div>
          <button onClick={addRoot} className="btn btn-outline" title="Create root tag">+</button>
        </div>
      </div>

      {err && <div className="card p-3 mb-5 text-red-300">{err}</div>}
      {loading && <div className="card p-6 mb-5 text-gray-300">Loading…</div>}

      {!loading && tree && (
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-5">
          {/* Tree */}
          <div className="lg:col-span-2 card p-3">
            {tree.length === 0 ? (
              <div className="p-6 text-center text-gray-400">No tags yet. Use the + button to create your first root tag.</div>
            ) : (
              <ul className="space-y-1">
                {tree.map(n => (
                  <TreeNode
                    key={n.placementId}
                    node={n}
                    parentCounts={parentCounts}
                    expanded={expanded}
                    setExpanded={setExpanded}
                    selectedPlacementId={selectedPlacementId}
                    setSelectedPlacementId={setSelectedPlacementId}
                    onAddChild={addChild}
                    onDelete={deleteNode}
                  />
                ))}
              </ul>
            )}
          </div>

          {/* Details */}
          <div className="card p-3">
            <h2 className="text-sm font-semibold mb-3">Details</h2>
            {!selected ? (
              <div className="text-gray-400">Select a tag to view/edit.</div>
            ) : (
              <DetailsForm
                key={selected.placementId}
                node={selected}
                onSave={saveDetails}
              />
            )}
          </div>
        </div>
      )}
    </div>
  );
}

function TreeNode(props: {
  node: TagNode;
  parentCounts: Record<string, number>;
  expanded: Record<string, boolean>;
  setExpanded: React.Dispatch<React.SetStateAction<Record<string, boolean>>>;
  selectedPlacementId: string | null;
  setSelectedPlacementId: (pid: string) => void;
  onAddChild: (node: TagNode) => void;
  onDelete: (node: TagNode) => void;
}) {
  const { node, parentCounts, expanded, setExpanded, selectedPlacementId } = props;
  const isOpen = !!expanded[node.placementId];
  const hasChildren = node.children.length > 0;
  const isLinked = (parentCounts[node.tagId] ?? 0) > 1;

  return (
    <li>
      <div
        className={[
          'relative flex items-center gap-2 px-2 py-1 rounded-lg group/row',
          selectedPlacementId === node.placementId ? 'bg-white/10 border border-white/10' : 'hover:bg-white/5',
        ].join(' ')}
      >
        <button
          onClick={() => hasChildren && setExpanded(e => ({ ...e, [node.placementId]: !isOpen }))}
          className={[
            'h-6 w-6 grid place-items-center rounded-md border',
            hasChildren ? 'opacity-100' : 'opacity-40',
          ].join(' ')}
          style={{ borderColor: 'var(--color-border)' }}
          title={hasChildren ? (isOpen ? 'Collapse' : 'Expand') : 'No children'}
        >
          {hasChildren ? (isOpen ? '–' : '+') : '•'}
        </button>

        <button onClick={() => props.setSelectedPlacementId(node.placementId)} className="flex-1 text-left">
          <div className="font-medium flex items-center gap-1">
            <span>{node.name}</span>
            {isLinked && <span title="Tag appears in multiple branches">🔗</span>}
          </div>
          {node.description && <div className="text-xs text-gray-400">{node.description}</div>}
        </button>

        {/* Row-only hover actions */}
        <div className="absolute right-2 top-1/2 -translate-y-1/2 hidden gap-1 group-hover/row:flex">
          <button onClick={() => props.onAddChild(node)} className="btn btn-outline text-xs" title="Add child">+</button>
          <button onClick={() => props.onDelete(node)} className="btn btn-outline text-xs" title="Delete placement">🗑️</button>
        </div>
      </div>

      {hasChildren && isOpen && (
        <ul className="pl-6 mt-1 space-y-1">
          {node.children.map(c => (
            <TreeNode
              key={c.placementId}
              node={c}
              parentCounts={parentCounts}
              expanded={expanded}
              setExpanded={setExpanded}
              selectedPlacementId={selectedPlacementId}
              setSelectedPlacementId={props.setSelectedPlacementId}
              onAddChild={props.onAddChild}
              onDelete={props.onDelete}
            />
          ))}
        </ul>
      )}
    </li>
  );
}

function DetailsForm(props: {
  node: TagNode;
  onSave: (payload: { name?: string; description?: string | null }) => Promise<void>;
}) {
  const [name, setName] = useState(props.node.name);
  const [description, setDescription] = useState(props.node.description ?? '');
  const [saving, setSaving] = useState(false);
  const [msg, setMsg] = useState<string | null>(null);

  useEffect(() => {
    setName(props.node.name);
    setDescription(props.node.description ?? '');
  }, [props.node.tagId, props.node.name, props.node.description]);

  const save = async () => {
    setSaving(true);
    setMsg(null);
    try {
      await props.onSave({ name, description: description || null });
      setMsg('Saved.');
    } catch (e: any) {
      setMsg(e.message || 'Save failed');
    } finally {
      setSaving(false);
      setTimeout(() => setMsg(null), 1500);
    }
  };

  return (
    <div className="space-y-3">
      <div>
        <label className="block text-xs text-gray-400">Name</label>
        <input className="field mt-1 w-full" value={name} onChange={e => setName(e.target.value)} />
      </div>
      <div>
        <label className="block text-xs text-gray-400">Description</label>
        <textarea className="field mt-1 w-full min-h-[96px]" value={description} onChange={e => setDescription(e.target.value)} />
      </div>
      <div className="flex items-center gap-2">
        <button onClick={save} disabled={saving} className="btn btn-outline disabled:opacity-50">
          {saving ? 'Saving…' : 'Save changes'}
        </button>
        {msg && <span className="text-sm text-gray-400">{msg}</span>}
      </div>
      <div className="text-xs text-gray-500">
        Tag ID: <span className="font-mono">{props.node.tagId}</span> · Placement ID: <span className="font-mono">{props.node.placementId}</span>
      </div>
    </div>
  );
}

```

---

## src/components/AppShell.tsx

```tsx
// src/components/AppShell.tsx
'use client';

import { useState } from 'react';
import Sidebar from './Sidebar';

export default function AppShell({ children }: { children: React.ReactNode }) {
  const [open, setOpen] = useState(false);

  return (
    <div className="min-h-screen lg:grid lg:grid-cols-[16rem_1fr]">
      <Sidebar open={open} onClose={() => setOpen(false)} />

      <div className="flex min-h-screen flex-col">
        <header className="sticky top-0 z-20 border-b border-white/10 bg-[#0b0f16]/80 backdrop-blur">
          <div className="mx-auto max-w-7xl px-4 py-4 flex items-center gap-3">
            {/* mobile toggle only */}
            <button
              className="inline-flex h-9 w-9 items-center justify-center rounded-md border border-gray-800 bg-gray-900 text-gray-200 hover:bg-gray-800 lg:hidden"
              onClick={() => setOpen(v => !v)}
              aria-label="Toggle navigation"
            >
              ☰
            </button>
            <h1 className="text-lg font-semibold">
              {process.env.NEXT_PUBLIC_APP_NAME || 'Proxy Dashboard'}
            </h1>
          </div>
        </header>

        <main className="mx-auto max-w-7xl flex-1 px-4 py-6 min-w-0">
          {children}
        </main>
      </div>
    </div>
  );
}

```

---

## src/components/Sidebar.tsx

```tsx
// src/components/Sidebar.tsx
'use client';

import Link from 'next/link';
import { useCallback } from 'react';

type Props = {
  open?: boolean;
  onClose?: () => void;
};

export default function Sidebar({ open = false, onClose }: Props) {
  const close = useCallback(() => onClose?.(), [onClose]);

  const Nav = (
    <nav className="space-y-1">
      <Link href="/dashboard" className="block px-2" onClick={close}>
        <div className="group flex items-center gap-3 rounded-lg px-3 py-2 text-sm text-gray-300 hover:bg-white/5">
          <span>🏠</span><span>Dashboard</span>
        </div>
      </Link>
      <Link href="/scraped-packages" className="block px-2" onClick={close}>
        <div className="group flex items-center gap-3 rounded-lg px-3 py-2 text-sm text-gray-300 hover:bg-white/5">
          <span>📦</span><span>Scraped Packages</span>
        </div>
      </Link>
      <Link href="/tags" className="block px-2" onClick={close}>
        <div className="group flex items-center gap-3 rounded-lg px-3 py-2 text-sm text-gray-300 hover:bg-white/5">
          <span>🏷️</span><span>Tags</span>
        </div>
      </Link>
      <Link href="/inventory-filler" className="block px-2" onClick={close}>
        <div className="group flex items-center gap-3 rounded-lg px-3 py-2 text-sm text-gray-300 hover:bg-white/5">
          <span>🧮</span><span>Inventory filler</span>
        </div>
      </Link>
      <Link href="/inventory" className="block px-2" onClick={close}>
        <div className="group flex items-center gap-3 rounded-lg px-3 py-2 text-sm text-gray-300 hover:bg-white/5">
          <span>📋</span><span>Inventory</span>
        </div>
      </Link>
    </nav>
  );

  return (
    <>
      {/* Desktop sidebar */}
      <aside className="hidden lg:block w-64 border-r border-white/5 bg-[#0b0f16] p-3">
        <div className="mb-3 px-2">
          <div className="text-xs uppercase tracking-wide text-gray-500">Navigation</div>
        </div>
        {Nav}
      </aside>

      {/* Mobile drawer + backdrop */}
      {open && (
        <div className="fixed inset-0 z-40 lg:hidden" role="dialog" aria-modal="true">
          <div className="absolute inset-0 bg-black/50" onClick={close} />
          <aside
            className="absolute inset-y-0 left-0 w-72 max-w-[85vw] border-r border-white/5 bg-[#0b0f16] p-3 shadow-xl"
            onClick={e => e.stopPropagation()}
          >
            <div className="mb-3 px-2 flex items-center justify-between">
              <div className="text-xs uppercase tracking-wide text-gray-500">Navigation</div>
              <button
                className="btn btn-outline text-xs"
                onClick={close}
                aria-label="Close navigation"
              >
                ✕
              </button>
            </div>
            {Nav}
          </aside>
        </div>
      )}
    </>
  );
}

```

---

## src/components/SingleTagPicker.tsx

```tsx
// src/components/SingleTagPicker.tsx
'use client';

import { useEffect, useMemo, useRef, useState } from 'react';

type TagFlat = { id: string; name: string; description?: string | null };

// Normalized node shape for the tree
type TagNode = {
  tagId: string;               // ALWAYS the tag id
  name: string;
  description?: string | null;
  placementKey: string;        // unique per placement/path (for React keys)
  placementId?: string;        // TagPlacement.id if available
  children?: TagNode[];
};

export default function SingleTagPicker({
  value,
  onChange,
  allTags,
  disabled,
}: {
  value: string | null | undefined;
  onChange: (sel: { tagId: string | null; placementId: string | null }) => void;
  allTags?: TagFlat[]; // optional; will self-fetch if absent
  disabled?: boolean;
}) {
  const [q, setQ] = useState('');
  const [tree, setTree] = useState<TagNode[] | null>(null);
  const [loadingTree, setLoadingTree] = useState(false);
  const [showTree, setShowTree] = useState(false);                   // 👈 restored modal state
  const [expanded, setExpanded] = useState<Record<string, boolean>>({}); // tree expand state

  // Local flat tags if parent didn't provide any
  const [localTags, setLocalTags] = useState<TagFlat[] | null>(null);
  const [loadingTags, setLoadingTags] = useState(false);

  // Remember exact branch chosen
  const [selectedPath, setSelectedPath] = useState<{ tagId: string; labels: string[] } | null>(null);

  // Suggestions dropdown
  const inputWrapRef = useRef<HTMLDivElement>(null);
  const [showSuggestions, setShowSuggestions] = useState(false);

  // Branch chooser for ambiguous picks (multiple placements)
  const [branchChoices, setBranchChoices] = useState<{
    tagId: string;
    options: { placementId: string | null; labels: string[] }[];
  } | null>(null);

  // Effective flat tags
  const effectiveTags: TagFlat[] = useMemo(() => {
    if (Array.isArray(allTags) && allTags.length) return allTags;
    return Array.isArray(localTags) ? localTags : [];
  }, [allTags, localTags]);

  // Fetch flat tags if not provided
  useEffect(() => {
    if (Array.isArray(allTags) && allTags.length) return;
    if (localTags !== null) return;
    (async () => {
      try {
        setLoadingTags(true);
        const r = await fetch('/api/tags?format=flat', { cache: 'no-store' });
        const j = await r.json();
        setLocalTags(Array.isArray(j.tags) ? j.tags : []);
      } catch {
        setLocalTags([]);
      } finally {
        setLoadingTags(false);
      }
    })();
  }, [allTags, localTags]);

  // Close suggestions on outside click
  useEffect(() => {
    const onDoc = (e: MouseEvent) => {
      if (!inputWrapRef.current) return;
      if (!inputWrapRef.current.contains(e.target as Node)) setShowSuggestions(false);
    };
    document.addEventListener('mousedown', onDoc);
    return () => document.removeEventListener('mousedown', onDoc);
  }, []);

  // If parent clears value, clear path memory
  useEffect(() => {
    if (!value) setSelectedPath(null);
  }, [value]);

  // Ensure we have the tree (optionally open modal immediately)
  async function ensureTree(openModal = false): Promise<TagNode[] | null> {
    if (tree) {
      if (openModal) setShowTree(true);
      return tree;
    }
    try {
      setLoadingTree(true);
      const res = await fetch('/api/tags?format=tree', { cache: 'no-store' });
      const j = await res.json();
      const raw = (j.tree || j.tags || []) as any[];
      const norm = normalizeTree(raw, 'root');
      setTree(norm);
      if (openModal) setShowTree(true);          // 👈 open modal after load
      return norm;
    } catch {
      return null;
    } finally {
      setLoadingTree(false);
    }
  }

  // Load tree silently when we already have a selected value (for path fallback)
  useEffect(() => {
    if (!value || tree || loadingTree) return;
    void ensureTree(false);
  }, [value, tree, loadingTree]);

  // Fallback path if selection came from outside OR no stored path for this tag
  const fallbackPath = useMemo(() => {
    if (!value || !tree) return null;
    if (selectedPath && selectedPath.tagId === value) return null;
    return findPathLabelsByTagId(tree, value);
  }, [value, tree, selectedPath]);

  const selectedObj = value ? effectiveTags.find(t => t.id === value) : undefined;
  const selectedName = useMemo(() => {
    if (selectedPath && selectedPath.tagId === value) {
      const labels = selectedPath.labels;
      return labels[labels.length - 1];
    }
    if (selectedObj) return selectedObj.name;
    if (fallbackPath?.length) return fallbackPath[fallbackPath.length - 1];
    return value ?? undefined;
  }, [selectedPath, value, selectedObj, fallbackPath]);

  // Suggestions list
  const suggestions = useMemo(() => {
    const s = q.trim().toLowerCase();
    if (!s) return [] as TagFlat[];
    return effectiveTags.filter(t => t.name.toLowerCase().includes(s)).slice(0, 20);
  }, [q, effectiveTags]);

  // Pick from suggestions
  async function pickFromSuggestions(tagId: string) {
    const t = await ensureTree(false);
    if (!t) {
      onChange({ tagId, placementId: null });
      setSelectedPath(null);
      setShowSuggestions(false);
      return;
    }
    const placements = collectPlacementsByTagId(t, tagId);
    if (placements.length <= 1) {
      const only = placements[0] ?? { placementId: null, labels: [selectedObj?.name ?? tagId] };
      onChange({ tagId, placementId: only.placementId });
      setSelectedPath({ tagId, labels: only.labels });
      setShowSuggestions(false);
    } else {
      setBranchChoices({ tagId, options: placements });
      setShowSuggestions(false);
    }
  }

  return (
    <div className="w-full">
      {/* Selected pill */}
      <div className="mb-2">
        {value ? (
          <span className="px-2 py-1 rounded bg-white/10 text-xs">
            {selectedName ?? value}
            {!disabled && (
              <button
                className="ml-2 opacity-70 hover:opacity-100"
                onClick={() => { onChange({ tagId: null, placementId: null }); setSelectedPath(null); }}
              >
                ×
              </button>
            )}
          </span>
        ) : (
          <span className="text-xs text-gray-400">No tag selected</span>
        )}
      </div>

      {/* Input + suggestions + browse */}
      <div className="flex gap-2">
        <div className="relative flex-1" ref={inputWrapRef}>
          <input
            className="field w-full"
            placeholder={loadingTags ? 'Loading tags…' : 'Type to search tags…'}
            value={q}
            onChange={e => { setQ(e.target.value); setShowSuggestions(true); }}
            onFocus={() => suggestions.length && setShowSuggestions(true)}
            disabled={disabled || loadingTags}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && suggestions.length > 0) {
                e.preventDefault();
                void pickFromSuggestions(suggestions[0].id);
              }
              if (e.key === 'Escape') setShowSuggestions(false);
            }}
          />
          {showSuggestions && suggestions.length > 0 && (
            <div className="absolute left-0 right-0 top-full z-50 mt-1 rounded-lg border border-white/10 bg-[#0b0f16] shadow-xl overflow-hidden">
              {suggestions.map((t) => (
                <button
                  key={t.id}
                  className="w-full text-left px-3 py-2 hover:bg-white/5 flex items-center justify-between"
                  onClick={() => void pickFromSuggestions(t.id)}
                  disabled={disabled}
                  title={t.description || ''}
                >
                  <span className="text-sm">{t.name}</span>
                  <span className="text-xs text-gray-400">select</span>
                </button>
              ))}
            </div>
          )}
        </div>

        <button
          className="btn btn-outline"
          onClick={() => void ensureTree(true)}         // 👈 open modal
          disabled={disabled || loadingTree}
          title="Browse full hierarchy"
        >
          {loadingTree ? 'Loading…' : 'Browse tree…'}
        </button>
      </div>

      {/* Selected tag full path */}
      <div className="mt-2 text-xs text-gray-300 min-h-[1.5rem]">
        {value ? (
          selectedPath && selectedPath.tagId === value ? (
            <span>Path: {selectedPath.labels.join(' › ')}</span>
          ) : tree ? (
            fallbackPath?.length ? (
              <span>Path: {fallbackPath.join(' › ')}</span>
            ) : (
              <span className="text-gray-500">This tag may exist in multiple branches. Use the tree to pick an exact branch.</span>
            )
          ) : (
            <span className="text-gray-500">Path will appear once the tree is loaded.</span>
          )
        ) : (
          <span className="text-gray-500">Pick a tag to see its full path.</span>
        )}
      </div>

      {/* Tree modal (restored) */}
      {showTree && (
        <div className="fixed inset-0 z-50 grid place-items-center bg-black/60 p-4" onClick={() => setShowTree(false)}>
          <div className="card w-full max-w-3xl p-4" onClick={e => e.stopPropagation()}>
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold">Pick a tag</div>
              <button className="btn btn-outline text-xs" onClick={() => setShowTree(false)}>Close</button>
            </div>
            <div className="max-h-[65vh] overflow-auto">
              {tree ? (
                <Tree
                  nodes={tree}
                  expanded={expanded}
                  onToggle={(k) => setExpanded(e => ({ ...e, [k]: !e[k] }))}
                  onPick={(tagId, pathLabels, placementId) => {
                    setSelectedPath({ tagId, labels: pathLabels });
                    onChange({ tagId, placementId: placementId ?? null });
                    setShowTree(false);
                  }}
                  parentKey="root"
                  parentPathLabels={[]} // start empty
                  query={q} // reuse the input text to filter inside modal
                />
              ) : (
                <div className="text-sm text-gray-400">Loading…</div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Branch chooser (if a tag has multiple placements) */}
      {branchChoices && (
        <div className="fixed inset-0 z-50 grid place-items-center bg-black/60 p-4" onClick={() => setBranchChoices(null)}>
          <div className="card w-full max-w-xl p-4" onClick={e => e.stopPropagation()}>
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold">Choose branch</div>
              <button className="btn btn-outline text-xs" onClick={() => setBranchChoices(null)}>Close</button>
            </div>
            <div className="space-y-2 max-h-[60vh] overflow-auto">
              {branchChoices.options.map((opt, i) => (
                <button
                  key={`${opt.placementId ?? 'none'}#${i}`}
                  className="w-full text-left px-3 py-2 hover:bg-white/5 rounded-md border border-white/10"
                  onClick={() => {
                    onChange({ tagId: branchChoices.tagId, placementId: opt.placementId });
                    setSelectedPath({ tagId: branchChoices.tagId, labels: opt.labels });
                    setBranchChoices(null);
                  }}
                >
                  {opt.labels.join(' › ')}
                </button>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

/* ---------- helpers ---------- */

function normalizeTree(rawNodes: any[], parentKey: string): TagNode[] {
  return (rawNodes || []).map((node, idx) => {
    const tagId: string =
      node.tagId ??
      node.tag?.id ??
      node.tag_id ??
      node.tagID ??
      node.id; // fallback

    const name: string =
      node.name ??
      node.tag?.name ??
      node.title ??
      node.label ??
      '(untitled)';

    const description: string | null | undefined =
      node.description ?? node.tag?.description ?? null;

    const placementId: string | undefined = node.placementId ?? node.id;
    const placementKey: string = String(placementId ?? `${tagId}-${idx}`);

    const children = normalizeTree(node.children || [], `${parentKey}/${placementKey}`);

    return { tagId, name, description, placementKey, placementId, children };
  });
}

// Find first path to tagId (labels only) — fallback only
function findPathLabelsByTagId(nodes: TagNode[], tagId: string): string[] | null {
  for (const n of nodes) {
    if (n.tagId === tagId) return [n.name];
    if (n.children?.length) {
      const down = findPathLabelsByTagId(n.children, tagId);
      if (down) return [n.name, ...down];
    }
  }
  return null;
}

// Collect all placements (paths) for a tag id
function collectPlacementsByTagId(
  nodes: TagNode[],
  tagId: string,
  parentPath: string[] = []
): { placementId: string | null; labels: string[] }[] {
  const out: { placementId: string | null; labels: string[] }[] = [];
  for (const n of nodes) {
    const path = [...parentPath, n.name];
    if (n.tagId === tagId) {
      out.push({ placementId: n.placementId ?? null, labels: path });
    }
    if (n.children?.length) {
      out.push(...collectPlacementsByTagId(n.children, tagId, path));
    }
  }
  return out;
}

/* ---------- Tree (recursive) ---------- */

function Tree({
  nodes,
  expanded,
  onToggle,
  onPick,
  parentKey,
  parentPathLabels,
  query,
}: {
  nodes: TagNode[];
  expanded: Record<string, boolean>;
  onToggle: (nodeKey: string) => void;
  onPick: (tagId: string, pathLabels: string[], placementId?: string) => void;
  parentKey: string;
  parentPathLabels: string[];
  query: string; // filter inside modal
}) {
  const filteredNodes = useMemo(() => {
    const s = query.trim().toLowerCase();
    if (!s) return nodes;
    const match = (n: TagNode): boolean =>
      n.name.toLowerCase().includes(s) || (n.children?.some(match) ?? false);
    return nodes.filter(match);
  }, [nodes, query]);

  return (
    <ul className="space-y-1">
      {filteredNodes.map((n, idx) => {
        const nodeKey = `${parentKey}/${n.placementKey}#${idx}`; // unique key per placement path
        const hasKids = !!(n.children && n.children.length);
        const open = !!expanded[nodeKey];
        const pathLabels = [...parentPathLabels, n.name];

        return (
          <li key={nodeKey}>
            <div className="flex items-center gap-2">
              {hasKids ? (
                <button
                  className="h-6 w-6 grid place-items-center rounded-md border border-white/10"
                  onClick={() => onToggle(nodeKey)}
                  title={open ? 'Collapse' : 'Expand'}
                >
                  {open ? '▾' : '▸'}
                </button>
              ) : (
                <span className="h-6 w-6 grid place-items-center text-gray-500">•</span>
              )}
              <button
                className="btn btn-outline text-xs"
                onClick={() => onPick(n.tagId, pathLabels, n.placementId)}
                title={n.description || ''}
              >
                {n.name}
              </button>
            </div>

            {hasKids && open && (
              <div className="ml-6 mt-1">
                <Tree
                  nodes={n.children!}
                  expanded={expanded}
                  onToggle={onToggle}
                  onPick={onPick}
                  parentKey={nodeKey}
                  parentPathLabels={pathLabels}
                  query={query}
                />
              </div>
            )}
          </li>
        );
      })}
    </ul>
  );
}

```

---

## src/components/WeightSliders.tsx

```tsx
// src/components/WeightSliders.tsx
'use client';

import { useMemo, useState } from 'react';
import { equalizeUnlockedPPM, normalizeWithLocksPPM, percentToPpm, ppmToPercent, setWeightAtIndexWithLocksPPM } from '@/lib/weights';

export type WeightRow = {
  id: string;
  label: string;
  ppm: number;
  locked?: boolean;
  rightHint?: React.ReactNode; // optional preview (e.g., ¥ value)
};

export default function WeightSliders(props: {
  title: string;
  rows: WeightRow[];
  onChange: (rows: WeightRow[]) => void;
  help?: string;
}) {
  const { title, help } = props;

  // Keep lock states locally (simple & ergonomic). You can lift this up if you want to persist locks.
  const [locks, setLocks] = useState<Record<string, boolean>>(() =>
    Object.fromEntries(props.rows.map(r => [r.id, !!r.locked]))
  );

  const sumPercent = useMemo(() => {
    const totalPpm = props.rows.reduce((a, r) => a + r.ppm, 0);
    return (totalPpm / 10_000).toFixed(1);
  }, [props.rows]);

  const toggleLock = (id: string) => {
    setLocks(prev => ({ ...prev, [id]: !prev[id] }));
  };

  const apply = (nextPpm: number[]) => {
    const next = props.rows.map((r, i) => ({ ...r, ppm: nextPpm[i] }));
    props.onChange(next);
  };

  const onChangeIdx = (idx: number, newPercent: number) => {
    const ppm = props.rows.map(r => r.ppm);
    const locked = props.rows.map(r => !!locks[r.id]);
    const next = setWeightAtIndexWithLocksPPM(ppm, idx, percentToPpm(newPercent), locked);
    apply(next);
  };

  const onNormalize = () => {
    const ppm = props.rows.map(r => r.ppm);
    const locked = props.rows.map(r => !!locks[r.id]);
    apply(normalizeWithLocksPPM(ppm, locked));
  };

  const onEqualize = () => {
    const ppm = props.rows.map(r => r.ppm);
    const locked = props.rows.map(r => !!locks[r.id]);
    apply(equalizeUnlockedPPM(ppm, locked));
  };

  return (
    <div className="rounded-xl border border-white/10 p-3">
      <div className="flex items-center justify-between mb-2">
        <div className="font-semibold">{title}</div>
        <div className="flex items-center gap-2">
          <span className={`text-xs ${sumPercent === '100.0' ? 'text-emerald-400' : 'text-amber-400'}`}>
            Total: {sumPercent}%
          </span>
          <button className="btn btn-outline text-xs" onClick={onEqualize}>Equalize</button>
          <button className="btn btn-outline text-xs" onClick={onNormalize}>Normalize</button>
        </div>
      </div>
      {help && <div className="text-xs text-gray-400 mb-3">{help}</div>}

      <div className="space-y-3">
        {props.rows.map((r, i) => {
          const percent = ppmToPercent(r.ppm);
          const isLocked = !!locks[r.id];
          return (
            <div key={r.id} className="grid grid-cols-12 gap-3 items-center">
              <div className="col-span-4">
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => toggleLock(r.id)}
                    className={`h-6 w-6 grid place-items-center rounded-md border ${isLocked ? 'bg-white/10' : ''}`}
                    title={isLocked ? 'Unlock' : 'Lock'}
                    style={{ borderColor: 'var(--color-border)' }}
                  >
                    {isLocked ? '🔒' : '🔓'}
                  </button>
                  <div className="font-medium truncate" title={r.label}>{r.label}</div>
                </div>
              </div>

              <div className="col-span-6">
                <input
                  type="range"
                  min={0}
                  max={1000} // 0.1% steps
                  step={1}
                  value={Math.round(percent * 10)}
                  onChange={(e) => onChangeIdx(i, Number(e.target.value) / 10)}
                  disabled={isLocked}
                  className="w-full"
                />
              </div>

              <div className="col-span-2">
                <div className="flex items-center gap-1">
                  <input
                    type="number"
                    step={0.1}
                    className="field w-20"
                    value={percent.toFixed(1)}
                    onChange={(e) => onChangeIdx(i, parseFloat(e.target.value || '0'))}
                    disabled={isLocked}
                  />
                  <span className="text-xs">% </span>
                </div>
              </div>

              {r.rightHint && <div className="col-span-12 text-right text-xs text-gray-400">{r.rightHint}</div>}
            </div>
          );
        })}
      </div>
    </div>
  );
}

```

---

## src/lib/fx.client.ts

```ts
export async function getJpyToEurRate(dateISO: string): Promise<number | null> {
  try {
    const r = await fetch(`/api/fx?date=${encodeURIComponent(dateISO)}&base=JPY&quote=EUR`, { cache: 'no-store' });
    const j = await r.json();
    if (!r.ok) {
      console.error('FX API error', j);
      return null;
    }
    const rate = typeof j.rate === 'string' ? parseFloat(j.rate) : j.rate;
    if (!isFinite(rate)) {
      console.error('FX API returned invalid rate', j);
      return null;
    }
    return rate;
  } catch (e) {
    console.error('FX fetch failed', e);
    return null;
  }
}

// Safe multiply using integers to dodge FP noise where it matters in UI
// yen is Decimal(12,2) in backend; in UI we usually have a JS number
export function yenToEuro(yen: number, rate: number | null): number {
  if (!rate || !isFinite(rate)) return 0;
  const eur = yen * rate;
  // Round to 2 decimals for display
  return Math.round(eur * 100) / 100;
}

```

---

## src/lib/prisma.ts

```ts
import { PrismaClient } from '@prisma/client';

// Prevent creating many clients in dev (Next.js hot reload)
const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: ['warn', 'error'], // add 'query' if you want verbose logs
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

---

## src/lib/refresh-runner.ts

```ts
import { spawn, ChildProcessWithoutNullStreams } from 'node:child_process';

type Source = 'buyee' | 'zenmarket' | 'fromjapan';

type ProcMap = Map<Source, ChildProcessWithoutNullStreams>;
declare global {
  // eslint-disable-next-line no-var
  var __refreshProcs__: ProcMap | undefined;
}
const procs: ProcMap = globalThis.__refreshProcs__ ?? new Map<Source, ChildProcessWithoutNullStreams>();
globalThis.__refreshProcs__ = procs;

const SCRIPT_BY_SOURCE: Record<Source, string> = {
  buyee:     'src/scripts/save-buyee-auth.ts',
  zenmarket: 'src/scripts/save-zenmarket-auth.ts',
  fromjapan: 'src/scripts/save-fromjapan-auth.ts',
};

function norm(src: string): Source {
  const s = src.toLowerCase() as Source;
  if (s !== 'buyee' && s !== 'zenmarket' && s !== 'fromjapan') throw new Error('invalid_source');
  return s;
}

export function getRunning(source: string) {
  return procs.get(norm(source));
}

export function startRefresh(source: string) {
  const s = norm(source);
  const prev = procs.get(s);
  if (prev && !prev.killed) {
    try { prev.kill('SIGTERM'); } catch {}
  }

  const script = SCRIPT_BY_SOURCE[s];
  const cmd = process.platform === 'win32' ? 'npx.cmd' : 'npx';

  const child = spawn(cmd, ['tsx', script], {
    cwd: process.cwd(),
    env: { ...process.env, FORCE_COLOR: '1' },
    stdio: ['pipe', 'pipe', 'pipe'],
    shell: true,
  });

  procs.set(s, child);

  // Optional: helpful logs in server console
  child.stdout.on('data', d => process.stdout.write(`[auth:${s}] ${d}`));
  child.stderr.on('data', d => process.stderr.write(`[auth:${s}:ERR] ${d}`));

  const cleanup = () => { if (procs.get(s) === child) procs.delete(s); };
  child.on('exit', cleanup);
  child.on('close', cleanup);

  return { pid: child.pid ?? 0 };
}

export async function confirmRefresh(source: string) {
  const s = norm(source);
  const p = procs.get(s);
  if (!p) return { ok: false, error: 'no_process' };
  try { p.stdin.write('\n'); } catch {}
  const code: number = await new Promise((resolve) => {
    const done = (c: number | null) => resolve(c ?? 0);
    p.once('exit', done);
    p.once('close', done);
  });
  return { ok: code === 0, code };
}

export function abortRefresh(source: string) {
  const s = norm(source);
  const p = procs.get(s);
  if (!p) return { ok: false };
  try { p.kill('SIGTERM'); } catch {}
  procs.delete(s);
  return { ok: true };
}

```

---

## src/lib/scrape.ts

```ts
export type BuyeeItem = {
  orderNumber: string;
  title: string;
  itemUrl: string;
  listingId?: string;
  priceYen?: number;            // from Invoice Information → Subtotal
};

export type BuyeePackage = {
  dateShipped?: string;         // YYYY-MM-DD
  intlTrackingNumber?: string;  // e.g., CL072455942JP
  intlTrackingUrl?: string;
  packageNumber?: string;       // e.g., G2505289472
  items: BuyeeItem[];
  internationalShippingFeeYen?: number;
  domesticShippingFeeYen?: number;
};

export type BuyeeShippedResult = {
  proxyName: 'buyee';
  pageUrl: string;
  packages: BuyeePackage[];
};

export function yenToNumber(txt?: string): number | undefined {
  if (!txt) return;
  const cleaned = txt
    .replace(/[^\d.,-]/g, '')
    .replace(/,(?=\d{3}(\D|$))/g, '')        // remove thousands commas
    .replace(/(\d),(?=\d{1,2}$)/, '$1.');    // 1,23 => 1.23 (safety)
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : undefined;
}
```

---

## src/lib/translate.ts

```ts
type Provider = 'deepl' | 'libre' | undefined;

export async function translateJaToEn(texts: string[]): Promise<string[]> {
  const cleaned = texts.map(t => (t || '').trim());
  if (!cleaned.length) return [];

  const provider: Provider = (process.env.TRANSLATE_PROVIDER as Provider) || undefined;
  if (!provider) return cleaned; // no-op if not configured

  if (provider === 'deepl') return deeplTranslate(cleaned);
  if (provider === 'libre') return libreTranslate(cleaned);

  return cleaned;
}

async function deeplTranslate(texts: string[]): Promise<string[]> {
  const key = process.env.DEEPL_API_KEY;
  if (!key) return texts;

  const body = new URLSearchParams();
  texts.forEach(t => body.append('text', t));
  body.append('source_lang', 'JA');
  body.append('target_lang', 'EN');

  const resp = await fetch('https://api-free.deepl.com/v2/translate', {
    method: 'POST',
    headers: {
      'Authorization': `DeepL-Auth-Key ${key}`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: body.toString(),
  });
  if (!resp.ok) return texts;

  const data: any = await resp.json();
  return (data.translations || []).map((r: any) => r.text ?? '');
}

async function libreTranslate(texts: string[]): Promise<string[]> {
  const base = process.env.LIBRE_TRANSLATE_URL || 'http://localhost:5000';
  const out: string[] = [];
  for (const t of texts) {
    const resp = await fetch(`${base}/translate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ q: t, source: 'ja', target: 'en', format: 'text' }),
    });
    if (!resp.ok) { out.push(t); continue; }
    const data: any = await resp.json();
    out.push(data.translatedText || t);
  }
  return out;
}
```

---

## src/lib/weights.ts

```ts
// src/lib/weights.ts
export const PPM_DENOM = 1_000_000; // 100%

export function percentToPpm(percent: number): number {
  if (!isFinite(percent)) return 0;
  return Math.max(0, Math.min(PPM_DENOM, Math.round(percent * 10_000)));
}

export function ppmToPercent(ppm: number): number {
  return ppm / 10_000;
}

/** Linked sliders without locks: redistribute proportionally to keep total == DENOM */
export function setWeightAtIndexPPM(ppm: number[], idx: number, newValue: number): number[] {
  return setWeightAtIndexWithLocksPPM(ppm, idx, newValue, new Array(ppm.length).fill(false));
}

/** Lock-aware redistribution (true = locked). Keeps exact sum == DENOM. */
export function setWeightAtIndexWithLocksPPM(
  ppm: number[],
  idx: number,
  newValue: number,
  locked: boolean[]
): number[] {
  const n = ppm.length;
  const clamp = (x: number) => Math.max(0, Math.min(PPM_DENOM, x | 0));

  // Treat edited row as unlocked (editing implicitly unlocks it)
  const effLocked = locked.slice();
  effLocked[idx] = false;

  const current = ppm.slice();
  const sumLocked = current.reduce((a, v, j) => a + (effLocked[j] ? v : 0), 0);

  // Available budget for unlocked rows
  const budget = PPM_DENOM - sumLocked;
  const newI = clamp(Math.min(newValue, budget)); // cannot exceed the free budget

  const unlockedOthers = [];
  let oldUnlockedOthersSum = 0;
  for (let j = 0; j < n; j++) {
    if (!effLocked[j] && j !== idx) {
      unlockedOthers.push(j);
      oldUnlockedOthersSum += current[j];
    }
  }

  const next = current.slice();
  next[idx] = newI;

  const newRema = budget - newI;

  if (unlockedOthers.length === 0) {
    // No degrees of freedom; everything else locked. Force the edited value to consume all budget.
    next[idx] = budget;
    // Sum is exact by construction.
    return next;
  }

  // Proportional scale unlocked others to fill newRema
  if (oldUnlockedOthersSum === 0) {
    // Split equally among unlocked others
    const each = Math.floor(newRema / unlockedOthers.length);
    for (const j of unlockedOthers) next[j] = each;
    // fix residue
    let diff = newRema - each * unlockedOthers.length;
    for (let k = 0; diff > 0; k = (k + 1) % unlockedOthers.length) {
      next[unlockedOthers[k]]++;
      diff--;
    }
  } else {
    for (const j of unlockedOthers) {
      next[j] = Math.floor(current[j] * (newRema / oldUnlockedOthersSum));
    }
    // fix rounding residue across unlocked others
    const diff = budget - next.reduce((a, b, j) => a + (effLocked[j] ? 0 : b), 0);
    if (diff !== 0) {
      const order = unlockedOthers
        .slice()
        .sort((a, b) => current[b] - current[a]); // bias bigger buckets
      let k = 0, remain = Math.abs(diff);
      while (remain--) {
        next[order[k]] += Math.sign(diff);
        k = (k + 1) % order.length;
      }
    }
  }
  return next;
}

/** Normalize unlocked rows so total == DENOM (respect locks, keep proportions) */
export function normalizeWithLocksPPM(ppm: number[], locked: boolean[]): number[] {
  const n = ppm.length;
  const sumLocked = ppm.reduce((a, v, j) => a + (locked[j] ? v : 0), 0);
  const budget = PPM_DENOM - sumLocked;

  const unlockedIdxs = [];
  let sumUnlocked = 0;
  for (let j = 0; j < n; j++) if (!locked[j]) { unlockedIdxs.push(j); sumUnlocked += ppm[j]; }

  const next = ppm.slice();
  if (unlockedIdxs.length === 0) return next;
  if (sumUnlocked === 0) {
    const each = Math.floor(budget / unlockedIdxs.length);
    for (const j of unlockedIdxs) next[j] = each;
    let diff = budget - each * unlockedIdxs.length;
    for (let k = 0; diff > 0; k = (k + 1) % unlockedIdxs.length) { next[unlockedIdxs[k]]++; diff--; }
    return next;
  }

  for (const j of unlockedIdxs) next[j] = Math.floor(ppm[j] * (budget / sumUnlocked));
  const diff = budget - unlockedIdxs.reduce((a, j) => a + next[j], 0);
  let k = 0, remain = Math.abs(diff);
  while (remain--) {
    next[unlockedIdxs[k]] += Math.sign(diff);
    k = (k + 1) % unlockedIdxs.length;
  }
  return next;
}

/** Equal split across unlocked rows (respect locks) */
export function equalizeUnlockedPPM(ppm: number[], locked: boolean[]): number[] {
  const n = ppm.length;
  const sumLocked = ppm.reduce((a, v, j) => a + (locked[j] ? v : 0), 0);
  const budget = PPM_DENOM - sumLocked;

  const unlockedIdxs = [];
  for (let j = 0; j < n; j++) if (!locked[j]) unlockedIdxs.push(j);

  const next = ppm.slice();
  if (unlockedIdxs.length === 0) return next;

  const each = Math.floor(budget / unlockedIdxs.length);
  for (const j of unlockedIdxs) next[j] = each;
  let diff = budget - each * unlockedIdxs.length;
  for (let k = 0; diff > 0; k = (k + 1) % unlockedIdxs.length) { next[unlockedIdxs[k]]++; diff--; }
  return next;
}

```

---

## src/scrapers/buyee.ts

```ts
import fs from 'fs';
import path from 'path';
import { chromium, type Page } from 'playwright';
import { BuyeeShippedResult, BuyeePackage, yenToNumber } from '@/lib/scrape';

const PROFILE_DIR = process.env.BUYEY_PROFILE_DIR || '.secrets/buyee-profile';
const DEBUG = process.env.DEBUG_SCRAPER === '1';

export async function scrapeBuyeeShippedList(url: string): Promise<BuyeeShippedResult> {
      const absProfile = path.resolve(PROFILE_DIR);
if (!fs.existsSync(absProfile)) {
    throw new Error(`Buyee profile not found at ${absProfile}. Run the profile initializer first.`);
  }
 const context = await chromium.launchPersistentContext(absProfile, {
    channel: 'chrome',        // IMPORTANT: use real Chrome
    headless: false,          // start visible first; switch to true later if it still works
    viewport: { width: 1366, height: 900 },
    locale: 'en-US',
    userAgent:
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
      '(KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36',
    extraHTTPHeaders: { 'Accept-Language': 'en-US,en;q=0.9,ja;q=0.8' },
  });
  const page = await context.newPage();
  try {
    // Prime a buyee tab so cookies attach to the correct domain
    await page.goto('https://buyee.jp/', { waitUntil: 'domcontentloaded' });
    await page.goto(url, { waitUntil: 'domcontentloaded' });

    // Detect not-logged-in redirect
    const currentUrl = page.url();
    if (/\/login\b/i.test(currentUrl)) {
      await page.screenshot({ path: '/tmp/buyee-login.png', fullPage: true }).catch(()=>{});
      throw new Error('Not logged in (redirected to /login). Check cookies file. Screenshot: /tmp/buyee-login.png');
    }

    // Try to locate shipped entries
    const entries = await page.locator('li.luggageInfo.shipped').count();
    if (DEBUG) console.log(`[scraper] found ${entries} shipped entries on ${currentUrl}`);

    if (entries === 0) {
      await page.screenshot({ path: '/tmp/buyee-empty.png', fullPage: true }).catch(()=>{});
      throw new Error('No shipped entries found. Selectors may need adjustment or cookies invalid. Screenshot: /tmp/buyee-empty.png');
    }

    // ... (leave the rest of the extraction code as we wrote before)
    const packages: BuyeePackage[] = await page.locator('li.luggageInfo.shipped').evaluateAll((nodes) => {
      const parseYen = (s?: string) => {
        if (!s) return undefined;
        const cleaned = s.replace(/[^\d.,-]/g, '').replace(/,(?=\d{3}(\D|$))/g, '').replace(/(\d),(?=\d{1,2}$)/, '$1.');
        const n = Number(cleaned);
        return Number.isFinite(n) ? n : undefined;
      };

      return nodes.map((li) => {
        const pick = (sel: string) => (li.querySelector(sel)?.textContent || '').trim();

        const dateRaw = pick('.luggageInfo_header .date_shipped');
        const dateShipped = (dateRaw.match(/\d{4}-\d{2}-\d{2}/) || [])[0];

        const intlA = li.querySelector('.luggageInfo_header .i18n_shipping_number a') as HTMLAnchorElement | null;
        const intlTrackingNumber = intlA?.textContent?.trim();
        const intlTrackingUrl = intlA?.href || undefined;

        const pkgRaw = pick('.luggageInfo_header .package_number');
        const packageNumber = pkgRaw.replace(/^Package number/i, '').trim() || undefined;

        const items: any[] = [];
        li.querySelectorAll('.luggageInfo_order tr').forEach((tr, idx) => {
          if (idx === 0) return;
          const tds = tr.querySelectorAll('td');
          if (tds.length < 3) return;
          const orderNumber = (tds[1]?.textContent || '').trim();
          const a = tds[2]?.querySelector('a') as HTMLAnchorElement | null;
          const title = (a?.textContent || '').trim();
          const itemUrl = a?.href || '';
          const listingId = itemUrl ? itemUrl.split('/').filter(Boolean).pop() : undefined;
          if (orderNumber || title) items.push({ orderNumber, title, itemUrl, listingId });
        });

        let internationalShippingFeeYen: number | undefined;
        let domesticShippingFeeYen: number | undefined;
        const fee = li.querySelector('.amount_info_container');
        if (fee) {
          const dts = Array.from(fee.querySelectorAll('dt'));
          const dds = Array.from(fee.querySelectorAll('dd'));
          for (let i = 0; i < dts.length; i++) {
            const label = (dts[i].textContent || '').replace(/\s+/g, ' ').trim();
            const value = (dds[i]?.textContent || '').trim();
            if (/^International Shipping Fee/i.test(label)) internationalShippingFeeYen = parseYen(value);
            if (/^Domestic Shipping Fee/i.test(label)) domesticShippingFeeYen = parseYen(value);
          }
        }

        const invoice = li.querySelector('.delivery_info_container .invoice_info table')
                      || li.querySelector('.invoice_info table');
        if (invoice) {
          const subtotals: number[] = [];
          invoice.querySelectorAll('tr').forEach((tr, idx) => {
            if (idx === 0) return;
            const tds = tr.querySelectorAll('td');
            if (tds.length >= 3) {
              const subTxt = (tds[2]?.textContent || '').trim();
              const n = parseYen(subTxt);
              if (typeof n === 'number') subtotals.push(n);
            }
          });
          for (let i = 0; i < items.length && i < subtotals.length; i++) {
            items[i].priceYen = subtotals[i];
          }
        }

        return {
          dateShipped,
          intlTrackingNumber,
          intlTrackingUrl,
          packageNumber,
          items,
          internationalShippingFeeYen,
          domesticShippingFeeYen,
        };
      });
    });

    const result: BuyeeShippedResult = { proxyName: 'buyee', pageUrl: url, packages };
    if (DEBUG) console.log('[scraper] result sample:', JSON.stringify(result.packages[0], null, 2));
    return result;
  } finally {
    await page.close();
    await context.close();
  }
}
```

---

## src/scrapers/fromjapan.ts

```ts
import path from 'path';
import fs from 'fs';
import { chromium } from 'playwright';

export type FJItem = {
  listingId?: string;     // auction ID / item_id
  orderNumber?: string;   // not exposed in JSON; leave undefined for now
  title: string;
  itemUrl: string;
  priceYen?: number;      // Charge 1 (c1_total)
};

export type FJPackage = {
  packageNumber: string;            // unique per physical package (shipmentNo#i if multi)
  baseShipmentNumber: string;       // original Shipment No. (or iid fallback)
  dateShipped?: string;             // shipped_date (YYYY-MM-DD part)
  trackingNumbers: string[];        // one or more tracking numbers
  items: FJItem[];
  internationalShippingFeeYen?: number; // Charge 2 (c2_total) split evenly across packages
  domesticShippingFeeYen?: number;      // always 0 per spec
};

export type FJShippedResult = {
  proxyName: 'fromjapan';
  pageUrl: string;
  packages: FJPackage[];
};

// Match your login helper’s path by default
const PROFILE_DIR = process.env.FJ_PROFILE_DIR || '/home/oulette/.proxy-profiles/fj-profile';
const DEBUG = process.env.DEBUG_SCRAPER === '1';
const KEEP_OPEN = process.env.KEEP_FJ_BROWSER_OPEN === '1';

function decodeUrlMaybe(u?: string): string {
  if (!u) return '';
  try { return decodeURIComponent(u); } catch { return u; }
}

function asNumber(v: unknown): number | undefined {
  return typeof v === 'number' && Number.isFinite(v) ? v : undefined;
}

/**
 * Scrape the shipped list. Supports multi-page by POSTing { currentPage } to the list endpoint.
 * @param url e.g. https://www.fromjapan.co.jp/japan/en/member/history/ship/list
 * @param page 1-based page number. Page 1 loads directly; page>1 fetched via POST and injected.
 */
export async function scrapeFromJapanShippedList(url: string, page: number = 1): Promise<FJShippedResult> {
  const absProfile = path.resolve(PROFILE_DIR);
  if (!fs.existsSync(absProfile)) {
    throw new Error(`FromJapan profile not found at ${absProfile}. Run the profile initializer to login first.`);
  }

  const context = await chromium.launchPersistentContext(absProfile, {
    channel: 'chrome',
    headless: false, // visible while stabilizing
    viewport: { width: 1366, height: 900 },
    locale: 'en-US',
    userAgent:
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36',
    extraHTTPHeaders: { 'Accept-Language': 'en-US,en;q=0.9,ja;q=0.8' },
  });

  const pageObj = await context.newPage();
  try {
    // 1) Load base list page to ensure session cookies are applied
    await pageObj.goto(url, { waitUntil: 'domcontentloaded' });

    // If requesting page > 1, POST { currentPage } and inject that HTML so we can reuse the same parser
    if (Number(page) > 1) {
      const resp = await context.request.post(url, {
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        form: { currentPage: String(page) },
      });
      if (!resp.ok()) {
        throw new Error(`FJ list POST failed for page ${page}: ${resp.status()} ${resp.statusText()}`);
      }
      const html = await resp.text();
      await pageObj.setContent(html, { waitUntil: 'domcontentloaded' });
    }

    // 2) Wait for the embedded data blob to exist AND be non-empty
    await pageObj.waitForSelector('script#bData', { state: 'attached', timeout: 20000 }).catch(() => {});
    await pageObj.waitForFunction(() => {
      const s = document.querySelector<HTMLScriptElement>('script#bData');
      return !!(s && (s.textContent || '').trim().length > 10);
    }, { timeout: 20000 }).catch(() => { /* fallback paths below */ });

    // 3) Pull and parse the JSON embedded in #bData (robust: base64 → JSON → window.bData → inline assignment)
    const shipments = await pageObj.evaluate(() => {
      function tryParse(raw: string | null | undefined): any | null {
        if (!raw) return null;
        raw = raw.trim();
        if (!raw) return null;
        // base64 first
        try { return JSON.parse(atob(raw)); } catch {}
        // plain JSON
        try { return JSON.parse(raw); } catch {}
        return null;
      }

      function extractBData(): any | null {
        // a) <script id="bData">...</script>
        const script = document.querySelector<HTMLScriptElement>('script#bData');
        if (script) {
          const parsed = tryParse(script.textContent || '');
          if (parsed) return parsed;
        }

        // b) window.bData (string or object)
        const w: any = window as any;
        if (w && w.bData != null) {
          if (typeof w.bData === 'string') {
            const parsed = tryParse(w.bData);
            if (parsed) return parsed;
          } else if (typeof w.bData === 'object') {
            return w.bData;
          }
        }

        // c) inline assignment like: var bData = "....";
        for (const sc of Array.from(document.querySelectorAll('script'))) {
          const txt = (sc.textContent || '').trim();
          if (!txt) continue;
          const m = txt.match(/bData\s*=\s*(['"])([\s\S]*?)\1/);
          if (m && m[2]) {
            const parsed = tryParse(m[2]);
            if (parsed) return parsed;
          }
        }

        return null;
      }

      const data = extractBData() || {};
      const list: any[] =
        Array.isArray((data as any).list) ? (data as any).list :
        Array.isArray((data as any)?.data?.list) ? (data as any).data.list :
        [];

      const result: any[] = [];

      for (const shp of list) {
        try {
          // Prefer shipment_no; fallback to iid (numeric stable id)
          const shipmentNo: string | undefined =
            (shp.shipment_no_str as string) ||
            (shp.shipment_no as string) ||
            (shp.iid != null ? String(shp.iid) : undefined);
          if (!shipmentNo) continue;

          // Date shipped (YYYY-MM-DD from shipped_date)
          let dateShipped: string | undefined;
          if (typeof shp.shipped_date === 'string') {
            const m = shp.shipped_date.match(/\d{4}-\d{2}-\d{2}/);
            if (m) dateShipped = m[0];
          }

          // Tracking numbers: keys of ship_no object
          const trackingNumbers: string[] = [];
          if (shp.ship_no && typeof shp.ship_no === 'object') {
            for (const key of Object.keys(shp.ship_no)) {
              if (key && typeof key === 'string') trackingNumbers.push(key.trim());
            }
          }

          // Shipment-level shipping cost (Charge 2)
          const charge2Total: number = typeof shp.c2_total === 'number' ? shp.c2_total : 0;

          // Items (Charge 1 per item)
          const itemsRaw: any[] = Array.isArray(shp.items) ? shp.items : [];
          const items = itemsRaw.map((it) => {
            const title = (it.item_name as string) || '';
            const itemUrl = decodeURIComponent((it.item_url as string) || '');
            const listingId = (it.item_id as string) || undefined; // Yahoo auction ID, etc.
            const priceYen = typeof it.c1_total === 'number' ? it.c1_total : undefined; // Charge 1
            return { listingId, orderNumber: undefined, title, itemUrl, priceYen };
          });

          result.push({ dateShipped, shipmentNo, trackingNumbers, items, charge2Total });
        } catch {
          // ignore malformed rows
        }
      }

      return result;
    });

    // 4) Expand multi-package (split charge2 evenly; ITEMS distribution with special single-item split rule)
    const packages: FJPackage[] = [];
    for (const s of shipments as any[]) {
      if (!s.shipmentNo) continue;

      const nPkgs = Math.max(1, s.trackingNumbers?.length || 1);
      const perPkgShip = s.charge2Total ? s.charge2Total / nPkgs : 0;

      const allItems: FJItem[] = (s.items || []).map((it: any) => ({
        listingId: it.listingId,
        orderNumber: it.orderNumber,
        title: it.title,
        itemUrl: decodeUrlMaybe(it.itemUrl),
        priceYen: asNumber(it.priceYen),
      }));

      // SPECIAL CASE:
      // If there's exactly 1 item but multiple parcels, duplicate the item across all parcels
      // and split its price evenly (integers, sum preserved).
      const singleItemSplit = nPkgs > 1 && allItems.length === 1;

      // Even block distribution (default)
      const m = allItems.length;
      const base = Math.floor(m / nPkgs);
      const extra = m % nPkgs;
      let cursor = 0;

      for (let i = 0; i < nPkgs; i++) {
        let pkgItems: FJItem[];

        if (singleItemSplit) {
          const original = allItems[0];
          let share: number | undefined = undefined;

          if (typeof original.priceYen === 'number') {
            const total = Math.round(original.priceYen);
            const per = Math.floor(total / nPkgs);
            const remainder = total - per * nPkgs;
            // Distribute remainder to the first 'remainder' packages
            share = per + (i < remainder ? 1 : 0);
          }

          pkgItems = [{ ...original, priceYen: share }];
        } else {
          const pkgCount = base + (i < extra ? 1 : 0);
          pkgItems = allItems.slice(cursor, cursor + pkgCount);
          cursor += pkgCount;
        }

        const pkgSuffix = nPkgs > 1 ? `#${i + 1}` : '';
        const packageNumber = `${s.shipmentNo}${pkgSuffix}`;
        const tracking = s.trackingNumbers?.[i] ? [s.trackingNumbers[i]] : (s.trackingNumbers || []);

        packages.push({
          packageNumber,
          baseShipmentNumber: s.shipmentNo,
          dateShipped: s.dateShipped,
          trackingNumbers: tracking,
          items: pkgItems,
          internationalShippingFeeYen: perPkgShip,
          domesticShippingFeeYen: 0,
        });
      }
    }

    if ((packages.length === 0) && !Number.isNaN(page)) {
      await pageObj.screenshot({ path: '/tmp/fj-empty.png', fullPage: true }).catch(() => {});
    }

    if (DEBUG) console.log(`[FJ] scraped shipments=${(shipments as any[]).length}, packages=${packages.length} (page ${page})`);
    return { proxyName: 'fromjapan', pageUrl: url, packages };
  } finally {
    if (!KEEP_OPEN) {
      await pageObj.close().catch(() => {});
      await context.close().catch(() => {});
    } else if (DEBUG) {
      // eslint-disable-next-line no-console
      console.log('[FJ] KEEP_FJ_BROWSER_OPEN=1 set — leaving browser open.');
    }
  }
}

```

---

## src/scrapers/zenmarket.ts

```ts
import path from 'path';
import fs from 'fs';
import { chromium } from 'playwright';

type ZMItemRow = {
  titleJa: string;
  itemUrl: string;
  listingId?: string | null;
  priceYen?: number;
  // used only to compute domestic total; not persisted per item
  localShipYen?: number;
};

type ZMItemsNested = {
  create: Array<{
    orderNumber?: string | null;
    titleJa?: string | null;
    titleEn?: string | null;
    itemUrl?: string | null;
    listingId?: string | null;
    priceYen?: number | null;
  }>;
};

export type ZMPackage = {
  proxyName: 'zenmarket';
  pageUrl: string;

  packageNumber: string;          // pid (unique)
  displayNumber?: string;         // e.g. "#2"

  dateShipped?: string;           // YYYY-MM-DD
  trackingNumber?: string | null;
  trackingUrl?: string | null;

  internationalShippingFeeYen?: number;
  domesticShippingFeeYen?: number;

  items?: ZMItemsNested;          // Prisma nested create
  raw?: any;
};

const PROFILE_DIR = process.env.ZM_PROFILE_DIR || '.secrets/zm-profile';
const DEBUG = process.env.DEBUG_SCRAPER === '1';

function yenToNumber(txt: string | null | undefined): number {
  if (!txt) return 0;
  const n = txt.replace(/[^0-9.-]/g, '');
  const v = Number(n);
  return Number.isFinite(v) ? v : 0;
}

// supports auction.aspx?itemCode=XXXX and pretty “/auction/XXXX”
function parseListingIdFromUrl(url: string): string | null {
  try {
    const m0 = url.match(/[?&]itemCode=([A-Za-z0-9]+)/i);
    if (m0) return m0[1];
    const m = url.match(/auction\/([A-Za-z0-9]+)/i);
    if (m) return m[1];
    const m2 = url.match(/mercari\.com\/.*\/item\/([A-Za-z0-9]+)/i);
    if (m2) return m2[1];
  } catch {}
  return null;
}

export async function scrapeZenMarketParcels(
  url = 'https://zenmarket.jp/fr/profile/parcel.aspx?state=5'
): Promise<ZMPackage[]> {
  const absProfile = path.resolve(PROFILE_DIR);
  if (!fs.existsSync(absProfile)) {
    throw new Error(`ZenMarket profile not found at ${absProfile}. Log in once with a persistent context.`);
  }

  const context = await chromium.launchPersistentContext(absProfile, {
    channel: 'chrome',
    headless: false,
    viewport: { width: 1366, height: 900 },
    userAgent:
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36',
    locale: 'fr-FR',
    extraHTTPHeaders: { 'Accept-Language': 'fr-FR,fr;q=0.9,en;q=0.8,ja;q=0.7' },
  });

  const page = await context.newPage();
  try {
    await page.goto(url, { waitUntil: 'domcontentloaded' });
    await page.waitForSelector('div.parcel', { timeout: 20000 });

    // -------- Discover parcels by walking .parcel cards --------
    const parcels = await page.evaluate(() => {
      const toNum = (s?: string | null) => {
        if (!s) return 0;
        const n = s.replace(/[^0-9.-]/g, '');
        const v = Number(n);
        return Number.isFinite(v) ? v : 0;
      };

      const normDate = (t: string): string | undefined => {
        const a = t.match(/\b(\d{4}-\d{2}-\d{2})\b/);
        if (a) return a[1];
        const b = t.match(/\b(\d{2}\/\d{2}\/\d{4})\b/);
        if (b) {
          const [dd, mm, yyyy] = b[1].split('/');
          return `${yyyy}-${mm}-${dd}`;
        }
        return undefined;
      };

      // Pull number from the parent <div> that contains `<span>Envoi:</span>` or `<span>Shipping:</span>`
      const extractIntlShipping = (card: HTMLElement): number => {
        const labelSpan = Array.from(card.querySelectorAll('span')).find(sp => {
          const t = (sp.textContent || '').trim();
          return t.startsWith('Envoi:') || t.startsWith('Shipping:');
        });
        if (!labelSpan) return 0;

        const container = labelSpan.parentElement as HTMLElement | null;
        if (!container) return 0;

        // The amount is the remaining text in the same container after removing the label text.
        let txt = (container.textContent || '').replace(labelSpan.textContent || '', '').trim();
        // e.g. "¥6,100"
        return toNum(txt);
      };

      const results: Array<{
        pid: string;
        displayNumber?: string;
        dateShipped?: string;
        trackingNumber?: string | null;
        trackingUrl?: string | null;
        intlShipping?: number;
      }> = [];

      document.querySelectorAll<HTMLDivElement>('div.parcel').forEach(card => {
        const link = card.querySelector<HTMLAnchorElement>('a[data-parcelid]');
        if (!link) return;
        const pid = link.getAttribute('data-parcelid');
        if (!pid) return;

        // e.g. "#2"
        const displayNumber =
          card.innerText.split('\n').map(s => s.trim()).find(s => /^#\d+\b/.test(s)) || undefined;

        const dateShipped = normDate(card.innerText);

        // Tracking (JP Post example in snippet)
        let trackingNumber: string | null = null;
        let trackingUrl: string | null = null;
        const links = Array.from(card.querySelectorAll('a[href]')) as HTMLAnchorElement[];
        const tlink = links.find(x => /[A-Z]{2}\d{9}[A-Z]{2}|\b\d{10,14}\b|JJD/i.test(x.textContent || ''));
        if (tlink) {
          trackingNumber = (tlink.textContent || '').trim() || null;
          trackingUrl = tlink.href || null;
        }

        const intlShipping = extractIntlShipping(card);

        results.push({ pid, displayNumber, dateShipped, trackingNumber, trackingUrl, intlShipping });
      });

      return results;
    });

    if (DEBUG) console.log('[ZM] found pids:', parcels.map((p: any) => p.pid));

    const packages: ZMPackage[] = [];

    for (const p of parcels) {
      if (!p.pid) continue;

      // Fetch parcel items
      const payload = { pid: Number(p.pid) };
      const resp = await page.evaluate(async (body) => {
        const r = await fetch('/profile/parcel.aspx/getParcelContent', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json; charset=UTF-8',
            'X-Requested-With': 'XMLHttpRequest',
          },
          body: JSON.stringify(body),
          credentials: 'same-origin',
        });
        return await r.json();
      }, payload);

      // JSON-first parse into ZMItemRow[]
      let rows: ZMItemRow[] = [];
      try {
        const raw = typeof resp?.d === 'string' ? resp.d : (resp?.d ? JSON.stringify(resp.d) : '[]');
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          rows = arr.map((it: any) => ({
            titleJa: String(it?.ProductName ?? '').trim(),
            itemUrl: String(it?.ProductURL ?? '').trim(),
            priceYen: yenToNumber(it?.Price) + yenToNumber(it?.Tax),
            localShipYen: yenToNumber(it?.LocalShippingPrice),
            listingId: null, // fill below outside evaluate()
          }));
        }
      } catch {}

      // Fill listingId client-side and compute domestic total
      let domesticTotal = 0;
      const rawItemsReady: ZMItemRow[] = rows.map(r => {
        const listingId = parseListingIdFromUrl(r.itemUrl || '') ?? null;
        domesticTotal += (r.localShipYen || 0);
        return { ...r, listingId };
      });

      // Convert to Prisma nested create shape (duplicate titleEn from titleJa)
      const itemsNested: ZMItemsNested | undefined =
        rawItemsReady.length > 0
          ? {
              create: rawItemsReady.map(r => ({
                orderNumber: null,
                titleJa: r.titleJa ?? null,
                titleEn: r.titleJa ?? null,  // duplicate JP into EN
                itemUrl: r.itemUrl ?? null,
                listingId: r.listingId ?? null,
                priceYen: (r.priceYen ?? 0),
              })),
            }
          : undefined;

      const pkg: ZMPackage = {
        proxyName: 'zenmarket',
        pageUrl: url,
        packageNumber: String(p.pid),
        displayNumber: p.displayNumber,
        dateShipped: p.dateShipped,
        trackingNumber: p.trackingNumber ?? null,
        trackingUrl: p.trackingUrl ?? null,
        internationalShippingFeeYen: p.intlShipping ?? 0,
        domesticShippingFeeYen: domesticTotal || 0,
        items: itemsNested,
        raw: { parcelMeta: p, response: resp },
      };

      packages.push(pkg);
    }

    if (DEBUG) console.log(`[ZM] scraped packages=${packages.length}`);
    return packages;
  } finally {
    await page.close();
    await context.close();
  }
}

```

---

## src/scripts/build-summary.mjs

```js
// scripts/build-summary.mjs
import fs from 'node:fs';
import path from 'node:path';
import { execSync } from 'node:child_process';
import url from 'node:url';

const repoRoot = process.cwd();
const OUT_FILE = (process.argv.includes('--out')
  ? process.argv[process.argv.indexOf('--out') + 1]
  : 'docs/codebase-summary.md');

const WATCH = process.argv.includes('--watch');

// allow-list of file extensions we’ll include in the summary
const TEXT_EXTS = new Set([
  // code
  '.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs',
  '.css', '.scss', '.sass',
  '.htm',
  '.mdx',
  '.yml', '.yaml', '.toml', '.ini', '.conf',
  '.prisma',
  '.sh', '.bash', '.zsh',
  '.py', '.rb', '.go', '.rs', '.kt', '.java',
  '.m', '.mm', '.swift',
  '.txt',
  // project config
  '.env.example', '.gitignore', '.gitattributes', '.editorconfig',
  '.tsconfig', '.eslintrc', '.prettierrc', '.npmrc',
]);

// soft size cap (skip huge text files)
const MAX_FILE_BYTES = 512 * 1024; // 512 KB

function languageFromExt(p) {
  const ext = path.extname(p).toLowerCase();
  switch (ext) {
    case '.ts': return 'ts';
    case '.tsx': return 'tsx';
    case '.js': case '.mjs': case '.cjs': return 'js';
    case '.jsx': return 'jsx';
    case '.css': return 'css';
    case '.scss': case '.sass': return 'scss';
    case '.html': case '.htm': return 'html';
    case '.json': return 'json';
    case '.yml': case '.yaml': return 'yaml';
    case '.toml': return 'toml';
    case '.sql': return 'sql';
    case '.prisma': return 'prisma';
    case '.md': case '.mdx': return 'md';
    case '.sh': case '.bash': case '.zsh': return 'bash';
    case '.py': return 'python';
    case '.rb': return 'ruby';
    case '.go': return 'go';
    case '.rs': return 'rust';
    case '.kt': return 'kotlin';
    case '.java': return 'java';
    case '.swift': return 'swift';
    default: return ''; // plain fence
  }
}

function getGitFiles() {
  // includes tracked + staged + untracked (but not ignored) files
  const out = execSync('git ls-files --cached --others --exclude-standard -z', { cwd: repoRoot });
  return out.toString('utf8').split('\0').filter(Boolean);
}

function getRepoMeta() {
  let commit = '';
  let when = '';
  let origin = '';
  try { commit = execSync('git rev-parse HEAD', { cwd: repoRoot }).toString('utf8').trim(); } catch {}
  try { when = execSync('git show -s --format=%ci HEAD', { cwd: repoRoot }).toString('utf8').trim(); } catch {}
  try { origin = execSync('git config --get remote.origin.url', { cwd: repoRoot }).toString('utf8').trim(); } catch {}
  return { commit, when, origin };
}

function isTextFile(p) {
  const ext = path.extname(p).toLowerCase();
  if (!TEXT_EXTS.has(ext)) return false;
  try {
    const st = fs.statSync(path.join(repoRoot, p));
    if (st.size > MAX_FILE_BYTES) return false;
    return true;
  } catch {
    return false;
  }
}

function buildOnce() {
  const files = getGitFiles().filter(isTextFile);

  const { commit, when, origin } = getRepoMeta();
  const header =
`# Codebase Summary

> Generated: ${new Date().toISOString()}
> Commit: ${commit || 'n/a'}
> Date: ${when || 'n/a'}
> Remote: ${origin || 'n/a'}

This file concatenates important text/code files in the repo so a single raw URL can be shared.

---

`;

  let out = header;

  for (const rel of files.sort()) {
    const abs = path.join(repoRoot, rel);
    let content = '';
    try {
      content = fs.readFileSync(abs, 'utf8');
    } catch {
      continue;
    }
    const lang = languageFromExt(rel);
    out += `\n---\n\n## ${rel}\n\n\`\`\`${lang}\n${content.replace(/\`\`\`/g, '```')}\n\`\`\`\n`;
  }

  const outAbs = path.join(repoRoot, OUT_FILE);
  fs.mkdirSync(path.dirname(outAbs), { recursive: true });
  fs.writeFileSync(outAbs, out, 'utf8');

  const relOut = path.relative(repoRoot, outAbs);
  console.log(`[summary] Wrote ${relOut} (${files.length} files)`);
}

async function main() {
  if (!WATCH) {
    buildOnce();
    return;
  }

  // Watch mode (uses chokidar if available; else falls back to periodic rebuild)
  try {
    const chokidar = (await import('chokidar')).default;
    const watcher = chokidar.watch(['**/*'], {
      ignored: [
        '**/.git/**',
        '**/node_modules/**',
        '**/.next/**',
        '**/dist/**',
        '**/build/**',
        '**/coverage/**',
        '**/.turbo/**',
        '**/.vercel/**',
        '**/.idea/**',
        '**/.vscode/**',
         '**/.sql/**',
         '**/package-lock.json/**',
         '**/debug-final.html/**',
        OUT_FILE,
      ],
      ignoreInitial: true,
    });

    let timer = null;
    const schedule = () => {
      clearTimeout(timer);
      timer = setTimeout(buildOnce, 200);
    };

    buildOnce();
    watcher.on('add', schedule).on('change', schedule).on('unlink', schedule);
    console.log('[summary] Watching for changes… (Ctrl+C to stop)');
  } catch (e) {
    console.warn('[summary] chokidar not installed. Run: npm i -D chokidar');
    // fallback: rebuild once
    buildOnce();
  }
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});

```

---

## src/scripts/games/import-libretro-tags.cjs

```js
#!/usr/bin/env node
/* eslint-disable no-console */
/**
 * Import game tags from a Libretro JSON file into your Tag tree.
 *
 * - Interactive TagPlacement chooser (browse by numbers; 'b' back; 's' select; 'q' quit)
 * - Creates Tag(name=serial) only if serial contains '-'
 * - Tag.description = title, Tag.photoUrl = boxartUrl
 * - Places each Tag under the selected branch (TagPlacement)
 * - Rebuilds PlacementClosure at the end
 *
 * Usage:
 *   node scripts/games/import-libretro-tags.cjs --json "data/games/libretro/Nintendo - Game Boy.json"
 *   # optional:
 *   --parent <placementId>  (skip the interactive picker)
 *   --dry-run               (no DB writes)
 *   --force-photo           (overwrite Tag.photoUrl if already set)
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

// ───────────────────────────────────────────────────────────────────────────────
// CLI
// ───────────────────────────────────────────────────────────────────────────────
const args = new Map();
for (let i = 2; i < process.argv.length; i++) {
  const k = process.argv[i];
  const v = process.argv[i + 1];
  if (k && k.startsWith('--')) {
    if (v && !v.startsWith('--')) { args.set(k.slice(2), v); i++; }
    else { args.set(k.slice(2), true); }
  }
}
const JSON_PATH = args.get('json');
const PARENT_PLACEMENT = args.get('parent') || null;
const DRY_RUN = !!args.get('dry-run');
const FORCE_PHOTO = !!args.get('force-photo');

if (!JSON_PATH) {
  console.error('❌ Missing --json <file>');
  process.exit(1);
}

function readJsonArray(p) {
  const raw = fs.readFileSync(p, 'utf8');
  const data = JSON.parse(raw);
  if (!Array.isArray(data)) throw new Error('JSON must be an array of { title, serial, boxartUrl, ... }');
  return data;
}

// ───────────────────────────────────────────────────────────────────────────────
// Tag tree utilities
// ───────────────────────────────────────────────────────────────────────────────
async function loadPlacementsTree() {
  const rows = await prisma.tagPlacement.findMany({
    select: {
      id: true,
      tagId: true,
      parentPlacementId: true,
      tag: { select: { id: true, name: true, description: true } },
    },
  });

  const byParent = new Map();
  for (const r of rows) {
    const k = r.parentPlacementId === null ? 'root' : r.parentPlacementId;
    if (!byParent.has(k)) byParent.set(k, []);
    byParent.get(k).push(r);
  }
  // sort children by tag.name for stable UX
  for (const arr of byParent.values()) arr.sort((a, b) => a.tag.name.localeCompare(b.tag.name));

  function build(parentId) {
    const key = parentId === null ? 'root' : parentId;
    const kids = byParent.get(key) || [];
    return kids.map((r) => ({
      placementId: r.id,
      tagId: r.tagId,
      name: r.tag.name,
      description: r.tag.description || '',
      children: build(r.id),
    }));
  }
  return build(null);
}

function printMenu(nodes, pathNames) {
  console.log('\nPath:', pathNames.length ? pathNames.join(' › ') : '(root)');
  if (!nodes.length) {
    console.log('(no children here)');
  } else {
    nodes.forEach((n, i) => console.log(`${String(i + 1).padStart(2, ' ')}. ${n.name}`));
  }
  console.log("\nChoose a number, 'b' = back, 's' = select here, 'q' = quit");
}

async function pickPlacementInteractively() {
  const roots = await loadPlacementsTree();
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  const ask = (q) => new Promise((res) => rl.question(q, (a) => res(a.trim())));

  const stack = []; // stack of { nodes, index, name }
  let currentNodes = roots;
  let pathNames = [];

  while (true) {
    printMenu(currentNodes, pathNames);
    const ans = await ask('> ');
    if (ans === 'q') { rl.close(); process.exit(0); }
    if (ans === 's') {
      // selecting "here": return parent placement (the current list's parent)
      const parentPlacementId = stack.length ? stack[stack.length - 1].node.placementId : null;
      rl.close();
      return parentPlacementId;
    }
    if (ans === 'b') {
      if (stack.length) {
        const popped = stack.pop();
        currentNodes = stack.length ? stack[stack.length - 1].node.children : roots;
        pathNames = pathNames.slice(0, -1);
      } else {
        console.log('(already at root)');
      }
      continue;
    }
    const idx = parseInt(ans, 10);
    if (!Number.isFinite(idx) || idx < 1 || idx > currentNodes.length) {
      console.log('Invalid choice.');
      continue;
    }
    const chosen = currentNodes[idx - 1];
    stack.push({ node: chosen });
    pathNames.push(chosen.name);
    currentNodes = chosen.children;
  }
}

// ensure TagPlacement(tagId under parentPlacementId) exists
async function ensurePlacement(tagId, parentPlacementId) {
  const existing = await prisma.tagPlacement.findFirst({
    where: { tagId, parentPlacementId: parentPlacementId ?? null },
    select: { id: true },
  });
  if (existing) return existing.id;
  const created = await prisma.tagPlacement.create({
    data: { tagId, parentPlacementId: parentPlacementId ?? null },
    select: { id: true },
  });
  return created.id;
}

// rebuild PlacementClosure (BFS from every node)
async function rebuildPlacementClosureAll() {
  await prisma.placementClosure.deleteMany({});
  const placements = await prisma.tagPlacement.findMany({
    select: { id: true, parentPlacementId: true },
  });
  if (!placements.length) return;

  // self-rows
  await prisma.placementClosure.createMany({
    data: placements.map((p) => ({
      ancestorPlacementId: p.id,
      descendantPlacementId: p.id,
      depth: 0,
    })),
    skipDuplicates: true,
  });

  const childrenByParent = new Map();
  for (const p of placements) {
    const k = p.parentPlacementId;
    if (!childrenByParent.has(k)) childrenByParent.set(k, []);
    childrenByParent.get(k).push(p.id);
  }

  const toInsert = [];
  for (const anc of placements) {
    const q = [{ id: anc.id, depth: 0 }];
    const seen = new Set([anc.id]);
    while (q.length) {
      const { id, depth } = q.shift();
      const kids = childrenByParent.get(id) || [];
      for (const ch of kids) {
        if (!seen.has(ch)) {
          seen.add(ch);
          toInsert.push({
            ancestorPlacementId: anc.id,
            descendantPlacementId: ch,
            depth: depth + 1,
          });
          q.push({ id: ch, depth: depth + 1 });
        }
      }
    }
  }
  if (toInsert.length) {
    // chunk to avoid giant single payloads
    const CHUNK = 1000;
    for (let i = 0; i < toInsert.length; i += CHUNK) {
      await prisma.placementClosure.createMany({
        data: toInsert.slice(i, i + CHUNK),
        skipDuplicates: true,
      });
    }
  }
}

// ───────────────────────────────────────────────────────────────────────────────
// Import logic
// ───────────────────────────────────────────────────────────────────────────────
function sanitizeSerial(serial) {
  if (!serial || typeof serial !== 'string') return null;
  const s = serial.trim();
  if (!s.includes('-')) return null; // rule: must contain dash
  return s;
}

async function importFromJson(file, parentPlacementId) {
  const records = readJsonArray(file);

  let createdTags = 0;
  let updatedDesc = 0;
  let updatedPhoto = 0;
  let createdPlacements = 0;
  let skippedNoDash = 0;

  let i = 0;
  for (const rec of records) {
    i++;
    const title = (rec.title || '').trim();
    const serial = sanitizeSerial(rec.serial);
    const boxartUrl = (rec.boxartUrl || '').trim();

    if (!serial) {
      skippedNoDash++;
      continue;
    }

    let tag = await prisma.tag.findUnique({ where: { name: serial } });
    if (!tag) {
      if (DRY_RUN) {
        createdTags++;
      } else {
        tag = await prisma.tag.create({
          data: {
            name: serial,
            description: title || null,
            photoUrl: boxartUrl || null,
          },
        });
        createdTags++;
      }
    } else {
      const patch = {};
      if (!tag.description && title) { patch.description = title; updatedDesc++; }
      if ((FORCE_PHOTO && boxartUrl) || (!tag.photoUrl && boxartUrl)) { patch.photoUrl = boxartUrl; updatedPhoto++; }
      if (!DRY_RUN && Object.keys(patch).length) {
        tag = await prisma.tag.update({ where: { id: tag.id }, data: patch });
      }
    }

    if (!DRY_RUN) {
      const existed = await prisma.tagPlacement.findFirst({
        where: { tagId: tag.id, parentPlacementId: parentPlacementId ?? null },
        select: { id: true },
      });
      if (!existed) {
        await ensurePlacement(tag.id, parentPlacementId);
        createdPlacements++;
      }
    } else {
      createdPlacements++;
    }

    if (i % 100 === 0) {
      console.log(`… processed ${i}/${records.length}`);
    }
  }

  return { createdTags, updatedDesc, updatedPhoto, createdPlacements, skippedNoDash, total: records.length };
}

// ───────────────────────────────────────────────────────────────────────────────
// Main
// ───────────────────────────────────────────────────────────────────────────────
(async function main() {
  try {
    const parentPlacementId = PARENT_PLACEMENT || await pickPlacementInteractively();

    console.log('\n--- Import starting ---');
    console.log('JSON:', path.resolve(JSON_PATH));
    console.log('Parent placement:', parentPlacementId ?? '(root)');
    console.log('Dry run:', DRY_RUN ? 'YES' : 'NO');
    console.log('Force photo overwrite:', FORCE_PHOTO ? 'YES' : 'NO');

    const stats = await importFromJson(JSON_PATH, parentPlacementId);

    console.log('\nStats:');
    console.log(`  Total records:           ${stats.total}`);
    console.log(`  Skipped (no dash):       ${stats.skippedNoDash}`);
    console.log(`  Created tags:            ${stats.createdTags}`);
    console.log(`  Updated descriptions:    ${stats.updatedDesc}`);
    console.log(`  Updated photoUrl:        ${stats.updatedPhoto}`);
    console.log(`  Created placements:      ${stats.createdPlacements}`);

    if (!DRY_RUN) {
      console.log('\nRebuilding PlacementClosure…');
      await rebuildPlacementClosureAll();
    }

    console.log('\n✅ Done.');
  } catch (e) {
    console.error('❌', e);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
})();

```

---

## src/scripts/games/scrape-libretro.mjs

```js
#!/usr/bin/env node
/**
 * Crawl Libretro Database for a given platform and save a JSON catalog:
 *   - title, region, serial, detailUrl, boxartUrl
 *
 * Example:
 *   node scripts/games/scrape-libretro.mjs --platform "Nintendo - Game Boy"
 */

import fs from "fs/promises";
import path from "path";

const DB_BASE = "https://db.libretro.com";
const THUMB_BASE = "https://thumbnails.libretro.com";
const OUTPUT_DIR = path.join("data", "games", "libretro");
const DEFAULT_DELAY_MS = Number(process.env.LIBRETRO_SCRAPE_DELAY_MS || 150);

// ---------------- CLI ----------------
function parseArgs(argv) {
  const args = { platform: null, out: null };
  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];
    if (a === "--platform" || a === "-p") args.platform = argv[++i];
    else if (a === "--out" || a === "-o") args.out = argv[++i];
    else if (a === "--help" || a === "-h") {
      console.log(`Usage:
  node scripts/games/scrape-libretro.mjs --platform "Nintendo - Game Boy" [--out custom.json]

Env:
  LIBRETRO_SCRAPE_DELAY_MS  throttle between requests (default ${DEFAULT_DELAY_MS}ms)
`);
      process.exit(0);
    }
  }
  if (!args.platform) {
    console.error('Missing --platform (e.g., "Nintendo - Game Boy")');
    process.exit(1);
  }
  return args;
}

// ------------- Helpers ---------------
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

function encodePath(p) {
  // encode each path segment (space -> %20 etc.), keep slashes
  return p.split("/").map((seg) => encodeURIComponent(seg)).join("/");
}
function platformIndexUrl(platform, pageIndex) {
  return `${DB_BASE}/${encodePath(platform)}/index-${pageIndex}.html`;
}
function absoluteUrl(href, platform) {
  if (/^https?:\/\//i.test(href)) return href;
  let rel = href.replace(/^\//, "");

  // If rel already includes the platform segment (raw or encoded), don't prepend it again.
  const platRaw = `${platform}/`;
  const platEnc = `${encodePath(platform)}/`;
  if (rel.startsWith(platRaw) || rel.startsWith(platEnc)) {
    const encodedRel = /%[0-9A-Fa-f]{2}/.test(rel) ? rel : encodePath(rel);
    return `${DB_BASE}/${encodedRel}`;
  }

  const encodedRel = /%[0-9A-Fa-f]{2}/.test(rel) ? rel : encodePath(rel);
  return `${DB_BASE}/${encodePath(platform)}/${encodedRel}`;
}

function sanitizeForBoxartName(name) {
  // libretro-thumbnails rule: replace &*/:`<>?\|" with "_"
  return name.replace(/[&*\/:`<>?\\|"]/g, "_");
}
function boxartUrl(platform, displayName) {
  const file = sanitizeForBoxartName(displayName) + ".png";
  return `${THUMB_BASE}/${encodePath(platform)}/Named_Boxarts/${encodePath(file)}`;
}
function matchAll(regex, str) {
  const out = [];
  let m;
  while ((m = regex.exec(str))) out.push(m);
  return out;
}
function extractTitleFromDetail(html, fallbackFromUrl) {
  const m = html.match(/<h1[^>]*>\s*([^<]+?)\s*<\/h1>/i);
  if (m && m[1]) return decodeHtml(m[1].trim());
  if (fallbackFromUrl) {
    const seg = fallbackFromUrl.replace(/\.html?$/i, "").replace(/_/g, " ");
    try { return decodeURIComponent(seg); } catch { return seg; }
  }
  return null;
}
function decodeHtml(s) {
  return s
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">");
}
function extractRegionFromTitle(title) {
  const m = title && title.match(/\(([^)]+)\)\s*$/);
  return m ? m[1] : null;
}

// Robust serial extraction
function extractSerial(html) {
  // A: simple text (works when no tags in between)
  let m = html.match(/Serial:\s*([A-Za-z0-9][A-Za-z0-9._\-\/]+)\b/i);
  if (m) return m[1];

  // B: value appears after closing tag following "Serial"
  // e.g., <strong>Serial</strong>: <span>DMG-XXXX-YYY</span>
  m = html.match(/>Serial<\/[^>]*>[^<]*:\s*<\/?[^>]*>\s*([A-Za-z0-9][A-Za-z0-9._\-\/]+)/i);
  if (m) return m[1];

  // C: generic — find "Serial" label then scan the next ~120 chars for a token
  const pos = html.search(/Serial\b/i);
  if (pos !== -1) {
    const tail = html.slice(pos, pos + 200);
    const m2 = tail.match(/Serial[^<:]*:?[^A-Za-z0-9._\-\/]{0,10}([A-Za-z0-9][A-Za-z0-9._\-\/]+)/i);
    if (m2) return m2[1];
  }

  // D: strip tags and retry on plaintext
  const plain = html.replace(/<[^>]+>/g, " ");
  m = plain.match(/Serial:\s*([A-Za-z0-9][A-Za-z0-9._\-\/]+)\b/i);
  if (m) return m[1];

  return null;
}

// -------------- Fetch ----------------
async function get(url) {
  const res = await fetch(url, { headers: { "User-Agent": "dash-scraper/1.0" } });
  if (!res.ok) throw new Error(`GET ${url} → ${res.status}`);
  return res.text();
}

async function crawlIndex(platform) {
  const links = [];
  let page = 0;
  while (true) {
    const url = platformIndexUrl(platform, page);
    let html;
    try {
      html = await get(url);
    } catch (e) {
      if (page === 0) throw e;
      break; // end of pages
    }

    // "See details" anchors; href may be just "<title>.html" OR "<platform>/<title>.html"
    const pageLinks = matchAll(/<a\s+href="([^"]+?\.html)".*?>\s*See details\s*<\/a>/gi, html)
      .map((m) => m[1]); // keep href as-is

    if (!pageLinks.length) break;
    links.push(...pageLinks);
    page++;
    await sleep(DEFAULT_DELAY_MS);
  }
  return links;
}

async function scrapeDetail(platform, href) {
  const url = absoluteUrl(href, platform);
  const html = await get(url);

  // Serial (robust)
  const serial = extractSerial(html);

  // Title (prefer <h1>, fallback to file name)
  const fileName = href.split("/").pop() || "";
  const displayTitle = extractTitleFromDetail(html, fileName) || fileName.replace(/\.html?$/i, "");
  const region = extractRegionFromTitle(displayTitle);

  return {
    platform,
    title: displayTitle,
    region,
    serial,
    detailUrl: url,
    boxartUrl: boxartUrl(platform, displayTitle),
  };
}

// --------------- Main ----------------
async function main() {
  const { platform, out } = parseArgs(process.argv);

  console.log(`[libretro] Crawling platform: ${platform}`);
  const detailHrefs = await crawlIndex(platform);
  console.log(`[libretro] Found ${detailHrefs.length} detail pages`);

  const outRecords = [];
  let i = 0;
  for (const href of detailHrefs) {
    i++;
    try {
      const rec = await scrapeDetail(platform, href);
      outRecords.push(rec);
      if (i % 25 === 0) console.log(`  … ${i}/${detailHrefs.length}`);
    } catch (e) {
      console.warn(`  ! Failed on ${href}: ${e.message}`);
    }
    await sleep(DEFAULT_DELAY_MS);
  }

  await fs.mkdir(OUTPUT_DIR, { recursive: true });
  const outPath = out ? out : path.join(OUTPUT_DIR, `${platform}.json`);
  await fs.writeFile(outPath, JSON.stringify(outRecords, null, 2), "utf8");
  console.log(`[libretro] Wrote ${outRecords.length} records → ${outPath}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

```

---

## src/scripts/generate-raw-index.mjs

```js
#!/usr/bin/env node
/**
 * Generate docs/ai-index.md listing every file in the repo
 * with clickable raw links of the form:
 *   https://raw.githubusercontent.com/gnjax/dash/refs/heads/main/{file}
 *
 * Skips typical build/output dirs and this index file itself.
 */

import fs from "fs/promises";
import path from "path";

const REPO_OWNER = "gnjax";
const REPO_NAME = "dash";
const RAW_PREFIX = `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/refs/heads/main/`;

const REPO_ROOT = process.cwd();
const OUTPUT_FILE = path.join("docs", "ai-index.md");

// Keep this list small & conservative.
const IGNORE_NAMES = new Set([
  ".git",
  "node_modules",
  ".next",
  ".turbo",
  "dist",
  "build",
  ".cache",
  ".vercel",
  ".vscode",
  ".idea",
  ".husky",
  ".githooks", // keep hook scripts out of the index
  "coverage",
  "tmp",
  "temp",
  ".DS_Store",
  ".secrets"
]);

function toPosix(p) {
  return p.replace(/\\/g, "/");
}

function encodePath(posixPath) {
  // Encode each segment so spaces and special chars become valid in a URL.
  return posixPath
    .split("/")
    .map((seg) => encodeURIComponent(seg))
    .join("/");
}

async function* walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (IGNORE_NAMES.has(entry.name)) continue;
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      yield* walk(full);
    } else {
      yield full;
    }
  }
}

async function ensureDir(p) {
  await fs.mkdir(p, { recursive: true });
}

async function main() {
  // Build list of files (relative to repo root), POSIX-style, sorted
  const files = [];
  for await (const full of walk(REPO_ROOT)) {
    const rel = path.relative(REPO_ROOT, full);
    const relPosix = toPosix(rel);

    // Skip the output file itself
    if (relPosix === toPosix(OUTPUT_FILE)) continue;

    files.push(relPosix);
  }
  files.sort((a, b) => a.localeCompare(b));

  // Group by top-level directory (or "." for files in root)
  const sections = new Map(); // key -> array of files
  for (const f of files) {
    const top = f.includes("/") ? f.split("/")[0] : ".";
    if (!sections.has(top)) sections.set(top, []);
    sections.get(top).push(f);
  }

  const now = new Date().toISOString();

  let md = "";
  md += `# Project Raw File Index\n\n`;
  md += `Generated: ${now}\n\n`;
  md += `> Click any link to open the **raw** file on GitHub.\n\n`;
  md += `Repository: \`${REPO_OWNER}/${REPO_NAME}\`\n\n`;
  md += `---\n\n`;

  // Table of contents
  md += `## Directories\n\n`;
  for (const key of Array.from(sections.keys()).sort((a, b) => {
    if (a === ".") return -1;
    if (b === ".") return 1;
    return a.localeCompare(b);
  })) {
    const label = key === "." ? "(root)" : key;
    md += `- [${label}](#${label === "(root)" ? "root" : label.replace(/[^\w-]+/g, "-").toLowerCase()})\n`;
  }
  md += `\n---\n`;

  for (const [dir, list] of Array.from(sections.entries()).sort((a, b) => {
    const [ka, kb] = [a[0], b[0]];
    if (ka === ".") return -1;
    if (kb === ".") return 1;
    return ka.localeCompare(kb);
  })) {
    const heading = dir === "." ? "root" : dir;
    md += `\n## ${dir === "." ? "(root)" : dir}\n\n`;

    for (const file of list) {
      const encoded = encodePath(file);
      const url = `${RAW_PREFIX}${encoded}`;
      md += `- [\`${file}\`](${url})\n`;
    }
  }

  await ensureDir(path.dirname(OUTPUT_FILE));
  await fs.writeFile(OUTPUT_FILE, md, "utf8");
  // eslint-disable-next-line no-console
  console.log(`Wrote ${OUTPUT_FILE} with ${files.length} files.`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

```

---

## src/scripts/migrate-tags-to-placement.ts

```ts
/* scripts/migrate-tags-to-placements.ts
   Migrates from TagRelation (DAG) to TagPlacement (branch-local tree),
   and builds PlacementClosure. Safe to re-run (idempotent).
*/
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

type Relation = { parentId: string; childId: string };
type Placement = { id: string; tagId: string; parentPlacementId: string | null };

async function main() {
  console.log('--- Migration: TagRelation -> TagPlacement ---');

  // 1) Read tags and relations
  const [tags, rels] = await Promise.all([
    prisma.tag.findMany({ select: { id: true } }),
    prisma.tagRelation.findMany({ select: { parentId: true, childId: true } }),
  ]);
  console.log(`Tags: ${tags.length}, Relations: ${rels.length}`);

  // Build adjacency + reverse adjacency
  const childrenByTag = new Map<string, string[]>();
  const parentsByTag = new Map<string, string[]>();
  for (const r of rels) {
    (childrenByTag.get(r.parentId) ?? childrenByTag.set(r.parentId, []).get(r.parentId)!).push(r.childId);
    (parentsByTag.get(r.childId) ?? parentsByTag.set(r.childId, []).get(r.childId)!).push(r.parentId);
  }

  // 2) Ensure root placements for tags with no parents OR isolated tags
  const tagIds = new Set(tags.map(t => t.id));
  const childSet = new Set(rels.map(r => r.childId));
  const parentSet = new Set(rels.map(r => r.parentId));

  const roots: string[] = [];
  for (const tid of tagIds) {
    if (!parentsByTag.has(tid)) roots.push(tid);
  }
  console.log(`Root tags detected: ${roots.length}`);

  // Helper: ensure placement exists under given parentPlacementId
  async function ensurePlacement(tagId: string, parentPlacementId: string | null): Promise<Placement> {
    const existing = await prisma.tagPlacement.findFirst({
      where: { tagId, parentPlacementId },
      select: { id: true, tagId: true, parentPlacementId: true },
    });
    if (existing) return existing as Placement;

    const created = await prisma.tagPlacement.create({
      data: { tagId, parentPlacementId },
      select: { id: true, tagId: true, parentPlacementId: true },
    });
    return created as Placement;
  }

  // Create root placements
  const rootPlacements: Placement[] = [];
  for (const rootTagId of roots) {
    const p = await ensurePlacement(rootTagId, null);
    rootPlacements.push(p);
  }
  console.log(`Root placements created/verified: ${rootPlacements.length}`);

  // 3) Expand placements down the DAG: for each placement of a parent tag,
  //    create a child placement per TagRelation edge (parentTag -> childTag) under that *placement*.
  // We'll BFS over placements.
  const queue: Placement[] = [...rootPlacements];
  let createdCount = 0;

  // Build quick lookup for children
  function getChildren(tagId: string): string[] {
    return childrenByTag.get(tagId) ?? [];
  }

  while (queue.length) {
    const p = queue.shift()!;
    const parentTagId = p.tagId;
    const childTagIds = getChildren(parentTagId);
    if (childTagIds.length === 0) continue;

    for (const childTagId of childTagIds) {
      const childPlacement = await ensurePlacement(childTagId, p.id);
      // If it was newly created in this run, we have no way to know except by trying to find it first.
      // We still push to queue so deeper descendants get created.
      queue.push(childPlacement);
      createdCount++;
    }
  }
  console.log(`Placement expansion completed. (Created/verified edges: ${createdCount})`);

  // 4) Rebuild PlacementClosure from TagPlacement parent links
  console.log('Rebuilding PlacementClosure…');
  await prisma.placementClosure.deleteMany({});

  const allPlacements = await prisma.tagPlacement.findMany({
    select: { id: true, parentPlacementId: true },
  });

  // Self links
  if (allPlacements.length) {
    await prisma.placementClosure.createMany({
      data: allPlacements.map(p => ({
        ancestorPlacementId: p.id,
        descendantPlacementId: p.id,
        depth: 0,
      })),
      skipDuplicates: true,
    });
  }

  // Build adjacency for placements
  const childrenByPlacement = new Map<string, string[]>();
  for (const p of allPlacements) {
    if (p.parentPlacementId) {
      const arr = childrenByPlacement.get(p.parentPlacementId);
      if (arr) arr.push(p.id);
      else childrenByPlacement.set(p.parentPlacementId, [p.id]);
    }
  }

  // BFS from each placement as ancestor
  const pairs: { ancestorPlacementId: string; descendantPlacementId: string; depth: number }[] = [];
  for (const anc of allPlacements) {
    const seen = new Set<string>([anc.id]);
    const q: Array<{ id: string; depth: number }> = [{ id: anc.id, depth: 0 }];
    while (q.length) {
      const { id, depth } = q.shift()!;
      const kids = childrenByPlacement.get(id) ?? [];
      for (const kid of kids) {
        if (!seen.has(kid)) {
          seen.add(kid);
          pairs.push({
            ancestorPlacementId: anc.id,
            descendantPlacementId: kid,
            depth: depth + 1,
          });
          q.push({ id: kid, depth: depth + 1 });
        }
      }
    }
  }

  // Insert closure in manageable chunks
  const chunkSize = 5000;
  for (let i = 0; i < pairs.length; i += chunkSize) {
    const chunk = pairs.slice(i, i + chunkSize);
    await prisma.placementClosure.createMany({ data: chunk, skipDuplicates: true });
    if ((i / chunkSize) % 20 === 0) console.log(`…closure progress ${i + chunk.length}/${pairs.length}`);
  }

  console.log('PlacementClosure rebuild done.');
  console.log('--- Migration complete ---');
}

main()
  .catch((e) => {
    console.error('Migration failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

```

---

## src/scripts/pruneorphan.ts

```ts
// scripts/prune-orphan-tags.ts
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
async function main() {
  await prisma.$executeRawUnsafe(`
    DELETE FROM "Tag" t
    WHERE NOT EXISTS (SELECT 1 FROM "TagPlacement" p WHERE p."tagId" = t."id")
      AND NOT EXISTS (SELECT 1 FROM "ItemTag" it WHERE it."tagId" = t."id");
  `);
  console.log('Pruned orphan tags.');
}
main().finally(() => prisma.$disconnect());
```

---

## src/scripts/reset-tags.ts

```ts
import { prisma } from '@/lib/prisma';

async function main() {
  console.log('Wiping ItemTag, TagClosure, TagRelation, Tag …');
  await prisma.$transaction([
    prisma.itemTag.deleteMany({}),
    prisma.tagClosure.deleteMany({}),
    // If you’re on the new DAG schema, keep this; otherwise it’s harmless if the table doesn’t exist:
    prisma.$executeRawUnsafe(`DO $$ BEGIN
      IF to_regclass('public."TagRelation"') IS NOT NULL THEN
        DELETE FROM "TagRelation";
      END IF;
    END $$;`),
    prisma.tag.deleteMany({}),
  ]);
  console.log('Done.');
}

main().catch(e => {
  console.error(e);
  process.exit(1);
}).finally(async () => prisma.$disconnect());
```

---

## src/scripts/save-buyee-auth.ts

```ts
import { chromium } from 'playwright';
import path from 'path';
import fs from 'fs';

(async () => {
  const profileDir = path.resolve('/home/oulette/.proxy-profiles/buyee-profile'); // persisted session directory
  fs.mkdirSync(profileDir, { recursive: true });

  const context = await chromium.launchPersistentContext(profileDir, {
    channel: 'chrome',         // use your real Chrome, not bundled Chromium
    headless: false,           // visible window so you can log in
    viewport: { width: 1280, height: 900 },
    locale: 'en-US',
    userAgent:
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
      '(KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36',
    acceptDownloads: false,
    permissions: [],
    extraHTTPHeaders: { 'Accept-Language': 'en-US,en;q=0.9,ja;q=0.8' },
  });

  const page = await context.newPage();
  console.log('Opening Buyee. Please log in, then press ENTER here to save profile…');
  await page.goto('https://buyee.jp/', { waitUntil: 'domcontentloaded' });

  process.stdin.resume();
  process.stdin.on('data', async () => {
    await context.close(); // this writes state into the profile dir
    console.log('Profile saved at', profileDir);
    process.exit(0);
  });
})();
```

---

## src/scripts/save-fromjapan-auth.ts

```ts
import { chromium } from 'playwright';
import path from 'path';
import fs from 'fs';

(async () => {
  const profileDir = path.resolve('/home/oulette/.proxy-profiles/fj-profile');
  fs.mkdirSync(profileDir, { recursive: true });

  const ctx = await chromium.launchPersistentContext(profileDir, {
    channel: 'chrome',
    headless: false,
    viewport: { width: 1280, height: 900 },
  });
  const page = await ctx.newPage();
  console.log('Opening FromJapan. Log in, then press ENTER here to save profile…');
  await page.goto('https://www.fromjapan.co.jp/japan/en/member/history/ship/list', { waitUntil: 'domcontentloaded' });

  process.stdin.resume();
  process.stdin.on('data', async () => {
    await ctx.close();
    console.log('Saved profile at', profileDir);
    process.exit(0);
  });
})();
```

---

## src/scripts/save-zenmarket-auth.ts

```ts
import { chromium } from 'playwright';
import path from 'path';
import fs from 'fs';

(async () => {
  const profileDir = path.resolve('/home/oulette/.proxy-profiles/zm-profile');
  fs.mkdirSync(profileDir, { recursive: true });

  const ctx = await chromium.launchPersistentContext(profileDir, {
    channel: 'chrome',
    headless: false,
    viewport: { width: 1280, height: 900 },
  });
  const page = await ctx.newPage();
  console.log('Opening FromJapan. Log in, then press ENTER here to save profile…');
  await page.goto('https://zenmarket.jp', { waitUntil: 'domcontentloaded' });

  process.stdin.resume();
  process.stdin.on('data', async () => {
    await ctx.close();
    console.log('Saved profile at', profileDir);
    process.exit(0);
  });
})();
```
