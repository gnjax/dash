# Codebase Summary

> Generated: 2025-09-24T22:07:58.665Z
> Commit: 76cfba936e6a728c8856ea7253b1913c2d513c91
> Date: 2025-09-25 00:03:59 +0200
> Remote: git@github.com:gnjax/dash.git

This file concatenates important text/code files in the repo so a single raw URL can be shared.

---


---

## next.config.ts

```ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

```

---

## postcss.config.mjs

```js
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

```

---

## prisma/migrations/migration_lock.toml

```toml
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

```

---

## prisma/schema.prisma

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model FxRate {
  date     DateTime
  base     String
  quote    String
  rate     Decimal    @db.Decimal(20, 10)
  source   String     @default("frankfurter")
  fetchedAt DateTime  @default(now())

  @@id([date, base, quote])
  @@index([base, quote])
}

model ListingImageCache {
  listingId String   @id
  source    String?
  url       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// =====================
/// NEW INVENTORY MODELS
/// =====================

enum InventoryOriginType {
  Scraped
  Manual
}

enum InventoryCondition {
  Loose
  Boxed
  CIB
  NIB
}

model InventoryItem {
  id            String               @id @default(uuid())
  name          String
  originType    InventoryOriginType
  scrapedItemId String?
  manualLineId  String?
  fillEntryId   String?
  ordinal       Int?
  createdAt     DateTime             @default(now())

  condition     InventoryCondition   @default(Loose)

  tags          InventoryItemTag[]

  @@index([scrapedItemId])
  @@index([manualLineId])
  @@index([fillEntryId])
  @@unique([fillEntryId, ordinal])
}

model InventoryItemTag {
  itemId String
  tagId  String
  placementId String?

  item   InventoryItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  tag    Tag           @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([itemId, tagId])
  @@index([tagId])
}

/// =====================
/// MANUAL PURCHASE INPUT
/// =====================

model ManualPurchase {
  id                        String   @id @default(uuid())
  currency                  String   @default("JPY")
  intlShippingTotalYen      Decimal  @default(0) @db.Decimal(12, 2)
  domesticShippingTotalYen  Decimal  @default(0) @db.Decimal(12, 2)
  customsTotalYen           Decimal  @default(0) @db.Decimal(12, 2)
  subtotalYen               Decimal? @db.Decimal(12, 2)
  notes                     String?
  createdAt                 DateTime @default(now())

  lines                     ManualLine[]
}

model ManualLine {
  id               String   @id @default(uuid())
  manualPurchaseId String
  title            String
  priceYen         Decimal  @db.Decimal(12, 2)

  purchase         ManualPurchase @relation(fields: [manualPurchaseId], references: [id], onDelete: Cascade)

  @@index([manualPurchaseId])
}

/// =====================
/// FILL SESSION + INPUTS
/// =====================

enum FillSourceType {
  ScrapedPackage
  Manual
}

model InventoryFillSession {
  id               String         @id @default(uuid())
  sourceType       FillSourceType
  scrapedPackageId String?
  manualPurchaseId String?
  customsTotalYen  Decimal        @default(0) @db.Decimal(12, 2)
  createdAt        DateTime       @default(now())
  finalizedAt      DateTime?

  sourceItems      InventoryFillSourceItem[]
  entries          InventoryFillEntry[]

  @@index([scrapedPackageId])
  @@index([manualPurchaseId])
}

model InventoryFillSourceItem {
  id            String   @id @default(uuid())
  sessionId     String
  scrapedItemId String?
  manualLineId  String?

  shippingWeightPpm Int  @default(0)

  session       InventoryFillSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  entries       InventoryFillEntry[]

  @@index([sessionId])
  @@index([scrapedItemId])
  @@index([manualLineId])
}

model InventoryFillEntry {
  id                String   @id @default(uuid())
  sessionId         String
  sourceItemId      String
  nameOverride      String?
  quantity          Int      @default(1)

  priceWeightPpm    Int      @default(0)
  shippingWeightPpm Int      @default(0)

  // NEW: condition chosen at fill-time, copied to InventoryItem(s)
  condition         InventoryCondition @default(Loose)

  entryTags         InventoryFillEntryTag[]

  session           InventoryFillSession    @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sourceItem        InventoryFillSourceItem @relation(fields: [sourceItemId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([sourceItemId])
}

model InventoryFillEntryTag {
  entryId String
  tagId   String
  placementId String?

  entry   InventoryFillEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  tag     Tag                @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([entryId, tagId])
  @@index([tagId])
}

model Tag {
  id          String  @id @default(uuid())
  name        String
  description String?

  placements      TagPlacement[]
  itemTags        InventoryItemTag[]
  fillEntryTags   InventoryFillEntryTag[]

  @@unique([name])
  @@index([name])
}

model TagPlacement {
  id                String  @id @default(uuid())
  tagId             String
  parentPlacementId String?

  tag      Tag            @relation(fields: [tagId], references: [id], onDelete: Restrict)
  parent   TagPlacement?  @relation("TP_Children", fields: [parentPlacementId], references: [id])
  children TagPlacement[] @relation("TP_Children")

  asAncestor   PlacementClosure[] @relation("PC_Ancestor")
  asDescendant PlacementClosure[] @relation("PC_Descendant")

  @@unique([parentPlacementId, tagId])
  @@index([tagId])
}

model PlacementClosure {
  ancestorPlacementId   String
  descendantPlacementId String
  depth                 Int

  ancestor   TagPlacement @relation("PC_Ancestor", fields: [ancestorPlacementId], references: [id], onDelete: Cascade)
  descendant TagPlacement @relation("PC_Descendant", fields: [descendantPlacementId], references: [id], onDelete: Cascade)

  @@id([ancestorPlacementId, descendantPlacementId])
  @@index([descendantPlacementId, depth])
  @@index([ancestorPlacementId, depth])
}

enum PackageStatus {
  Todo
  Processed
  Blacklist
}

model ScrapedPackage {
  id      String @id @default(uuid())
  source  String @default("buyee")
  pageUrl String

  dateShipped        DateTime?
  packageNumber      String    @unique
  intlTrackingNumber String?
  intlTrackingUrl    String?

  internationalShippingFeeYen Decimal? @db.Decimal(12, 2)
  domesticShippingFeeYen      Decimal? @db.Decimal(12, 2)

  raw         Json?
  firstSeenAt DateTime @default(now())
  lastSeenAt  DateTime @default(now())

  status PackageStatus @default(Todo)

  items ScrapedItem[]

  @@index([dateShipped])
  @@index([intlTrackingNumber])
}

model ScrapedItem {
  id               String   @id @default(uuid())
  scrapedPackageId String
  orderNumber      String?
  titleJa          String?
  titleEn          String?
  itemUrl          String?
  listingId        String?
  priceYen         Decimal? @db.Decimal(12, 2)

  scrapedPackage ScrapedPackage @relation(fields: [scrapedPackageId], references: [id], onDelete: Cascade)

  @@index([scrapedPackageId])
  @@index([listingId])
}

```

---

## prisma/seed.ts

```ts
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();
async function main() {
  await prisma.category.createMany({
    data: ["Video game","Arcade"].map(name => ({ name })), skipDuplicates: true
  });
  await prisma.type.createMany({
    data: ["Console","Game","Controller","PCB"].map(name => ({ name })), skipDuplicates: true
  });
  await prisma.brand.createMany({
    data: ["Nintendo","Konami","SEGA","Sony","Taito","SNK","NEC"].map(name => ({ name })), skipDuplicates: true
  });
  await prisma.platform.createMany({
    data: ["Famicom", "Super Famicom","N64","GameBoy","GameBoy Advance", "Gamecube", "Wii", "Wii U", "DS", "3DS","PS1","PS2", "PS3", "PSP", "PSVita", "Mark3", "MegaDrive", "Saturn","Dreamcast", "GameGear", "Neo Geo", "NEC PC Engine"].map(name => ({ name })), skipDuplicates: true
  });
}
main().finally(()=>prisma.$disconnect());
```

---

## src/app/api/fill-sessions/[id]/finalize/route.ts

```ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { PPM_DENOM } from '@/lib/weights';
import { PackageStatus, Condition } from '@prisma/client'; // ✅ add Condition

export async function POST(
  _req: NextRequest,
  ctx: { params: Promise<{ id: string }> }
) {
  const { id } = await ctx.params;

  const result = await prisma.$transaction(async (db) => {
    // 1) lock session by flipping finalizedAt if null
    const setFinal = await db.inventoryFillSession.updateMany({
      where: { id, finalizedAt: null },
      data: { finalizedAt: new Date() },
    });

    if (setFinal.count === 0) {
      // already finalized → still ensure the scraped package is marked Processed
      const sess = await db.inventoryFillSession.findUnique({
        where: { id },
        select: { sourceType: true, scrapedPackageId: true },
      });
      if (sess?.sourceType === 'ScrapedPackage' && sess.scrapedPackageId) {
        await db.scrapedPackage.update({
          where: { id: sess.scrapedPackageId },
          data: { status: PackageStatus.Processed },
        });
      }
      return { created: 0, alreadyFinalized: true };
    }

    const session = await db.inventoryFillSession.findUnique({
      where: { id },
      include: {
        sourceItems: { include: { entries: { include: { entryTags: true } } } },
      },
    });
    if (!session) throw new Error('Session not found after lock');

    const isScraped = session.sourceType === 'ScrapedPackage';

    // package totals
    let intlShip = 0, domShip = 0, customs = Number(session.customsTotalYen ?? 0);
    if (isScraped) {
      const pkg = await db.scrapedPackage.findUnique({ where: { id: session.scrapedPackageId! } });
      intlShip = Number(pkg?.internationalShippingFeeYen ?? 0);
      domShip = Number(pkg?.domesticShippingFeeYen ?? 0);
    } else {
      const mp = await db.manualPurchase.findUnique({ where: { id: session.manualPurchaseId! } });
      intlShip = Number(mp?.intlShippingTotalYen ?? 0);
      domShip = Number(mp?.domesticShippingTotalYen ?? 0);
    }
    const pkgShippingTotal = intlShip + domShip;

    // load source prices/titles
    const priceByKey: Record<string, number> = {};
    const titleByKey: Record<string, string> = {};
    if (isScraped) {
      const sitems = await db.scrapedItem.findMany({
        where: { scrapedPackageId: session.scrapedPackageId! },
        select: { id: true, priceYen: true, titleEn: true, titleJa: true },
      });
      for (const s of sitems) {
        priceByKey[s.id] = Number(s.priceYen ?? 0);
        titleByKey[s.id] = s.titleEn ?? s.titleJa ?? '(untitled)';
      }
    } else {
      const lines = await db.manualLine.findMany({
        where: { manualPurchaseId: session.manualPurchaseId! },
        select: { id: true, priceYen: true, title: true },
      });
      for (const l of lines) {
        priceByKey[l.id] = Number(l.priceYen ?? 0);
        titleByKey[l.id] = l.title;
      }
    }

    const pkgSubtotal = session.sourceItems.reduce((a, si) => {
      const key = si.scrapedItemId ?? si.manualLineId!;
      return a + (priceByKey[key] ?? 0);
    }, 0);

    // 2) Create items idempotently per entry using (fillEntryId, ordinal) uniqueness
    let created = 0;

    for (const si of session.sourceItems) {
      const key = si.scrapedItemId ?? si.manualLineId!;
      const sourcePrice = priceByKey[key] ?? 0;
      const sourceShip = Math.round((pkgShippingTotal * si.shippingWeightPpm) / PPM_DENOM);

      for (const e of si.entries) {
        const qty = e.quantity;
        const baseName = e.nameOverride ?? titleByKey[key] ?? '(untitled)';
        const originType = isScraped ? 'Scraped' : 'Manual';

        // Insert N items with ordinals 1..qty (skip duplicates via unique)
        const rows = Array.from({ length: qty }, (_, i) => ({
          name: baseName,
          originType: originType as any,
          scrapedItemId: si.scrapedItemId ?? null,
          manualLineId: si.manualLineId ?? null,
          fillEntryId: e.id,
          ordinal: i + 1,
          condition: (e as any).condition ?? Condition.Loose, // ✅ set condition (default Loose)
        }));

        // create items; duplicates (same fillEntryId, ordinal) are ignored
        const result = await db.inventoryItem.createMany({
          data: rows,
          skipDuplicates: true,
        });
        created += result.count; // ✅ accurate number created this run

        // fetch ids of all items for this entry (for tagging)
        const items = await db.inventoryItem.findMany({
          where: { fillEntryId: e.id },
          select: { id: true, ordinal: true },
        });

        // upsert first tag (with placement) for each item if present
        const t = e.entryTags[0];
        if (t && items.length) {
          await db.inventoryItemTag.createMany({
            data: items.map(it => ({
              itemId: it.id,
              tagId: t.tagId,
              placementId: t.placementId ?? null,
            })),
            skipDuplicates: true,
          });
        }
      }
    }

    // ✅ Mark scraped package as Processed when finalizing
    if (isScraped && session.scrapedPackageId) {
      await db.scrapedPackage.update({
        where: { id: session.scrapedPackageId },
        data: { status: PackageStatus.Processed },
      });
    }

    return { created, alreadyFinalized: false };
  });

  return NextResponse.json({ ok: true, ...result });
}

```

---

## src/app/api/fill-sessions/[id]/route.ts

```ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { PPM_DENOM } from '@/lib/weights';

function toNum(d: any) {
  if (d == null) return 0;
  if (typeof d === 'number') return d;
  if (typeof d === 'string') return Number(d);
  if (typeof d.toNumber === 'function') return d.toNumber();
  return Number(d);
}

// ===================
// GET /api/fill-sessions/:id
// ===================
export async function GET(
  _req: NextRequest,
  ctx: { params: Promise<{ id: string }> }
) {
  const { id } = await ctx.params;

  const session = await prisma.inventoryFillSession.findUnique({
    where: { id },
    include: {
      sourceItems: { include: { entries: { include: { entryTags: true } } } },
    },
  });
  if (!session) return NextResponse.json({ error: 'Session not found' }, { status: 404 });

  const isScraped = session.sourceType === 'ScrapedPackage';

  type Meta = { title: string; priceYen: number; listingId?: string | null };
  const metaByKey: Record<string, Meta> = {};

  let intlShip = 0;
  let domShip = 0;
  let fxDateISO: string | null = null;

  if (isScraped) {
    const pkg = await prisma.scrapedPackage.findUnique({
      where: { id: session.scrapedPackageId! },
      include: { items: true },
    });
    if (!pkg) return NextResponse.json({ error: 'Scraped package not found' }, { status: 404 });

    for (const it of pkg.items) {
      metaByKey[it.id] = {
        title: it.titleEn ?? it.titleJa ?? '(untitled)',
        priceYen: toNum(it.priceYen ?? 0),
        listingId: it.listingId ?? null,
      };
    }

    intlShip = toNum(pkg.internationalShippingFeeYen ?? 0);
    domShip = toNum(pkg.domesticShippingFeeYen ?? 0);
    fxDateISO = pkg.dateShipped ? pkg.dateShipped.toISOString().slice(0, 10) : null;
  } else {
    const mp = await prisma.manualPurchase.findUnique({
      where: { id: session.manualPurchaseId! },
      include: { lines: true },
    });
    if (!mp) return NextResponse.json({ error: 'Manual purchase not found' }, { status: 404 });

    for (const ln of mp.lines) {
      metaByKey[ln.id] = {
        title: ln.title ?? '(untitled)',
        priceYen: toNum(ln.priceYen ?? 0),
        listingId: null,
      };
    }

    // keeping your manual totals field names
    intlShip = toNum((mp as any).intlShippingTotalYen ?? 0);
    domShip = toNum((mp as any).domShippingTotalYen ?? 0);
  }

  return NextResponse.json({
    session: {
      id: session.id,
      sourceType: session.sourceType,
      customsTotalYen: toNum(session.customsTotalYen ?? 0),
      finalizedAt: session.finalizedAt,
    },
    packageTotals: {
      intlShip,
      domShip,
      packageShippingTotal: intlShip + domShip,
    },
    fxDateISO,
    sourceItems: session.sourceItems.map((si) => {
      const key = si.scrapedItemId ?? si.manualLineId!;
      const meta = metaByKey[key] || { title: '(missing)', priceYen: 0, listingId: null };
      return {
        id: si.id,
        scrapedItemId: si.scrapedItemId,
        manualLineId: si.manualLineId,
        listingId: meta.listingId ?? null, // ✅ keep thumbs working
        title: meta.title,
        priceYen: meta.priceYen,
        shippingWeightPpm: si.shippingWeightPpm,
        entries: si.entries.map(e => ({
          id: e.id,
          nameOverride: e.nameOverride,
          quantity: e.quantity,
          priceWeightPpm: e.priceWeightPpm,
          shippingWeightPpm: e.shippingWeightPpm,
          tagId: e.entryTags[0]?.tagId ?? null,
          tagPlacementId: e.entryTags[0]?.placementId ?? null,
          condition: e.condition, // ✅ NEW
        })),
      };
    }),
  }, { status: 200 });
}

// ===================
// PATCH /api/fill-sessions/:id
// ===================
//
// body:
// {
//   customsTotalYen: number,
//   sourceItems: [{ id, shippingWeightPpm }],
//   entriesUpsert: [{
//     id?, sourceItemId, nameOverride, quantity, priceWeightPpm, shippingWeightPpm,
//     tagId, tagPlacementId, condition
//   }]
// }
export async function PATCH(
  req: NextRequest,
  ctx: { params: Promise<{ id: string }> }
) {
  const { id } = await ctx.params;
  const body = await req.json();

  await prisma.$transaction(async (db) => {
    if (typeof body.customsTotalYen === 'number' && Number.isFinite(body.customsTotalYen)) {
      await db.inventoryFillSession.update({
        where: { id },
        data: { customsTotalYen: body.customsTotalYen },
      });
    }

    if (Array.isArray(body.sourceItems)) {
      for (const si of body.sourceItems) {
        const ppm = Math.max(0, Math.min(PPM_DENOM, (si.shippingWeightPpm | 0)));
        await db.inventoryFillSourceItem.update({
          where: { id: si.id },
          data: { shippingWeightPpm: ppm },
        });
      }
    }

    const keepIds = new Set<string>();
    if (Array.isArray(body.entriesUpsert)) {
      for (const e of body.entriesUpsert) {
        const data = {
          sessionId: id,
          sourceItemId: e.sourceItemId,
          nameOverride: e.nameOverride ?? null,
          quantity: Math.max(1, Number(e.quantity || 1)) | 0,
          priceWeightPpm: Math.max(0, Math.min(PPM_DENOM, (e.priceWeightPpm | 0))),
          shippingWeightPpm: Math.max(0, Math.min(PPM_DENOM, (e.shippingWeightPpm | 0))),
          condition: e.condition ?? 'Loose', // ✅ NEW
        } as const;

        let entryId: string;
        if (e.id) {
          entryId = String(e.id);
          await db.inventoryFillEntry.update({ where: { id: entryId }, data });
          await db.inventoryFillEntryTag.deleteMany({ where: { entryId } });
        } else {
          const created = await db.inventoryFillEntry.create({ data });
          entryId = created.id;
        }
        keepIds.add(entryId);

        if (e.tagId) {
          await db.inventoryFillEntryTag.create({
            data: {
              entryId,
              tagId: e.tagId,
              placementId: e.tagPlacementId ?? null,
            },
          });
        }
      }

      const existing = await db.inventoryFillEntry.findMany({
        where: { sessionId: id },
        select: { id: true },
      });
      const toDelete = existing.map(x => x.id).filter(dbId => !keepIds.has(dbId));
      if (toDelete.length) {
        await db.inventoryFillEntry.deleteMany({ where: { id: { in: toDelete } } });
      }
    }
  });

  return NextResponse.json({ ok: true });
}

```

---

## src/app/api/fill-sessions/by-package/route.ts

```ts
// src/app/api/fill-sessions/by-package/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const pkgId = searchParams.get('packageId') ?? searchParams.get('scrapedPackageId');
  if (!pkgId) {
    return NextResponse.json({ error: 'packageId is required' }, { status: 400 });
  }

  const sess = await prisma.inventoryFillSession.findFirst({
    where: { sourceType: 'ScrapedPackage', scrapedPackageId: pkgId },
    orderBy: { createdAt: 'desc' }, // latest one
    select: { id: true, finalizedAt: true },
  });

  if (!sess) {
    return NextResponse.json({ error: 'not_found' }, { status: 404 });
  }

  return NextResponse.json({ sessionId: sess.id, finalized: !!sess.finalizedAt });
}

```

---

## src/app/api/fill-sessions/route.ts

```ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { PPM_DENOM } from '@/lib/weights';

// POST /api/fill-sessions
// body: { sourceType: 'ScrapedPackage'|'Manual', scrapedPackageId?, manualPurchaseId?, customsTotalYen? }
export async function POST(req: NextRequest) {
  const body = await req.json();
  const { sourceType, scrapedPackageId, manualPurchaseId, customsTotalYen } = body || {};

  if (sourceType === 'ScrapedPackage') {
    if (!scrapedPackageId) return NextResponse.json({ error: 'scrapedPackageId required' }, { status: 400 });

    // ✅ Reuse existing non-finalized session
    const existing = await prisma.inventoryFillSession.findFirst({
      where: { sourceType: 'ScrapedPackage', scrapedPackageId, finalizedAt: null },
      select: { id: true },
    });
    if (existing) return NextResponse.json({ sessionId: existing.id }, { status: 200 });

    const pkg = await prisma.scrapedPackage.findUnique({
      where: { id: scrapedPackageId },
      include: { items: true },
    });
    if (!pkg) return NextResponse.json({ error: 'ScrapedPackage not found' }, { status: 404 });

    const session = await prisma.inventoryFillSession.create({
      data: {
        sourceType: 'ScrapedPackage',
        scrapedPackageId,
        customsTotalYen: customsTotalYen ?? 0,
      },
    });

    // Default shipping split proportional to price (fallback equal)
    const total = pkg.items.reduce((a, s) => a + Number(s.priceYen ?? 0), 0);
    for (const s of pkg.items) {
      let ppm = 0;
      const v = Number(s.priceYen ?? 0);
      if (total > 0) ppm = Math.round((v / total) * PPM_DENOM);
      await prisma.inventoryFillSourceItem.create({
        data: { sessionId: session.id, scrapedItemId: s.id, shippingWeightPpm: ppm },
      });
    }

    return NextResponse.json({ sessionId: session.id }, { status: 201 });
  }

  if (sourceType === 'Manual') {
    if (!manualPurchaseId) return NextResponse.json({ error: 'manualPurchaseId required' }, { status: 400 });

    // ✅ Reuse existing non-finalized session
    const existing = await prisma.inventoryFillSession.findFirst({
      where: { sourceType: 'Manual', manualPurchaseId, finalizedAt: null },
      select: { id: true },
    });
    if (existing) return NextResponse.json({ sessionId: existing.id }, { status: 200 });

    const mp = await prisma.manualPurchase.findUnique({
      where: { id: manualPurchaseId },
      include: { lines: true },
    });
    if (!mp) return NextResponse.json({ error: 'ManualPurchase not found' }, { status: 404 });

    const session = await prisma.inventoryFillSession.create({
      data: {
        sourceType: 'Manual',
        manualPurchaseId,
        customsTotalYen: customsTotalYen ?? mp.customsTotalYen,
      },
    });

    const total = mp.lines.reduce((a, s) => a + Number(s.priceYen ?? 0), 0);
    for (const line of mp.lines) {
      let ppm = 0;
      const v = Number(line.priceYen ?? 0);
      if (total > 0) ppm = Math.round((v / total) * PPM_DENOM);
      await prisma.inventoryFillSourceItem.create({
        data: { sessionId: session.id, manualLineId: line.id, shippingWeightPpm: ppm },
      });
    }

    return NextResponse.json({ sessionId: session.id }, { status: 201 });
  }

  return NextResponse.json({ error: 'Invalid sourceType' }, { status: 400 });
}

```

---

## src/app/api/fx/route.ts

```ts
// src/app/api/fx/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// Normalize "YYYY-MM-DD" -> Date at 00:00:00 UTC
function toUtcDate(d: string) {
  const [y, m, day] = d.split('-').map(Number);
  return new Date(Date.UTC(y, m - 1, day, 0, 0, 0, 0));
}

// Fetch from Frankfurter and return numeric rate JPY->EUR for a given date
async function fetchFrankfurter(dateStr: string): Promise<{ date: string; rate: number } | null> {
  // Frankfurter: https://api.frankfurter.dev/2020-01-01?from=JPY&to=EUR
  const url = `https://api.frankfurter.app/${dateStr}?from=JPY&to=EUR`;
  try {
    const r = await fetch(url, { next: { revalidate: 60 * 60 * 24 } }); // cache at edge for a day
    if (!r.ok) return null;
    const j = await r.json();
    const rate = j?.rates?.EUR;
    const date = j?.date || dateStr;
    if (typeof rate !== 'number' || !Number.isFinite(rate)) return null;
    return { date, rate };
  } catch {
    return null;
  }
}

function toNum(d: any) {
  if (d == null) return 0;
  if (typeof d === 'number') return d;
  if (typeof d === 'string') return Number(d);
  if (typeof d.toNumber === 'function') return d.toNumber();
  return Number(d);
}

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const dateParam = (searchParams.get('date') || '').slice(0, 10); // "YYYY-MM-DD"
    const base = (searchParams.get('base') || '').toUpperCase();
    const quote = (searchParams.get('quote') || '').toUpperCase();

    if (!dateParam || !/^\d{4}-\d{2}-\d{2}$/.test(dateParam)) {
      return NextResponse.json({ error: 'Invalid date' }, { status: 400 });
    }
    if (base !== 'JPY' || quote !== 'EUR') {
      // You can lift this restriction later; for now we only support JPY->EUR
      return NextResponse.json({ error: 'Only JPY->EUR supported' }, { status: 400 });
    }

    const dateUTC = toUtcDate(dateParam);

    // 1) Try DB cache for exact day
    const cached = await prisma.fxRate.findUnique({
      where: { date_base_quote: { date: dateUTC, base, quote } },
    });
    if (cached) {
      return NextResponse.json({
        base,
        quote,
        date: dateParam,
        rate: toNum(cached.rate),
        source: cached.source || 'cache',
        cached: true,
      });
    }

    // 2) Try Frankfurter (will auto-shift to nearest business day)
    const remote = await fetchFrankfurter(dateParam);
    if (remote) {
      await prisma.fxRate.upsert({
        where: { date_base_quote: { date: toUtcDate(remote.date), base, quote } },
        update: { rate: remote.rate, source: 'frankfurter' },
        create: {
          date: toUtcDate(remote.date),
          base,
          quote,
          rate: remote.rate,
          source: 'frankfurter',
        },
      });
      return NextResponse.json({
        base,
        quote,
        date: dateParam,
        rate: remote.rate,
        source: 'frankfurter',
        cached: false,
        note: remote.date !== dateParam ? `using nearest business day ${remote.date}` : undefined,
      });
    }

    // 3) Fallback: use most recent cached rate for base/quote (if any)
    const latest = await prisma.fxRate.findFirst({
      where: { base, quote },
      orderBy: { date: 'desc' },
    });
    if (latest) {
      return NextResponse.json({
        base,
        quote,
        date: dateParam,
        rate: toNum(latest.rate),
        source: latest.source || 'cache',
        cached: true,
        note: `fallback to latest cached rate from ${latest.date.toISOString().slice(0,10)}`,
      });
    }

    // 4) Emergency fallback for fully-offline dev environments
    const emergency = 0.0062; // conservative placeholder; replace if you prefer
    return NextResponse.json({
      base,
      quote,
      date: dateParam,
      rate: emergency,
      source: 'emergency-fallback',
      cached: false,
      note: 'remote FX fetch failed and no cache exists; using placeholder',
    });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Server error' }, { status: 500 });
  }
}

```

---

## src/app/api/inventory/route.ts

```ts
// src/app/api/inventory/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { PPM_DENOM } from '@/lib/weights';

function toNum(d: any) {
  if (d == null) return 0;
  if (typeof d === 'number') return d;
  if (typeof d === 'string') return Number(d);
  if (typeof (d as any).toNumber === 'function') return (d as any).toNumber();
  return Number(d);
}

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const limit = Math.max(1, Math.min(100, Number(searchParams.get('limit') ?? '50')));
  const cursor = searchParams.get('cursor') || undefined;

  // Support stacked filters: multiple ?q= values -> AND across terms
  const terms = searchParams.getAll('q').map(s => s.trim()).filter(Boolean);
  const singleQ = (searchParams.get('q') || '').trim();
  if (!terms.length && singleQ) terms.push(singleQ);

  // Helper to build a where-clause for ONE term
  async function buildWhereForTerm(q: string) {
    // Package number -> entryIds
    let entryIdsFromPackageQuery: string[] = [];
    {
      const pkgs = await prisma.scrapedPackage.findMany({
        where: { packageNumber: { contains: q, mode: 'insensitive' } },
        select: { id: true },
      });
      if (pkgs.length) {
        const sess = await prisma.inventoryFillSession.findMany({
          where: { scrapedPackageId: { in: pkgs.map(p => p.id) } },
          select: { id: true },
        });
        if (sess.length) {
          const entryIds = await prisma.inventoryFillEntry.findMany({
            where: { sessionId: { in: sess.map(s => s.id) } },
            select: { id: true },
          });
          entryIdsFromPackageQuery = entryIds.map(e => e.id);
        }
      }
    }

    // Match any segment in placement chain
    // tags (name ~ q) -> placements -> closure descendants -> InventoryItemTag.placementId
    let itemIdsFromPlacementQuery: string[] = [];
    {
      const tagHits = await prisma.tag.findMany({
        where: { name: { contains: q, mode: 'insensitive' } },
        select: { id: true },
      });
      const tagIds = tagHits.map(t => t.id);

      if (tagIds.length) {
        const ancPlacements = await prisma.tagPlacement.findMany({
          where: { tagId: { in: tagIds } },
          select: { id: true },
        });
        const ancIds = ancPlacements.map(p => p.id);

        let descIds: string[] = [];
        if (ancIds.length) {
          const closures = await prisma.placementClosure.findMany({
            where: { ancestorPlacementId: { in: ancIds } },
            select: { descendantPlacementId: true },
          });
          descIds = Array.from(new Set(closures.map(c => c.descendantPlacementId)));
        }

        const invTags = await prisma.inventoryItemTag.findMany({
          where: {
            OR: [
              { tagId: { in: tagIds } },
              ...(descIds.length ? [{ placementId: { in: descIds } }] as const : []),
            ],
          },
          select: { itemId: true },
        });
        itemIdsFromPlacementQuery = Array.from(new Set(invTags.map(it => it.itemId)));
      }
    }

    // OR group for this term; the final WHERE will AND these groups for all terms
    const clause: any = {
      OR: [
        { name: { contains: q, mode: 'insensitive' } },
        { tags: { some: { tag: { name: { contains: q, mode: 'insensitive' } } } } },
        ...(itemIdsFromPlacementQuery.length ? [{ id: { in: itemIdsFromPlacementQuery } }] : []),
        ...(entryIdsFromPackageQuery.length ? [{ fillEntryId: { in: entryIdsFromPackageQuery } }] : []),
      ],
    };
    return clause;
  }

  // Compose WHERE across terms (AND)
  let where: any = undefined;
  if (terms.length) {
    const clauses = [];
    for (const t of terms) {
      clauses.push(await buildWhereForTerm(t));
    }
    where = { AND: clauses };
  }

  // 1) Page of items
  const items = await prisma.inventoryItem.findMany({
    take: limit,
    ...(cursor ? { skip: 1, cursor: { id: cursor } } : {}),
    orderBy: { id: 'desc' },
    where,
    select: {
      id: true,
      name: true,
      ordinal: true,
      scrapedItemId: true,
      manualLineId: true,
      fillEntryId: true,
      createdAt: true,
      condition: true, // ✅ added
      tags: {
        select: {
          tag: { select: { id: true, name: true } },
          placementId: true,
        },
      },
    },
  });

  // 2) Batch lookups for allocations (same logic as before)
  const fillEntryIds = Array.from(new Set(items.map(i => i.fillEntryId).filter(Boolean) as string[]));
  const entries = fillEntryIds.length
    ? await prisma.inventoryFillEntry.findMany({
        where: { id: { in: fillEntryIds } },
        select: {
          id: true,
          quantity: true,
          priceWeightPpm: true,
          shippingWeightPpm: true,
          sourceItemId: true,
          sessionId: true,
        },
      })
    : [];
  const entriesById = new Map(entries.map(e => [e.id, e]));

  const sourceItemIds = Array.from(new Set(entries.map(e => e.sourceItemId)));
  const sourceItems = sourceItemIds.length
    ? await prisma.inventoryFillSourceItem.findMany({
        where: { id: { in: sourceItemIds } },
        select: {
          id: true,
          sessionId: true,
          shippingWeightPpm: true,
          scrapedItemId: true,
          manualLineId: true,
        },
      })
    : [];
  const sourceItemsById = new Map(sourceItems.map(s => [s.id, s]));

  const sessionIds = Array.from(new Set(entries.map(e => e.sessionId)));
  const sessions = sessionIds.length
    ? await prisma.inventoryFillSession.findMany({
        where: { id: { in: sessionIds } },
        select: {
          id: true,
          sourceType: true,
          customsTotalYen: true,
          scrapedPackageId: true,
          manualPurchaseId: true,
        },
      })
    : [];
  const sessionsById = new Map(sessions.map(s => [s.id, s]));

  const allSessSourceItems = sessionIds.length
    ? await prisma.inventoryFillSourceItem.findMany({
        where: { sessionId: { in: sessionIds } },
        select: { sessionId: true, scrapedItemId: true, manualLineId: true },
      })
    : [];
  const sessToSourceItems = new Map<
    string,
    { scrapedItemId: string | null; manualLineId: string | null }[]
  >();
  for (const si of allSessSourceItems) {
    const arr = sessToSourceItems.get(si.sessionId) ?? [];
    arr.push({ scrapedItemId: si.scrapedItemId ?? null, manualLineId: si.manualLineId ?? null });
    sessToSourceItems.set(si.sessionId, arr);
  }

  // Prices
  const scrapedIds = Array.from(new Set(allSessSourceItems.map(si => si.scrapedItemId).filter(Boolean) as string[]));
  const manualIds = Array.from(new Set(allSessSourceItems.map(si => si.manualLineId).filter(Boolean) as string[]));
  const scrapedItems = scrapedIds.length
    ? await prisma.scrapedItem.findMany({
        where: { id: { in: scrapedIds } },
        select: { id: true, priceYen: true, scrapedPackageId: true },
      })
    : [];
  const manualLines = manualIds.length
    ? await prisma.manualLine.findMany({
        where: { id: { in: manualIds } },
        select: { id: true, priceYen: true },
      })
    : [];
  const scrapedPriceById = new Map(scrapedItems.map(si => [si.id, toNum(si.priceYen)]));
  const manualPriceById = new Map(manualLines.map(ml => [ml.id, toNum(ml.priceYen)]));

  // Shipping & dates
  const scrapedPkgIds = Array.from(new Set(sessions.map(s => s.scrapedPackageId).filter(Boolean) as string[]));
  const manualPurchaseIds = Array.from(new Set(sessions.map(s => s.manualPurchaseId).filter(Boolean) as string[]));
  const scrapedPkgs = scrapedPkgIds.length
    ? await prisma.scrapedPackage.findMany({
        where: { id: { in: scrapedPkgIds } },
        select: {
          id: true,
          packageNumber: true,
          dateShipped: true,
          internationalShippingFeeYen: true,
          domesticShippingFeeYen: true,
        },
      })
    : [];
  const scrapedPkgById = new Map(scrapedPkgs.map(p => [p.id, p]));

  const manualPurchases = manualPurchaseIds.length
    ? await prisma.manualPurchase.findMany({
        where: { id: { in: manualPurchaseIds } },
        select: {
          id: true,
          datePurchased: true,
          intlShippingTotalYen: true,
          domesticShippingTotalYen: true,
        },
      })
    : [];
  const manualById = new Map(manualPurchases.map(m => [m.id, m]));

  // Build placement labels (Root > ... > Leaf) with leaf last
  const placementIds = Array.from(
    new Set(items.flatMap(i => i.tags?.map(t => t.placementId).filter(Boolean) as string[] ?? [])),
  );
  const placementLabels = new Map<string, string>();
  if (placementIds.length) {
    const closures = await prisma.placementClosure.findMany({
      where: { descendantPlacementId: { in: placementIds } },
      select: {
        descendantPlacementId: true,
        depth: true,
        ancestor: { select: { tag: { select: { name: true } } } },
      },
    });

    const byDesc = new Map<string, { depth: number; name: string }[]>();
    for (const c of closures) {
      const nm = (c as any).ancestor.tag?.name ?? '';
      if (!nm) continue;
      const arr = byDesc.get(c.descendantPlacementId) ?? [];
      arr.push({ depth: c.depth, name: nm });
      byDesc.set(c.descendantPlacementId, arr);
    }
    for (const [desc, arr] of byDesc) {
      // depth: 0=leaf, >0 ancestors. For root → ... → leaf order, sort DESC by depth.
      arr.sort((a, b) => b.depth - a.depth);
      placementLabels.set(desc, arr.map(x => x.name).join(' > '));
    }
  }

  // 3) Rows
  const rows: any[] = [];
  for (const it of items) {
    const entry = it.fillEntryId ? entriesById.get(it.fillEntryId) : null;

    // even if no entry (should be rare), still render tags & minimal fields
    if (!entry) {
      const tagParts = (it.tags || []).map(tp => {
        const t = tp.tag?.name ?? '';
        const pname = tp.placementId ? (placementLabels.get(tp.placementId) || '') : '';
        return pname ? `${t} (${pname})` : t;
      });
      rows.push({
        id: it.id,
        name: it.name,
        condition: it.condition, // ✅ added
        tagChain: tagParts.join(' • '),
        fxDateISO: null,
        packageNumber: null,
        purchaseDateISO: null,
        jpy: { basePerUnit: 0, shipPerUnit: 0, customsPerUnit: 0, totalPerUnit: 0 },
      });
      continue;
    }

    const qty = Math.max(1, toNum(entry.quantity));
    const entryPricePPM = toNum(entry.priceWeightPpm);
    const entryShipPPM = toNum(entry.shippingWeightPpm);

    const src = sourceItemsById.get(entry.sourceItemId)!;
    const sourceItemShipPPM = toNum(src.shippingWeightPpm);

    // Source price (JPY)
    let sourcePriceYen = 0;
    if (src.scrapedItemId) sourcePriceYen = scrapedPriceById.get(src.scrapedItemId) ?? 0;
    else if (src.manualLineId) sourcePriceYen = manualPriceById.get(src.manualLineId) ?? 0;

    // Package subtotal (JPY)
    let packageSubtotal = 0;
    for (const s of (sessToSourceItems.get(entry.sessionId) ?? [])) {
      if (s.scrapedItemId) packageSubtotal += scrapedPriceById.get(s.scrapedItemId) ?? 0;
      else if (s.manualLineId) packageSubtotal += manualPriceById.get(s.manualLineId) ?? 0;
    }

    // Session meta
    const sess = sessionsById.get(entry.sessionId)!;
    let pkgShipTotal = 0;
    let fxDateISO: string | null = null;
    let packageNumber: string | null = null;
    let purchaseDateISO: string | null = null;

    if (sess.sourceType === 'ScrapedPackage' && sess.scrapedPackageId) {
      const pkg = scrapedPkgById.get(sess.scrapedPackageId) || null;
      const intl = toNum(pkg?.internationalShippingFeeYen ?? 0);
      const dom = toNum(pkg?.domesticShippingFeeYen ?? 0);
      pkgShipTotal = intl + dom;
      fxDateISO = pkg?.dateShipped ? pkg.dateShipped.toISOString().slice(0, 10) : null;
      packageNumber = (pkg as any)?.packageNumber ?? null;
      purchaseDateISO = fxDateISO;
    } else if (sess.sourceType === 'Manual' && sess.manualPurchaseId) {
      const mp = manualById.get(sess.manualPurchaseId) || null;
      const intl = toNum((mp as any)?.intlShippingTotalYen ?? 0);
      const dom = toNum((mp as any)?.domesticShippingTotalYen ?? 0);
      pkgShipTotal = intl + dom;
      purchaseDateISO = (mp as any)?.datePurchased
        ? new Date((mp as any).datePurchased).toISOString().slice(0, 10)
        : null;
      fxDateISO = purchaseDateISO;
    }

    // Allocations (same as filler)
    const baseAllocJPY = Math.round(sourcePriceYen * (entryPricePPM / PPM_DENOM));
    const sourceShipAllocJPY = Math.round(pkgShipTotal * (sourceItemShipPPM / PPM_DENOM));
    const entryShipAllocJPY = Math.round(sourceShipAllocJPY * (entryShipPPM / PPM_DENOM));

    let entryCustomsJPY = 0;
    if (packageSubtotal > 0) {
      const customsTotal = toNum(sess.customsTotalYen ?? 0);
      const sourceShare = sourcePriceYen / packageSubtotal;
      entryCustomsJPY = Math.round(customsTotal * sourceShare * (entryPricePPM / PPM_DENOM));
    }

    const basePerUnitJPY = Math.round(baseAllocJPY / qty);
    const shipPerUnitJPY = Math.round(entryShipAllocJPY / qty);
    const customsPerUnitJPY = Math.round(entryCustomsJPY / qty);
    const totalPerUnitJPY = basePerUnitJPY + shipPerUnitJPY + customsPerUnitJPY;

    const tagParts = (it.tags || []).map(tp => {
      const t = tp.tag?.name ?? '';
      const pname = tp.placementId ? (placementLabels.get(tp.placementId) || '') : '';
      return pname ? `${t} (${pname})` : t;
    });

    rows.push({
      id: it.id,
      name: it.name,
      condition: it.condition, // ✅ added
      tagChain: tagParts.join(' • '),
      fxDateISO,
      packageNumber,
      purchaseDateISO,
      jpy: {
        basePerUnit: basePerUnitJPY,
        shipPerUnit: shipPerUnitJPY,
        customsPerUnit: customsPerUnitJPY,
        totalPerUnit: totalPerUnitJPY,
      },
    });
  }

  const nextCursor = items.length === limit ? items[items.length - 1].id : null;
  return NextResponse.json({ items: rows, nextCursor });
}

```

---

## src/app/api/manual-purchase/route.ts

```ts
// src/app/api/manual-purchases/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// POST: { currency?, intlShippingTotalYen?, domesticShippingTotalYen?, customsTotalYen?, subtotalYen?, notes?, lines: [{ title, priceYen }] }
export async function POST(req: NextRequest) {
  const b = await req.json();
  if (!Array.isArray(b.lines) || b.lines.length === 0) {
    return NextResponse.json({ error: 'lines required' }, { status: 400 });
  }
  const mp = await prisma.manualPurchase.create({
    data: {
      currency: b.currency ?? 'JPY',
      intlShippingTotalYen: b.intlShippingTotalYen ?? 0,
      domesticShippingTotalYen: b.domesticShippingTotalYen ?? 0,
      customsTotalYen: b.customsTotalYen ?? 0,
      subtotalYen: b.subtotalYen ?? null,
      notes: b.notes ?? null,
      lines: {
        create: b.lines.map((l: any) => ({ title: l.title, priceYen: l.priceYen })),
      },
    },
  });

  return NextResponse.json({ manualPurchaseId: mp.id }, { status: 201 });
}

```

---

## src/app/api/profile/refresh/confirm/route.ts

```ts
// src/app/api/profile/refresh/confirm/route.ts
import { NextResponse } from 'next/server';
import { confirmRefresh, getRunning } from '@/lib/refresh-runner';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const body = await req.json().catch(() => ({}));
  const source = String(body?.source || '').toLowerCase();
  if (!['buyee','zenmarket','fromjapan'].includes(source)) {
    return NextResponse.json({ ok: false, error: 'invalid_source' }, { status: 400 });
  }
  if (!getRunning(source)) {
    return NextResponse.json({ ok: false, error: 'no_process' }, { status: 409 });
  }
  const out = await confirmRefresh(source);
  return NextResponse.json(out);
}

```

---

## src/app/api/profile/refresh/start/route.ts

```ts
// src/app/api/profile/refresh/start/route.ts
import { NextResponse } from 'next/server';
import { startRefresh, getRunning } from '@/lib/refresh-runner';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const body = await req.json().catch(() => ({}));
  const source = String(body?.source || '').toLowerCase();
  if (!['buyee','zenmarket','fromjapan'].includes(source)) {
    return NextResponse.json({ ok: false, error: 'invalid_source' }, { status: 400 });
  }
  if (getRunning(source)) {
    return NextResponse.json({ ok: true, alreadyRunning: true });
  }
  const { pid } = startRefresh(source);
  // tiny delay so the singleton map is definitely populated before a fast Confirm
  await new Promise(r => setTimeout(r, 100));
  return NextResponse.json({ ok: true, pid });
}

```

---

## src/app/api/scrape/buyee-crawl/route.ts

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { scrapeBuyeeShippedList } from '@/scrapers/buyee';
import { translateJaToEn } from '@/lib/translate';

function buildPageUrl(page: number): string {
  // fixed path; vary ?page=
  return `https://buyee.jp/mybaggages/shipped/1?term=0&page=${page}`;
}

export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const { startPage = 1, maxPages = 10 } = await req.json().catch(() => ({}));
  let pagesCrawled = 0, inserted = 0, updated = 0, stopReason = '';

  try {
    for (let pageNum = Number(startPage); pageNum < Number(startPage) + Number(maxPages); pageNum++) {
      const url = buildPageUrl(pageNum);
      const { packages } = await scrapeBuyeeShippedList(url);
      pagesCrawled++;

      // keep only entries with a packageNumber (should be all)
      const pagePkgs = packages.filter(p => p.packageNumber);
      if (!pagePkgs.length) { stopReason = 'empty_or_invalid_page'; break; }

      // === STOP CONDITION ===
      // Only stop if:
      //  (1) page has 10 entries
      //  (2) every entry has dateShipped (i.e., shipped)
      //  (3) every entry is already in DB (seen)
      const isFullPage = pagePkgs.length === 10;
      const allHaveDate = pagePkgs.every(p => !!p.dateShipped);
      let allSeen = false;
      if (isFullPage && allHaveDate) {
        const keys = pagePkgs.map(p => p.packageNumber!);
        const already = await prisma.scrapedPackage.findMany({
          where: { packageNumber: { in: keys } },
          select: { packageNumber: true, dateShipped: true },
        });
        allSeen = already.length === pagePkgs.length;
        const allSeenWithDate = allSeen && already.every(row => row.dateShipped != null);
        if (allSeenWithDate) { stopReason = 'all_10_shipped_on_page_already_seen'; break; }
      }
      // ======================

      // Upsert every entry (shipped or not)
      for (const p of pagePkgs) {
        const ja = (p.items || []).map(i => i.title || '');
        const en = await translateJaToEn(ja);

        const existing = await prisma.scrapedPackage.findUnique({
          where: { packageNumber: p.packageNumber! },
          select: { id: true, packageNumber: true }
        });

        const up = await prisma.scrapedPackage.upsert({
          where: { packageNumber: p.packageNumber! },
          update: {
            pageUrl: url,
            dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
            intlTrackingNumber: p.intlTrackingNumber || null,
            intlTrackingUrl: p.intlTrackingUrl || null,
            internationalShippingFeeYen: p.internationalShippingFeeYen ?? null,
            domesticShippingFeeYen: p.domesticShippingFeeYen ?? null,
            raw: p,
            lastSeenAt: new Date(),
          },
          create: {
            source: 'buyee',
            pageUrl: url,
            packageNumber: p.packageNumber!, // unique
            dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
            intlTrackingNumber: p.intlTrackingNumber || null,
            intlTrackingUrl: p.intlTrackingUrl || null,
            internationalShippingFeeYen: p.internationalShippingFeeYen ?? null,
            domesticShippingFeeYen: p.domesticShippingFeeYen ?? null,
            raw: p,
          },
          select: { id: true, packageNumber: true },
        });

        // Replace items
        await prisma.scrapedItem.deleteMany({ where: { scrapedPackageId: up.id } });
        if (p.items?.length) {
          await prisma.scrapedItem.createMany({
            data: p.items.map((it, idx) => ({
              scrapedPackageId: up.id,
              orderNumber: it.orderNumber || null,
              titleJa: it.title || null,
              titleEn: en[idx] || it.title || null,
              itemUrl: it.itemUrl || null,
              listingId: it.listingId || null,
              priceYen: typeof it.priceYen === 'number' ? it.priceYen : null,
            })),
            skipDuplicates: true,
          });
        }

        if (existing) updated++; else inserted++;
      }
    }

    return NextResponse.json({ pagesCrawled, inserted, updated, stopReason }, { status: 200 });
  } catch (e: any) {
    console.error('CRAWL_ERROR', e);
    return NextResponse.json({ error: e?.message || 'crawl failed', pagesCrawled, inserted, updated }, { status: 500 });
  }
}
```

---

## src/app/api/scrape/fromjapan-crawl/route.ts

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { scrapeFromJapanShippedList } from '@/scrapers/fromjapan';
import { translateJaToEn } from '@/lib/translate';

function buildPageUrl(page: number): string {
  // FromJapan shipped history page; page param TBD later.
  // We keep the builder so it's trivial to add pagination later.
  if (page <= 1) return 'https://www.fromjapan.co.jp/japan/en/member/history/ship/list';
  return `https://www.fromjapan.co.jp/japan/en/member/history/ship/list?page=${page}`;
}

export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const { startPage = 1, maxPages = 1 } = await req.json().catch(() => ({})); // default: just page 1
  let pagesCrawled = 0, inserted = 0, updated = 0, stopReason = '';

  try {
    for (let pageNum = Number(startPage); pageNum < Number(startPage) + Number(maxPages); pageNum++) {
      const url = buildPageUrl(pageNum);
      const { packages } = await scrapeFromJapanShippedList(url);
      pagesCrawled++;

      if (!packages.length) { stopReason = 'empty_page'; break; }

      // Stop when EVERYTHING on the page is already in DB (they are all shipped pages)
      const keys = packages.map(p => p.packageNumber);
      const already = await prisma.scrapedPackage.findMany({
        where: { packageNumber: { in: keys } },
        select: { packageNumber: true },
      });
      if (already.length === packages.length) { stopReason = 'all_seen_on_page'; break; }

      for (const p of packages) {
        // Translate item titles
        const ja = (p.items || []).map(i => i.title || '');
        const en = await translateJaToEn(ja);

        const existing = await prisma.scrapedPackage.findUnique({
          where: { packageNumber: p.packageNumber },
          select: { id: true, packageNumber: true }
        });

        const up = await prisma.scrapedPackage.upsert({
          where: { packageNumber: p.packageNumber },
          update: {
            pageUrl: url,
            dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
            intlTrackingNumber: p.trackingNumbers?.[0] || null,   // single tracking per package entry
            intlTrackingUrl: null, // FJ detail URL not required here; can add later
            internationalShippingFeeYen: p.internationalShippingFeeYen ?? null,
            domesticShippingFeeYen: p.domesticShippingFeeYen ?? null,
            raw: p,
            lastSeenAt: new Date(),
          },
          create: {
            source: 'fromjapan',
            pageUrl: url,
            packageNumber: p.packageNumber, // unique (includes #1/#2 for multi-pack)
            dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
            intlTrackingNumber: p.trackingNumbers?.[0] || null,
            intlTrackingUrl: null,
            internationalShippingFeeYen: p.internationalShippingFeeYen ?? null,
            domesticShippingFeeYen: p.domesticShippingFeeYen ?? null,
            raw: p,
          },
          select: { id: true, packageNumber: true },
        });

        // Replace items for this package
        await prisma.scrapedItem.deleteMany({ where: { scrapedPackageId: up.id } });
        if (p.items?.length) {
          await prisma.scrapedItem.createMany({
            data: p.items.map((it, idx) => ({
              scrapedPackageId: up.id,
              orderNumber: it.orderNumber || null,
              titleJa: it.title || null,
              titleEn: en[idx] || it.title || null,
              itemUrl: it.itemUrl || null,
              listingId: it.listingId || null,
              priceYen: typeof it.priceYen === 'number' ? it.priceYen : null,
            })),
            skipDuplicates: true,
          });
        }

        if (existing) updated++; else inserted++;
      }
    }

    return NextResponse.json({ pagesCrawled, inserted, updated, stopReason }, { status: 200 });
  } catch (e: any) {
    console.error('FJ_CRAWL_ERROR', e);
    return NextResponse.json({ error: e?.message || 'crawl failed', pagesCrawled, inserted, updated }, { status: 500 });
  }
}
```

---

## src/app/api/scrape/route.ts

```ts
import { NextResponse } from 'next/server';
import { scrapeBuyeeShippedList } from '@/scrapers/buyee';

export const dynamic = 'force-dynamic';

export async function POST(request: Request) {
  const { url } = await request.json();
  if (!url || typeof url !== 'string') {
    return NextResponse.json({ error: 'Missing url' }, { status: 400 });
  }

  try {
    const data = await scrapeBuyeeShippedList(url);
    return NextResponse.json(data);
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Scrape failed' }, { status: 500 });
  }
}
```

---

## src/app/api/scrape/zenmarket-crawl/route.ts

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { scrapeZenMarketParcels } from '@/scrapers/zenmarket';

export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  try {
    const { pageUrl } = await req.json().catch(() => ({}));
    const url = pageUrl || 'https://zenmarket.jp/en/profile/parcel.aspx?state=5';

    const pkgs = await scrapeZenMarketParcels(url);

    let inserted = 0;
    let updated = 0;

    for (const p of pkgs) {
      const now = new Date();
      const existing = await prisma.scrapedPackage.findUnique({
        where: { packageNumber: p.packageNumber },
      });

      const payload = {
        source: 'zenmarket' as const,
        pageUrl: p.pageUrl,
        dateShipped: p.dateShipped ? new Date(p.dateShipped) : null,
        packageNumber: p.packageNumber,
        intlTrackingNumber: p.trackingNumber ?? null,
        intlTrackingUrl: p.trackingUrl ?? null,
        internationalShippingFeeYen: p.internationalShippingFeeYen ?? 0,
        domesticShippingFeeYen: p.domesticShippingFeeYen ?? 0,
        items: p.items,
        raw: p.raw,
        lastSeenAt: now,
        ...(existing ? {} : { firstSeenAt: now }),
      };

      if (existing) {
        await prisma.scrapedPackage.update({
          where: { packageNumber: p.packageNumber },
          data: payload,
        });
        updated++;
      } else {
        await prisma.scrapedPackage.create({ data: payload });
        inserted++;
      }
    }

    return NextResponse.json({
      pagesCrawled: 1,
      inserted,
      updated,
      stopReason: '',
    });
  } catch (err: any) {
    return NextResponse.json(
      { error: String(err?.message || err) || 'unknown error', pagesCrawled: 0, inserted: 0, updated: 0 },
      { status: 500 }
    );
  }
}
```

---

## src/app/api/scraped-packages/[id]/status/route.ts

```ts
// src/app/api/scraped-packages/[id]/status/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

type Status = 'Todo' | 'Processed' | 'Blacklist';

export async function POST(
  req: Request,
  ctx: { params: Promise<{ id: string }> }
) {
  const { id } = await ctx.params;
  const { status } = await req.json().catch(() => ({})) as { status?: Status };

  if (!id || !status || !['Todo','Processed','Blacklist'].includes(status)) {
    return NextResponse.json({ ok: false, error: 'invalid_input' }, { status: 400 });
  }

  try {
    const row = await prisma.scrapedPackage.update({
      where: { id },
      data: { status },
      select: { id: true, status: true },
    });
    return NextResponse.json({ ok: true, id: row.id, status: row.status });
  } catch (e:any) {
    return NextResponse.json({ ok: false, error: e?.message || 'update_failed' }, { status: 500 });
  }
}

```

---

## src/app/api/scraped-packages/route.ts

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

function toNum(d: any) {
  if (!d) return 0;
  if (typeof d === 'number') return d;
  if (typeof d === 'string') return Number(d);
  if (typeof (d as any).toNumber === 'function') return (d as any).toNumber();
  return Number(d);
}

// Accept UI labels or enum strings and normalize to Prisma enum
function normalizeStatus(raw: string | null): 'Todo' | 'Processed' | 'Blacklist' | null {
  if (!raw) return null;
  const s = raw.trim().toLowerCase();
  if (s === 'todo' || s === 'to process' || s === 'to_process' || s === 'to-process' || s === 'toprocess') return 'Todo';
  if (s === 'processed') return 'Processed';
  if (s === 'blacklist' || s === 'blacklisted') return 'Blacklist';
  return null;
}

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);

  const q = searchParams.get('q')?.trim() || '';
  const sort = (searchParams.get('sort') || 'date_desc') as
    | 'date_desc'
    | 'date_asc'
    | 'intl_desc'
    | 'intl_asc'
    | 'dom_desc'
    | 'dom_asc'
    | 'items_desc'
    | 'items_asc';
  const source = searchParams.get('source') || '';
  const statusParam = searchParams.get('status') || '';

  const where: any = {};

  if (q) {
    where.OR = [
      { packageNumber: { contains: q, mode: 'insensitive' } },
      { intlTrackingNumber: { contains: q, mode: 'insensitive' } },
      { pageUrl: { contains: q, mode: 'insensitive' } },
      {
        items: {
          some: {
            OR: [
              { titleJa: { contains: q, mode: 'insensitive' } },
              { titleEn: { contains: q, mode: 'insensitive' } },
              { listingId: { contains: q, mode: 'insensitive' } },
            ],
          },
        },
      },
    ];
  }

  if (source) where.source = source;

  // ✅ status filter (supports UI labels or enum string)
  const status = normalizeStatus(statusParam);
  if (status) where.status = status;

  const orderBy =
    sort === 'date_asc' ? [{ dateShipped: 'asc' }] :
    sort === 'intl_desc' ? [{ internationalShippingFeeYen: 'desc' }] :
    sort === 'intl_asc' ? [{ internationalShippingFeeYen: 'asc' }] :
    sort === 'dom_desc' ? [{ domesticShippingFeeYen: 'desc' }] :
    sort === 'dom_asc' ? [{ domesticShippingFeeYen: 'asc' }] :
    sort === 'items_desc' ? [{ _count: { items: 'desc' } }] :
    sort === 'items_asc' ? [{ _count: { items: 'asc' } }] :
    // default
    [{ dateShipped: 'desc' as const }, { lastSeenAt: 'desc' as const }];

  const data = await prisma.scrapedPackage.findMany({
    where,
    orderBy,
    include: {
      items: {
        select: {
          id: true,
          titleJa: true,
          titleEn: true,
          itemUrl: true,
          listingId: true,
          priceYen: true,
        },
        take: 20,
      },
      _count: { select: { items: true } },
    },
    take: 9999,
  });

  return NextResponse.json(
    data.map((p) => ({
      id: p.id,
      source: p.source,
      pageUrl: p.pageUrl,
      dateShipped: p.dateShipped?.toISOString().slice(0, 10) ?? null,
      packageNumber: p.packageNumber,
      intlTrackingNumber: p.intlTrackingNumber,
      intlTrackingUrl: p.intlTrackingUrl,
      internationalShippingFeeYen: toNum(p.internationalShippingFeeYen),
      domesticShippingFeeYen: toNum(p.domesticShippingFeeYen),
      itemsCount: (p as any)._count.items,
      items: p.items.map((it) => ({
        id: it.id,
        title: it.titleEn || it.titleJa,
        listingId: it.listingId,
        itemUrl: it.itemUrl,
        priceYen: it.priceYen ? toNum(it.priceYen) : null,
      })),
      status: p.status, // 'Todo' | 'Processed' | 'Blacklist'
    }))
  );
}

```

---

## src/app/api/tags/route.ts

```ts
// src/app/api/tags/route.ts
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

type PlacementRow = {
  id: string;
  tagId: string;
  parentPlacementId: string | null;
  tag: { id: string; name: string; description: string | null };
};

function buildTree(rows: PlacementRow[]) {
  const byParent = new Map<string | null, PlacementRow[]>();
  for (const r of rows) {
    const k = r.parentPlacementId;
    const arr = byParent.get(k);
    if (arr) arr.push(r);
    else byParent.set(k, [r]);
  }
  const makeNode = (r: PlacementRow): any => ({
    placementId: r.id,
    tagId: r.tagId,
    name: r.tag.name,
    description: r.tag.description,
    parentPlacementId: r.parentPlacementId,
    children: (byParent.get(r.id) || [])
      .sort((a, b) => a.tag.name.localeCompare(b.tag.name))
      .map(makeNode),
  });
  const roots = (byParent.get(null) || []).sort((a, b) => a.tag.name.localeCompare(b.tag.name)).map(makeNode);
  return roots;
}

async function rebuildPlacementClosureAll() {
  await prisma.placementClosure.deleteMany({});
  const placements = await prisma.tagPlacement.findMany({ select: { id: true, parentPlacementId: true } });

  // self links
  if (placements.length) {
    await prisma.placementClosure.createMany({
      data: placements.map(p => ({ ancestorPlacementId: p.id, descendantPlacementId: p.id, depth: 0 })),
      skipDuplicates: true,
    });
  }

  // adjacency
  const childrenByParent = new Map<string, string[]>();
  for (const p of placements) {
    if (p.parentPlacementId) {
      const arr = childrenByParent.get(p.parentPlacementId);
      if (arr) arr.push(p.id);
      else childrenByParent.set(p.parentPlacementId, [p.id]);
    }
  }

  // BFS from every node as ancestor (small datasets → simple + correct)
  const pairs: { ancestorPlacementId: string; descendantPlacementId: string; depth: number }[] = [];
  for (const anc of placements) {
    const q: Array<{ id: string; depth: number }> = [{ id: anc.id, depth: 0 }];
    const seen = new Set<string>([anc.id]);
    while (q.length) {
      const { id, depth } = q.shift()!;
      const kids = childrenByParent.get(id) ?? [];
      for (const child of kids) {
        if (!seen.has(child)) {
          seen.add(child);
          pairs.push({ ancestorPlacementId: anc.id, descendantPlacementId: child, depth: depth + 1 });
          q.push({ id: child, depth: depth + 1 });
        }
      }
    }
  }
  if (pairs.length) {
    await prisma.placementClosure.createMany({ data: pairs, skipDuplicates: true });
  }
}

export async function GET(req: NextRequest) {
  const rows = await prisma.tagPlacement.findMany({
    select: {
      id: true,
      tagId: true,
      parentPlacementId: true,
      tag: { select: { id: true, name: true, description: true } },
    },
  });

  const tree = buildTree(rows);

  // parentCounts = how many placements each tag has (for 🔗 icon logic)
  const parentCounts: Record<string, number> = {};
  for (const r of rows) {
    parentCounts[r.tagId] = (parentCounts[r.tagId] || 0) + 1;
  }

  // tags list for client-side name lookup (case-insensitive)
  const tags = await prisma.tag.findMany({ select: { id: true, name: true, description: true } });

  return NextResponse.json({ tree, parentCounts, tags });
}

export async function POST(req: NextRequest) {
  try {
    const { name, description, parentPlacementId } = await req.json();
    if (!name || typeof name !== 'string') {
      return NextResponse.json({ error: 'Name is required.' }, { status: 400 });
    }

    // find tag by name (case-insensitive)
    let tag = await prisma.tag.findFirst({
      where: { name: { equals: name, mode: 'insensitive' } },
      select: { id: true, name: true },
    });

    if (!tag) {
      tag = await prisma.tag.create({ data: { name, description } });
    }

    // create placement under given parent (or root)
    const placement = await prisma.tagPlacement.create({
      data: { tagId: tag.id, parentPlacementId: parentPlacementId ?? null },
      select: {
        id: true,
        tagId: true,
        parentPlacementId: true,
        tag: { select: { id: true, name: true, description: true } },
      },
    });

    await rebuildPlacementClosureAll();
    return NextResponse.json({ placement }, { status: 201 });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Failed to create/link placement.' }, { status: 400 });
  }
}

export async function PATCH(req: NextRequest) {
  try {
    const { tagId, name, description } = await req.json();
    if (!tagId) return NextResponse.json({ error: 'tagId is required.' }, { status: 400 });

    const tag = await prisma.tag.update({
      where: { id: tagId },
      data: { name: name ?? undefined, description: description ?? undefined },
      select: { id: true, name: true, description: true },
    });

    return NextResponse.json({ tag });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Failed to update tag.' }, { status: 400 });
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const { placementId } = await req.json();
    if (!placementId) return NextResponse.json({ error: 'placementId is required.' }, { status: 400 });

    // get tagId of placement
    const placement = await prisma.tagPlacement.findUnique({
      where: { id: placementId },
      select: { id: true, tagId: true, parentPlacementId: true },
    });
    if (!placement) return NextResponse.json({ error: 'Placement not found.' }, { status: 404 });

    // delete this placement
    await prisma.tagPlacement.delete({ where: { id: placementId } });

    // if tag has no more placements and is unused by items, delete the tag too
    const [remainingPlacements, inUse] = await Promise.all([
      prisma.tagPlacement.findFirst({ where: { tagId: placement.tagId }, select: { id: true } }),
      prisma.itemTag.findFirst({ where: { tagId: placement.tagId }, select: { itemId: true } }),
    ]);

    let deletedTag = false;
    if (!remainingPlacements && !inUse) {
      await prisma.tag.delete({ where: { id: placement.tagId } });
      deletedTag = true;
    }

    await rebuildPlacementClosureAll();
    return NextResponse.json({ ok: true, deletedPlacement: true, deletedTag });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Failed to delete placement.' }, { status: 400 });
  }
}

```

---

## src/app/api/thumb/[listingId]/route.ts

```ts
// app/api/thumb/[listingId]/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

function buyeeAuctionUrl(listingId: string) {
  return `https://buyee.jp/item/jdirectitems/auction/${listingId}`;
}
function rakutenDetailUrl(listingIdRaw: string) {
  // Next params may decode %3A to ':' — ensure it's encoded for the URL path segment
  const encoded = listingIdRaw.includes(':') ? encodeURIComponent(listingIdRaw) : listingIdRaw;
  return `https://buyee.jp/rakuten/detail/${encoded}`;
}
function abs(url: string, base: string) {
  try { return new URL(url, base).toString(); } catch { return url; }
}

// Buyee (Yahoo) extractor
function extractBuyeeImage(html: string, pageUrl: string): string | null {
  const i = html.indexOf('id="itemPhoto_sec"');
  if (i === -1) return null;
  const slice = html.slice(i, i + 120_000); // wider window

  let m = slice.match(/<li[^>]*\sdata-thumb\s*=\s*["']([^"']+)["'][^>]*>/i);
  if (m?.[1]) return abs(m[1], pageUrl);

  m = slice.match(/<a[^>]*\shref\s*=\s*["']([^"']+\.(?:jpg|jpeg|png))(?:\?[^"']*)?["']/i);
  if (m?.[1]) return abs(m[1], pageUrl);

  m = slice.match(/<img[^>]*\sdata-src\s*=\s*["']([^"']+\.(?:jpg|jpeg|png))(?:\?[^"']*)?["']/i);
  if (m?.[1]) return abs(m[1], pageUrl);

  return null;
}

// Rakuten extractor (more forgiving)
function extractRakutenImage(html: string, pageUrl: string): string | null {
  const i = html.indexOf('id="shopping_item_main_image"');
  if (i !== -1) {
    const slice = html.slice(i, i + 120_000);
    // Prefer data-src
    let m = slice.match(/<img[^>]*\sdata-src\s*=\s*["']([^"']+\.(?:jpg|jpeg|png)(?:\?[^"']*)?)["']/i);
    if (m?.[1]) return abs(m[1], pageUrl);
    // Fallback to src
    m = slice.match(/<img[^>]*\ssrc\s*=\s*["']([^"']+\.(?:jpg|jpeg|png)(?:\?[^"']*)?)["'][^>]*>/i);
    if (m?.[1]) {
      const url = m[1];
      // Skip obvious placeholders
      if (!/loading-spacer\.gif/i.test(url)) return abs(url, pageUrl);
    }
  }
  // Last resort: first cdnrakuten image anywhere on page
  const any = html.match(/https?:\/\/[^"'<>]+cdnrakuten\.buyee\.jp[^"'<>]+?\.(?:jpg|jpeg|png)(?:\?[^"'<>]*)?/i);
  if (any?.[0]) return abs(any[0], pageUrl);
  return null;
}

async function fetchText(url: string) {
  const res = await fetch(url, {
    headers: {
      'User-Agent':
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36',
      'Accept-Language': 'en-US,en;q=0.9,ja;q=0.8',
    },
    cache: 'no-store',
  });
  if (!res.ok) throw new Error(`html_fetch_${res.status}`);
  return res.text();
}
async function fetchImage(url: string) {
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`img_fetch_${res.status}`);
  const contentType = res.headers.get('content-type') || 'image/jpeg';
  const buf = Buffer.from(await res.arrayBuffer());
  return { buf, contentType };
}

const MERCARI_RE = /^m\d{11}$/i;

export async function GET(
  req: Request,
  ctx: { params: Promise<{ listingId: string }> }
) {
  const { listingId } = await ctx.params;
  const origin = new URL(req.url).origin;

  const servePlaceholder = async () => {
    const ph = await fetch(new URL('/placeholder-item.png', origin));
    const b = await ph.arrayBuffer();
    return new NextResponse(b, {
      status: 200,
      headers: { 'Content-Type': 'image/png', 'Cache-Control': 'no-store' },
    });
  };

  if (!/^[A-Za-z0-9_%:.-]+$/.test(listingId)) return servePlaceholder();

  // DB cache
  let cachedUrl: string | null = null;
  try {
    const cached = await prisma.listingImageCache.findUnique({ where: { listingId } });
    if (cached?.url) cachedUrl = cached.url;
  } catch {}

  // Resolve if not cached
  if (!cachedUrl) {
    try {
      if (MERCARI_RE.test(listingId)) {
        // Mercari -> direct CDN
        cachedUrl = `https://static.mercdn.net/item/detail/orig/photos/${listingId}_1.jpg`;
        await prisma.listingImageCache.upsert({
          where: { listingId },
          update: { url: cachedUrl, source: 'mercari' },
          create: { listingId, url: cachedUrl, source: 'mercari' },
        });
      } else if (listingId.includes('%3A') || listingId.includes(':')) {
        // Rakuten
        const detailUrl = rakutenDetailUrl(listingId);
        const html = await fetchText(detailUrl);
        cachedUrl = extractRakutenImage(html, detailUrl);
        await prisma.listingImageCache.upsert({
          where: { listingId },
          update: { url: cachedUrl, source: 'rakuten' },
          create: { listingId, url: cachedUrl, source: 'rakuten' },
        });
      } else {
        // Buyee (Yahoo Auctions)
        const pageUrl = buyeeAuctionUrl(listingId);
        const html = await fetchText(pageUrl);
        cachedUrl = extractBuyeeImage(html, pageUrl);
        await prisma.listingImageCache.upsert({
          where: { listingId },
          update: { url: cachedUrl, source: 'buyee' },
          create: { listingId, url: cachedUrl, source: 'buyee' },
        });
      }
    } catch {
      // ignore, fallback below
    }
  }

  // Stream image or placeholder
  try {
    if (cachedUrl) {
      const { buf, contentType } = await fetchImage(cachedUrl);
      return new NextResponse(buf, {
        status: 200,
        headers: { 'Content-Type': contentType, 'Cache-Control': 'no-store' },
      });
    }
  } catch {}

  return servePlaceholder();
}

```

---

## src/app/dashboard/page.tsx

```tsx
export default function DashboardPage() {
  return (
    <div className="rounded-xl border border-gray-800 bg-gray-950 p-6">
      <div className="text-gray-400">Dashboard coming soon…</div>
    </div>
  );
}
```

---

## src/app/globals.css

```css
@import "tailwindcss";

@theme {
  --color-bg:        #0b0f16;
  --color-surface:   color-mix(in oklab, white 6%, var(--color-bg));
  --color-border:    color-mix(in oklab, white 8%, var(--color-bg));
  --color-muted:     #8b9bb3;
  --color-text:      #e6ebf1;
  --color-accent:    #3b82f6;  /* blue-500 */
  --color-success:   #10b981;  /* emerald-500 */
  --radius:          12px;
}

:root { color-scheme: dark; }

body {
  background: var(--color-bg);
  color: var(--color-text);
}

/* nice low-contrast containers */
.card {
  @apply rounded-xl border;
  background: var(--color-surface);
  border-color: color-mix(in oklab, var(--color-border) 100%, transparent);
  box-shadow: 0 10px 30px -20px rgba(0,0,0,.6), inset 0 1px 0 0 rgba(255,255,255,.03);
}

/* inputs */
.field {
  @apply rounded-lg px-3 py-2 text-sm;
  background: color-mix(in oklab, white 5%, var(--color-bg));
  border: 1px solid var(--color-border);
}
.field:focus-visible {
  outline: none;
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--color-accent) 40%, transparent);
}

/* buttons */
.btn {
  @apply rounded-md px-3 py-1.5 text-sm font-medium;
}
.btn-outline {
  @apply border;
  border-color: var(--color-border);
  background: color-mix(in oklab, white 4%, var(--color-bg));
}
.btn-outline:hover { background: color-mix(in oklab, white 7%, var(--color-bg)); }
.btn-primary { background: var(--color-accent); color: white; }
.btn-primary:hover { filter: brightness(1.05); }
.btn-success { background: var(--color-success); color: white; }
.btn-success:hover { filter: brightness(1.05); }

/* subtle separator */
.hr { border-top: 1px solid var(--color-border); }

/* scrollbar */
::-webkit-scrollbar { width: 10px; height: 10px; }
::-webkit-scrollbar-thumb { background: #1f2733; border-radius: 8px; }
::-webkit-scrollbar-track { background: var(--color-bg); }

/* Responsive cards grid: never let a card go below 320px wide */
.cards-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 1.25rem; /* ~= gap-5 */
}

/* somewhere global (e.g., globals.css) */
.btn { cursor: pointer; }

```

---

## src/app/inventory-filler/page.tsx

```tsx
// src/app/inventory-filler/page.tsx
'use client';

import { useEffect, useMemo, useState } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import WeightSliders, { type WeightRow } from '@/components/WeightSliders';
import { percentToPpm, ppmToPercent, PPM_DENOM } from '@/lib/weights';
import { getJpyToEurRate, yenToEuro } from '@/lib/fx.client';
import SingleTagPicker from '@/components/SingleTagPicker';

type Condition = 'Loose' | 'Boxed' | 'CIB' | 'NIB';

type SourceEntry = {
  id?: string;
  nameOverride: string | null;
  quantity: number;
  priceWeightPpm: number;
  shippingWeightPpm: number;
  tagId: string | null;
  tagPlacementId: string | null;
  condition?: Condition; // ✅ new (defaults to 'Loose' in UI)
};

type SourceItem = {
  id: string;
  scrapedItemId?: string | null;
  manualLineId?: string | null;
  /** Optional listing id (needed for /api/thumb/[listingId]) */
  listingId?: string | null;
  title: string;
  priceYen: number;
  shippingWeightPpm: number;
  entries: SourceEntry[];
};

type SessionPayload = {
  session: {
    id: string;
    sourceType: 'ScrapedPackage' | 'Manual';
    customsTotalYen: number;
    finalizedAt?: string | null;
    dateShipped?: string | null;
  };
  fxDateISO?: string | null;
  packageTotals: { intlShip: number; domShip: number; packageShippingTotal: number };
  sourceItems: SourceItem[];
};

type TagFlat = { id: string; name: string; description: string | null };

// Build thumbnail URL if we have a listingId; otherwise null
function thumbUrlFor(item: SourceItem): string | null {
  const lid = (item as any)?.listingId;
  if (lid && typeof lid === 'string' && lid.length > 0) {
    return `/api/thumb/${encodeURIComponent(lid)}`;
  }
  return null;
}

/** Floating image preview that follows the cursor on hover */
function HoverFloat(props: { url: string | null; size?: number; children: React.ReactNode }) {
  const { url, size = 320, children } = props;
  const [show, setShow] = useState(false);
  const [pos, setPos] = useState<{ x: number; y: number }>({ x: 0, y: 0 });

  return (
    <>
      <span
        className="inline-flex items-center"
        onMouseEnter={() => url && setShow(true)}
        onMouseLeave={() => setShow(false)}
        onMouseMove={(e) => setPos({ x: e.clientX, y: e.clientY })}
        style={{ cursor: url ? 'zoom-in' : undefined }}
      >
        {children}
      </span>
      {url && show && (
        <div
          className="fixed z-[9999] pointer-events-none"
          style={{ left: pos.x + 12, top: pos.y + 12 }}
        >
          <div className="rounded-lg border border-white/10 bg-black/90 p-1 shadow-2xl">
            {/* eslint-disable-next-line @next/next/no-img-element */}
            <img
              src={url}
              alt=""
              width={size}
              height={size}
              className="block object-contain max-w-none"
              loading="eager"
            />
          </div>
        </div>
      )}
    </>
  );
}

function fmtEUR(v: number | null | undefined) {
  if (v == null || !isFinite(v)) return '€0.00';
  return v.toLocaleString(undefined, { style: 'currency', currency: 'EUR', minimumFractionDigits: 2, maximumFractionDigits: 2 });
}
function fmtJPY(v: number | null | undefined) {
  if (v == null || !isFinite(v)) return '¥0';
  return `¥${Math.round(v).toLocaleString()}`;
}

async function fetchTags(): Promise<TagFlat[]> {
  const r = await fetch('/api/tags?format=flat', { cache: 'no-store' });
  const j = await r.json();
  return (j.tags || []) as TagFlat[];
}

export default function InventoryFillerPage() {
  const sp = useSearchParams();
  const router = useRouter();

  const [data, setData] = useState<SessionPayload | null>(null);
  const [tags, setTags] = useState<TagFlat[]>([]);
  const [busy, setBusy] = useState(false);

  // FX state
  const [fxRate, setFxRate] = useState<number | null>(null);
  const [fxDateISO, setFxDateISO] = useState<string>('');

  // Customs input: user edits in EUR; we convert to JPY for preview/save
  const [customsEuro, setCustomsEuro] = useState<string>('');
  const [customsDirty, setCustomsDirty] = useState<boolean>(false); // ✅ prevents overwriting user input

  const sessionId = sp.get('sessionId');
  const packageId = sp.get('packageId');

  // Create/reuse session from packageId
  useEffect(() => {
  (async () => {
    if (!sessionId && packageId) {
      // 1) try existing
      const r = await fetch(`/api/fill-sessions/by-package?packageId=${encodeURIComponent(packageId)}`, { cache: 'no-store' });
      if (r.ok) {
        const j = await r.json();
        router.replace(`/inventory-filler?sessionId=${j.sessionId}`);
        return;
      }
      // 2) else create new
      const res = await fetch('/api/fill-sessions', {
        method: 'POST',
        body: JSON.stringify({ sourceType: 'ScrapedPackage', scrapedPackageId: packageId }),
      });
      const j = await res.json();
      if (res.ok) {
        router.replace(`/inventory-filler?sessionId=${j.sessionId}`);
      } else {
        alert(j.error || 'Failed to start session');
      }
    }
  })();
}, [sessionId, packageId, router]);

  // Load session + tags + FX by package shipping date
  useEffect(() => {
    (async () => {
      if (!sessionId) return;
      const res = await fetch(`/api/fill-sessions/${sessionId}`, { cache: 'no-store' });
      const j = await res.json();
      if (!res.ok) {
        alert(j.error || 'Failed to load');
        return;
      }
      setData(j);
      setTags(await fetchTags());

      // Prefer backend-provided date, else other fields, else today
      const shippedISO =
        (j?.fxDateISO && String(j.fxDateISO)) ||
        (j?.scrapedPackage?.dateShipped && new Date(j.scrapedPackage.dateShipped).toISOString().slice(0,10)) ||
        (j?.package?.dateShipped && new Date(j.package.dateShipped).toISOString().slice(0,10)) ||
        (j?.session?.dateShipped && new Date(j.session.dateShipped).toISOString().slice(0,10)) ||
        new Date().toISOString().slice(0, 10);

      setFxDateISO(shippedISO);
      const rate = await getJpyToEurRate(shippedISO);
      setFxRate(rate);
    })();
  }, [sessionId]);

  const packageSubtotal = useMemo(() => {
    if (!data) return 0;
    return data.sourceItems.reduce((a, s) => a + s.priceYen, 0);
  }, [data]);

  const shippingSumOK = useMemo(() => {
    if (!data) return true;
    const sum = data.sourceItems.reduce((a, s) => a + s.shippingWeightPpm, 0);
    return sum === PPM_DENOM;
  }, [data]);

  const finalized = !!data?.session.finalizedAt;

  // Seed customsEuro from DB **only when user hasn't edited yet**
  useEffect(() => {
    if (!data || !fxRate) return;
    if (customsDirty) return; // ✅ don't clobber user's input
    const jpy = Number(data.session.customsTotalYen || 0);
    const eur = yenToEuro(jpy, fxRate);
    setCustomsEuro(Number.isFinite(eur) ? eur.toFixed(2) : '');
  }, [data, fxRate, customsDirty]);

  // Computed JPY value used for previews (current input if available, else saved)
  const customsTotalJPYPreview = useMemo(() => {
    const savedJPY = Number(data?.session.customsTotalYen || 0);
    if (fxRate && isFinite(fxRate)) {
      const eur = Number(customsEuro || '0');
      if (Number.isFinite(eur)) {
        // round to 2 decimals to match storage style
        return Math.round((eur / fxRate) * 100) / 100;
      }
    }
    return savedJPY;
  }, [customsEuro, fxRate, data?.session.customsTotalYen]);

  const onSave = async () => {
    if (!data || finalized) return;
    setBusy(true);
    try {
      const eur = Number(customsEuro || '0');
      const customsJPY = fxRate ? Math.round((eur / (fxRate || 1)) * 100) / 100 : 0;

      const body = {
        customsTotalYen: customsJPY,
        sourceItems: data.sourceItems.map(s => ({ id: s.id, shippingWeightPpm: s.shippingWeightPpm })),
        entriesUpsert: data.sourceItems.flatMap(s =>
          s.entries.map(e => ({
            ...(e.id ? { id: e.id } : {}),
            sourceItemId: s.id,
            nameOverride: e.nameOverride,
            quantity: e.quantity,
            priceWeightPpm: e.priceWeightPpm,
            shippingWeightPpm: e.shippingWeightPpm,
            tagId: e.tagId,
            tagPlacementId: e.tagPlacementId,
            condition: (e.condition ?? 'Loose') as Condition, // ✅ send condition
          }))
        ),
      };

      const res = await fetch(`/api/fill-sessions/${data.session.id}`, {
        method: 'PATCH',
        body: JSON.stringify(body),
      });
      const j = await res.json();
      if (!res.ok) throw new Error(j.error || 'Save failed');

      // ✅ Keep local state in sync so it doesn't "snap back"
      setData(d => d ? { ...d, session: { ...d.session, customsTotalYen: customsJPY } } as SessionPayload : d);
      setCustomsDirty(false);
    } catch (e: any) {
      alert(e.message || 'Save failed');
    } finally {
      setBusy(false);
    }
  };

  const onFinalize = async () => {
    if (!data || finalized) return;
    const sourceOK = data.sourceItems.reduce((a, s) => a + s.shippingWeightPpm, 0) === PPM_DENOM;
    const entrySplitsOK = data.sourceItems.every(s => {
      const priceSum = s.entries.reduce((a, e) => a + e.priceWeightPpm, 0);
      const shipSum = s.entries.reduce((a, e) => a + e.shippingWeightPpm, 0);
      return priceSum === PPM_DENOM && shipSum === PPM_DENOM;
    });
    if (!sourceOK || !entrySplitsOK) {
      alert('Weights must sum to 100% at each level.');
      return;
    }
    setBusy(true);
    try {
      const res = await fetch(`/api/fill-sessions/${data.session.id}/finalize`, { method: 'POST' });
      const j = await res.json();
      if (!res.ok) throw new Error(j.error || 'Finalize failed');
      alert(j.alreadyFinalized ? 'Already finalized (no changes).' : `Created ${j.created} InventoryItems`);
      const res2 = await fetch(`/api/fill-sessions/${data.session.id}`, { cache: 'no-store' });
      setData(await res2.json());
    } catch (e: any) {
      alert(e.message || 'Finalize failed');
    } finally {
      setBusy(false);
    }
  };

  if (!sessionId) {
    return (
      <div className="card p-5">
        Open via a Scraped Package’s “Proceed” (it will take you here with <code>?packageId=…</code>),
        or pass <code>?sessionId=…</code> to continue an existing session.
      </div>
    );
  }
  if (!data) return <div className="card p-6">Loading…</div>;

  return (
    <div className="space-y-5">
      {finalized && (
        <div className="card p-3 bg-emerald-900/20 border border-emerald-700/30 text-emerald-200">
          This session was finalized on <span className="font-mono">{new Date(data.session.finalizedAt!).toLocaleString()}</span>. Editing is disabled.
        </div>
      )}

      {/* Header / package totals */}
      <div className="card p-4">
        <div className="grid sm:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
          <div>
            <div className="text-xs text-gray-400">Session</div>
            <div className="font-medium">{data.session.id}</div>
            <div className="text-xs text-gray-500">{data.session.sourceType}</div>
          </div>
          <div>
            <div className="text-xs text-gray-400">Package subtotal</div>
            <div className="font-medium">
              {fmtEUR(yenToEuro(packageSubtotal, fxRate ?? 0))}{' '}
              <span className="text-gray-500">({fmtJPY(packageSubtotal)})</span>
            </div>
          </div>
          <div>
            <div className="text-xs text-gray-400">Shipping total (intl+dom)</div>
            <div className="font-medium">
              {fmtEUR(yenToEuro(data.packageTotals.packageShippingTotal, fxRate ?? 0))}{' '}
              <span className="text-gray-500">({fmtJPY(data.packageTotals.packageShippingTotal)})</span>
            </div>
          </div>
          <div>
            <label className="text-xs text-gray-400">Customs (EUR)</label>
            <div className="flex items-center gap-2 mt-1">
              <input
                className="field w-full"
                type="number"
                step="0.01"
                inputMode="decimal"
                placeholder="0.00"
                value={customsEuro}
                onChange={e => { setCustomsDirty(true); setCustomsEuro(e.target.value); }} // ✅ mark as dirty
                disabled={finalized}
              />
              <span className="text-xs text-gray-500">
                ({fmtJPY(customsTotalJPYPreview)})
              </span>
            </div>
          </div>

          {/* FX badge */}
          <div className="sm:col-span-2 lg:col-span-4 flex justify-end text-xs">
            <div className="rounded-lg border border-white/10 px-2 py-1">
              FX JPY→EUR {fxDateISO ? `@ ${fxDateISO}` : ''}: <span className="font-medium">{fxRate ? fxRate.toFixed(6) : '—'}</span>
            </div>
          </div>
        </div>

        <div className="mt-3 text-xs">
          Source shipping weights sum:{' '}
          <span className={shippingSumOK ? 'text-emerald-400' : 'text-amber-400'}>
            {ppmToPercent(data.sourceItems.reduce((a, s) => a + s.shippingWeightPpm, 0)).toFixed(1)}%
          </span>
        </div>
      </div>

      {/* Top-level shipping split across source items */}
      <div className="card p-4">
        <WeightSliders
          title="Package → source items shipping split"
          help="Distribute the total package shipping (intl + domestic) across items. Locks keep a row fixed while others redistribute."
          rows={data.sourceItems.map(s => ({
            id: s.id,
            // Wrap the label with a hover preview of the item image
            label: (
              <HoverFloat url={thumbUrlFor(s)} size={320}>
                <span className="cursor-zoom-in underline decoration-dotted decoration-white/30">
                  {s.title}
                </span>
              </HoverFloat>
            ) as any, // cast keeps TS happy if label is typed as string
            ppm: s.shippingWeightPpm,
            rightHint: (
              <span>
                {fmtEUR(yenToEuro(data.packageTotals.packageShippingTotal * (s.shippingWeightPpm / PPM_DENOM), fxRate ?? 0))}{' '}
                <span className="text-gray-500">
                  ({fmtJPY(data.packageTotals.packageShippingTotal * (s.shippingWeightPpm / PPM_DENOM))})
                </span>
              </span>
            ),
          }))}
          onChange={(rows) => {
            if (finalized) return;
            setData(d => !d ? d : ({
              ...d,
              sourceItems: d.sourceItems.map(s => {
                const r = rows.find(x => x.id === s.id)!;
                return { ...s, shippingWeightPpm: r.ppm };
              }),
            }));
          }}
        />
      </div>

      {/* Source items */}
      {data.sourceItems.map((s) => (
        <SourceItemCard
          key={s.id}
          item={s}
          onChange={(next) => {
            if (finalized) return;
            setData(d => !d ? d : ({ ...d, sourceItems: d.sourceItems.map(x => x.id === s.id ? next : x) }));
          }}
          packageShippingTotal={data.packageTotals.packageShippingTotal}
          customsTotalPreview={customsTotalJPYPreview}  // ✅ live preview value
          packageSubtotal={packageSubtotal}
          allTags={tags}
          disabled={finalized}
          fxRate={fxRate ?? 0}
        />
      ))}

      {/* actions */}
      <div className="flex gap-3">
        <button className="btn btn-outline" onClick={onSave} disabled={busy || finalized}>
          {busy ? 'Saving…' : 'Save'}
        </button>
        <button className="btn btn-outline" onClick={onFinalize} disabled={busy || finalized}>
          Finalize → Inventory
        </button>
      </div>
    </div>
  );
}

function SourceItemCard(props: {
  item: SourceItem;
  onChange: (next: SourceItem) => void;
  packageShippingTotal: number;
  customsTotalPreview: number; // ✅ use preview (EUR input converted to JPY)
  packageSubtotal: number;
  allTags: TagFlat[];
  disabled?: boolean;
  fxRate: number;
}) {
  const { item, onChange, packageShippingTotal, customsTotalPreview, packageSubtotal, allTags, disabled, fxRate } = props;

  const sourceShipAlloc = Math.round(packageShippingTotal * (item.shippingWeightPpm / PPM_DENOM));

  const priceRows: WeightRow[] =
    item.entries.length > 0
      ? item.entries.map((e, i) => ({
          id: e.id ?? `new-${i}`,
          label: e.nameOverride || `Entry ${i + 1}`,
          ppm: e.priceWeightPpm,
          rightHint: (
            <span>
              {fmtEUR(yenToEuro(item.priceYen * (e.priceWeightPpm / PPM_DENOM), fxRate))}{' '}
              <span className="text-gray-500">({fmtJPY(item.priceYen * (e.priceWeightPpm / PPM_DENOM))})</span>
            </span>
          ),
        }))
      : [];

  const shipRows: WeightRow[] =
    item.entries.length > 0
      ? item.entries.map((e, i) => ({
          id: e.id ?? `new-${i}`,
          label: e.nameOverride || `Entry ${i + 1}`,
          ppm: e.shippingWeightPpm,
          rightHint: (
            <span>
              {fmtEUR(yenToEuro(sourceShipAlloc * (e.shippingWeightPpm / PPM_DENOM), fxRate))}{' '}
              <span className="text-gray-500">({fmtJPY(sourceShipAlloc * (e.shippingWeightPpm / PPM_DENOM))})</span>
            </span>
          ),
        }))
      : [];

  const entryCustomsPreview = (e: SourceEntry) => {
    if (packageSubtotal <= 0 || customsTotalPreview <= 0) return 0;
    const sourceShare = item.priceYen / packageSubtotal;
    return Math.round(customsTotalPreview * sourceShare * (e.priceWeightPpm / PPM_DENOM));
  };

  return (
    <div className="card p-4 space-y-4">
      <div className="flex items-start justify-between gap-3">
        <div className="flex items-start gap-3">
          {/* Thumbnail (uses /api/thumb/[listingId]) with hover preview */}
          {(() => {
            const url = thumbUrlFor(item);
            return url ? (
              <HoverFloat url={url} size={320}>
                {/* eslint-disable-next-line @next/next/no-img-element */}
                <img
                  src={url}
                  alt={item.title || 'thumbnail'}
                  className="w-16 h-16 rounded-md object-cover border border-white/10"
                  loading="lazy"
                  referrerPolicy="no-referrer"
                />
              </HoverFloat>
            ) : (
              <div className="w-16 h-16 rounded-md border border-white/10 bg-white/5 grid place-items-center text-[10px] text-gray-500">
                no img
              </div>
            );
          })()}
          <div>
            <div className="font-semibold">{item.title}</div>
            <div className="text-xs text-gray-400">
              {fmtEUR(yenToEuro(item.priceYen, fxRate))}{' '}
              <span className="text-gray-500">({fmtJPY(item.priceYen)})</span>
            </div>
            <div className="text-xs text-gray-400">
              This item’s shipping pool:{' '}
              {fmtEUR(yenToEuro(sourceShipAlloc, fxRate))}{' '}
              <span className="text-gray-500">({fmtJPY(sourceShipAlloc)})</span>
            </div>
          </div>
        </div>
        <div>
          <button
            className="btn btn-outline text-xs"
            onClick={() => {
              if (disabled) return;
              const newEntry: SourceEntry = {
                id: undefined,
                nameOverride: null,
                quantity: 1,
                priceWeightPpm: 0,
                shippingWeightPpm: 0,
                tagId: null,
                tagPlacementId: null,
                condition: 'Loose', // ✅ default
              };
              onChange({ ...item, entries: [...item.entries, newEntry] });
            }}
            disabled={disabled}
          >
            + Add entry
          </button>
        </div>
      </div>

      {/* Price split within this source item */}
      {priceRows.length > 0 ? (
        <WeightSliders
          title="Entries → price split"
          help="Split this source item’s base price across its entries. Locks keep an entry fixed while the others redistribute."
          rows={priceRows}
          onChange={(rows) => {
            if (disabled) return;
            onChange({
              ...item,
              entries: item.entries.map(e => {
                const rid = e.id ?? rows.find(r => r.label === (e.nameOverride || ''))?.id;
                const r = rows.find(x => x.id === (e.id ?? rid));
                if (!r) return e;
                return { ...e, priceWeightPpm: r.ppm };
              }),
            });
          }}
        />
      ) : (
        <div className="rounded-xl border border-white/10 p-3 text-xs text-gray-400">Add entries to split price and shipping.</div>
      )}

      {/* Shipping split within this source item */}
      {shipRows.length > 0 && (
        <WeightSliders
          title="Entries → shipping split"
          help="Split this source item’s shipping share across its entries. Locks keep an entry fixed while the others redistribute."
          rows={shipRows}
          onChange={(rows) => {
            if (disabled) return;
            onChange({
              ...item,
              entries: item.entries.map(e => {
                const rid = e.id ?? rows.find(r => r.label === (e.nameOverride || ''))?.id;
                const r = rows.find(x => x.id === (e.id ?? rid));
                if (!r) return e;
                return { ...e, shippingWeightPpm: r.ppm };
              }),
            });
          }}
        />
      )}

      {/* Entries editor */}
      <div className="rounded-lg border border-white/10 divide-y divide-white/10">
        {item.entries.map((e, i) => (
          <div key={e.id || i} className="p-3 grid md:grid-cols-7 gap-3 items-center">
            <div className="md:col-span-2">
              <input
                className="field w-full"
                placeholder="Name (optional override)"
                value={e.nameOverride ?? ''}
                onChange={ev => onChange({ ...item, entries: item.entries.map(x => x === e ? { ...e, nameOverride: ev.target.value } : x) })}
                disabled={disabled}
              />
              <div className="mt-2 flex flex-wrap gap-1">
                <SingleTagPicker
                  value={e.tagId ?? null}
                  onChange={(sel) => {
                    const tagId = sel?.tagId ?? null;
                    const placementId = sel?.placementId ?? null;
                    // Auto-fill name only if blank: prefer tag description, then name
                    let nextName = e.nameOverride ?? '';
                    const isBlank = !nextName || nextName.trim().length === 0;
                    if (isBlank && tagId) {
                      const t = allTags.find(t => t.id === tagId);
                      const candidate = (t?.description?.trim() || t?.name || '').trim();
                      if (candidate) nextName = candidate;
                    }
                    onChange({
                      ...item,
                      entries: item.entries.map(x =>
                        x === e ? { ...e, tagId, tagPlacementId: placementId, nameOverride: nextName } : x
                      ),
                    });
                  }}
                />
              </div>
            </div>

            <div>
              <label className="block text-xs text-gray-400">Qty</label>
              <input
                type="number"
                className="field w-20"
                min={1}
                value={e.quantity}
                onChange={ev => onChange({
                  ...item,
                  entries: item.entries.map(x => x === e ? { ...e, quantity: Math.max(1, parseInt(ev.target.value || '1', 10)) } : x),
                })}
                disabled={disabled}
              />
            </div>

            {/* ✅ Condition selector (kept compact) */}
            <div>
              <label className="block text-xs text-gray-400">Condition</label>
              <select
                className="field w-28"
                value={e.condition ?? 'Loose'}
                onChange={ev =>
                  onChange({
                    ...item,
                    entries: item.entries.map(x => x === e ? { ...e, condition: ev.target.value as Condition } : x),
                  })
                }
                disabled={disabled}
              >
                <option value="Loose">Loose</option>
                <option value="Boxed">Boxed</option>
                <option value="CIB">CIB</option>
                <option value="NIB">NIB</option>
              </select>
            </div>

            <div>
              <div className="text-xs text-gray-400">Base preview</div>
              <div className="text-sm">
                {fmtEUR(yenToEuro(item.priceYen * (e.priceWeightPpm / PPM_DENOM), fxRate))}
                <div className="text-xs text-gray-500">
                  {fmtJPY(item.priceYen * (e.priceWeightPpm / PPM_DENOM))}
                </div>
              </div>
            </div>

            <div>
              <div className="text-xs text-gray-400">Ship + customs preview</div>
              <div className="text-sm">
                {fmtEUR(yenToEuro(sourceShipAlloc * (e.shippingWeightPpm / PPM_DENOM), fxRate))}
                {' + '}
                {fmtEUR(yenToEuro(entryCustomsPreview(e), fxRate))}
                <div className="text-xs text-gray-500">
                  {fmtJPY(sourceShipAlloc * (e.shippingWeightPpm / PPM_DENOM))} + {fmtJPY(entryCustomsPreview(e))}
                </div>
              </div>
            </div>

            <div>
              <div className="text-xs text-gray-400">Est. total / unit</div>
              <div className="text-sm">
                {(() => {
                  const basePartJPY = Math.round(item.priceYen * (e.priceWeightPpm / PPM_DENOM));
                  const shipPartJPY = Math.round(sourceShipAlloc * (e.shippingWeightPpm / PPM_DENOM));
                  const customsPartJPY = entryCustomsPreview(e); // already in JPY
                  const totalJPY = basePartJPY + shipPartJPY + customsPartJPY;
                  const perUnitJPY = Math.round(totalJPY / Math.max(1, e.quantity));
                  return (
                    <div>
                      {fmtEUR(yenToEuro(perUnitJPY, fxRate))}
                      <div className="text-xs text-gray-500">{fmtJPY(perUnitJPY)}</div>
                    </div>
                  );
                })()}
              </div>
            </div>

            <div className="md:col-span-7 flex justify-end">
              <button
                className="btn btn-outline text-xs"
                onClick={() => onChange({ ...item, entries: item.entries.filter(x => x !== e) })}
                disabled={disabled}
              >
                🗑️ Remove
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

```

---

## src/app/inventory/page.tsx

```tsx
// src/app/inventory/page.tsx
'use client';

import { useEffect, useMemo, useState } from 'react';
import { getJpyToEurRate, yenToEuro } from '@/lib/fx.client';

type Row = {
  id: string;
  name: string;
  // ✅ NEW: condition is returned by the API (Loose | Boxed | CIB | NIB)
  condition: string;
  tagChain: string; // e.g. "Foo (Root > Branch > Leaf) • Bar (...)"
  fxDateISO: string | null; // date used for JPY->EUR conversion (YYYY-MM-DD)
  packageNumber: string | null;
  purchaseDateISO: string | null;
  jpy: {
    basePerUnit: number;
    shipPerUnit: number;
    customsPerUnit: number;
    totalPerUnit: number;
  };
};

type ApiResp = { items: Row[]; nextCursor: string | null };

function fmtEUR(v: number | null | undefined) {
  if (v == null || !isFinite(v)) return '€0.00';
  return v.toLocaleString(undefined, {
    style: 'currency',
    currency: 'EUR',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  });
}
function fmtJPY(v: number | null | undefined) {
  if (v == null || !isFinite(v)) return '¥0';
  return `¥${Math.round(v).toLocaleString()}`;
}

export default function InventoryPage() {
  // stacked filters (chips)
  const [filters, setFilters] = useState<string[]>([]);
  const [draft, setDraft] = useState('');
  const [rows, setRows] = useState<Row[]>([]);
  const [cursor, setCursor] = useState<string | null>(null);
  const [busy, setBusy] = useState(false);

  // cache of JPY->EUR rates by date
  const [rates, setRates] = useState<Record<string, number>>({});

  const todayISO = useMemo(() => new Date().toISOString().slice(0, 10), []);

  // URL sync (optional but nice; keeps filters in the address bar)
  useEffect(() => {
    const params = new URLSearchParams();
    for (const f of filters) params.append('q', f);
    const qs = params.toString();
    const url = qs ? `/inventory?${qs}` : '/inventory';
    window.history.replaceState(null, '', url);
  }, [filters]);

  async function ensureRates(dates: (string | null)[]) {
    const unique = Array.from(
      new Set(
        dates.map(d => (d && d.length ? d : todayISO)).filter(Boolean) as string[],
      ),
    ).filter(d => rates[d] == null);

    if (!unique.length) return;

    const fetched = await Promise.all(
      unique.map(async (d) => {
        try {
          const r = await getJpyToEurRate(d);
          return [d, r] as const;
        } catch {
          return [d, NaN] as const; // avoid re-fetch loops; UI will show €0.00
        }
      }),
    );

    setRates(prev => {
      const next = { ...prev };
      for (const [d, r] of fetched) next[d] = r;
      return next;
    });
  }

  async function load(opts: { reset?: boolean; cursor?: string | null } = {}) {
    const { reset = false, cursor: cur = null } = opts;
    setBusy(true);
    try {
      const url = new URL('/api/inventory', window.location.origin);
      url.searchParams.set('limit', '50');
      if (cur) url.searchParams.set('cursor', cur);
      for (const f of filters) url.searchParams.append('q', f);

      const r = await fetch(url.toString(), { cache: 'no-store' });
      const j: ApiResp = await r.json();
      if (!r.ok) throw new Error((j as any)?.error || 'load_failed');

      const page = j.items || [];
      setRows(prev => (reset ? page : [...prev, ...page]));
      setCursor(j.nextCursor ?? null);

      await ensureRates(page.map(x => x.fxDateISO));
    } catch (e: any) {
      alert(e.message || 'Load failed');
    } finally {
      setBusy(false);
    }
  }

  // initial load
  useEffect(() => {
    // hydrate filters from URL (?q=...&q=...)
    const sp = new URLSearchParams(window.location.search);
    const qs = sp.getAll('q').map(s => s.trim()).filter(Boolean);
    if (qs.length) setFilters(qs);

    // then load
    load({ reset: true });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // reload when filters change
  useEffect(() => {
    // immediate reload
    load({ reset: true });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [filters.join('\u0001')]);

  function addFilter() {
    const v = draft.trim();
    if (!v) return;
    if (!filters.includes(v)) setFilters(prev => [...prev, v]);
    setDraft('');
  }
  function removeFilter(f: string) {
    setFilters(prev => prev.filter(x => x !== f));
  }

  function eurFor(jpy: number, d: string | null) {
    const key = d && d.length ? d : todayISO;
    const rate = rates[key];
    if (!Number.isFinite(rate)) return 0;
    return yenToEuro(jpy, rate);
  }

  return (
    <div className="space-y-4">
      <h1 className="text-xl font-semibold">Inventory</h1>
      <p className="text-xs text-gray-400">
        Per-unit prices computed from session splits and FX on package date.
      </p>

      {/* Stacked filters */}
      <div className="rounded-lg border border-white/10 p-2">
        <div className="flex flex-wrap items-center gap-2">
          {filters.map(f => (
            <span
              key={f}
              className="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/5 px-2 py-1 text-xs"
            >
              {f}
              <button
                className="hover:text-red-300"
                onClick={() => removeFilter(f)}
                title="Remove filter"
              >
                ✕
              </button>
            </span>
          ))}

          <input
            className="field min-w-[14rem] flex-1"
            placeholder="Search by name, tag, or package # …"
            value={draft}
            onChange={e => setDraft(e.target.value)}
            onKeyDown={e => {
              if (e.key === 'Enter' || e.key === ',') {
                e.preventDefault();
                addFilter();
              }
              if (e.key === 'Escape') setDraft('');
            }}
          />
          <button className="btn btn-outline" onClick={addFilter}>Add</button>
          {filters.length > 0 && (
            <button className="btn btn-outline" onClick={() => setFilters([])}>
              Clear
            </button>
          )}
        </div>
      </div>

      {/* Table */}
      <div className="rounded-lg border border-white/10 overflow-hidden">
        <table className="w-full text-sm">
          <thead className="bg-white/5 text-xs text-gray-400">
            <tr>
              <th className="px-3 py-2 text-left">Name</th>
              <th className="px-3 py-2 text-left">Tags</th>
              {/* ✅ NEW */}
              <th className="px-3 py-2 text-left">Condition</th>
              <th className="px-3 py-2 text-left">Item price</th>
              <th className="px-3 py-2 text-left">Real price</th>
              <th className="px-3 py-2 text-left">Package #</th>
              <th className="px-3 py-2 text-left">Purchase date</th>
            </tr>
          </thead>
          <tbody>
            {rows.map((r) => {
              const baseEUR = eurFor(r.jpy.basePerUnit, r.fxDateISO);
              const totalEUR = eurFor(r.jpy.totalPerUnit, r.fxDateISO);
              return (
                <tr key={r.id} className="border-t border-white/10">
                  <td className="px-3 py-2">{r.name || '—'}</td>
                  <td className="px-3 py-2">{r.tagChain || '—'}</td>
                  {/* ✅ NEW */}
                  <td className="px-3 py-2">{r.condition || '—'}</td>

                  <td className="px-3 py-2">
                    <div>{fmtEUR(baseEUR)}</div>
                    <div className="text-xs text-gray-500">{fmtJPY(r.jpy.basePerUnit)}</div>
                  </td>
                  <td className="px-3 py-2">
                    <div>{fmtEUR(totalEUR)}</div>
                    <div className="text-xs text-gray-500">{fmtJPY(r.jpy.totalPerUnit)}</div>
                  </td>
                  <td className="px-3 py-2">{r.packageNumber ?? '—'}</td>
                  <td className="px-3 py-2">{r.purchaseDateISO ?? '—'}</td>
                </tr>
              );
            })}
          </tbody>
        </table>

        {rows.length === 0 && !busy && (
          <div className="p-6 text-center text-sm text-gray-400">No items yet.</div>
        )}

        <div className="flex items-center justify-between px-3 py-2 text-xs text-gray-400">
          <div>{rows.length} items</div>
          <button
            className="btn btn-outline"
            onClick={() => load({ cursor })}
            disabled={!cursor || busy}
          >
            {busy ? 'Loading…' : (cursor ? 'Load more' : 'No more')}
          </button>
        </div>
      </div>
    </div>
  );
}

```

---

## src/app/layout.tsx

```tsx
import './globals.css';
import type { Metadata } from 'next';
import Sidebar from '../components/Sidebar';
import { Inter } from 'next/font/google';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: process.env.NEXT_PUBLIC_APP_NAME || 'Proxy Dashboard',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" className="h-full">
      <body className={`${inter.className} h-full bg-[#0b0f16] text-gray-100 antialiased`}>
        <div className="flex min-h-screen">
          <Sidebar />
          <main className="flex-1">
            <header className="sticky top-0 z-10 border-b border-white/5 bg-[#0b0f16]/80 backdrop-blur">
              <div className="mx-auto max-w-7xl px-4 py-4">
                <h1 className="text-lg font-semibold tracking-tight">
                  {process.env.NEXT_PUBLIC_APP_NAME || 'Proxy Dashboard'}
                </h1>
              </div>
            </header>
            <div className="mx-auto max-w-7xl px-4 py-6">{children}</div>
          </main>
        </div>
      </body>
    </html>
  );
}

```

---

## src/app/page.tsx

```tsx
import { redirect } from 'next/navigation';
export default function Home() { redirect('/dashboard'); }
```

---

## src/app/scraped-packages/page.tsx

```tsx
// src/app/scraped-packages/page.tsx
import ScrapedPackagesClient from './scraped-packages.client';

export const dynamic = 'force-dynamic';

export default async function ScrapedPackagesPage({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | string[] | undefined>>;
}) {
  const sp = await searchParams; // <-- important

  const initialQuery = Object.fromEntries(
    Object.entries(sp || {}).map(([k, v]) => [k, String(v ?? '')])
  );

  return <ScrapedPackagesClient initialQuery={initialQuery} />;
}

```

---

## src/app/scraped-packages/scraped-packages.client.tsx

```tsx
'use client';
import { useEffect, useMemo, useState, useCallback } from 'react';
import ScrapedPackageCard from './ui/ScrapedPackageCard';
import ScrapedToolbar from './ui/ScrapedToolbar';
import ScrapersBar from './ui/ScrapersBar';

type ScrapedItemPreview = {
  id: string;
  title: string | null;
  listingId: string | null;
  itemUrl: string | null;
  priceYen: number | null;
};

export type ScrapedPackageRow = {
  id: string;
  source: string;
  pageUrl: string;
  dateShipped: string | null;
  packageNumber: string;
  intlTrackingNumber: string | null;
  intlTrackingUrl: string | null;
  internationalShippingFeeYen: number;
  domesticShippingFeeYen: number;
  itemsCount: number;
  items: ScrapedItemPreview[];
  status: 'Todo' | 'Processed' | 'Blacklist';
};

export default function ScrapedPackagesClient({ initialQuery }: { initialQuery: Record<string,string> }) {
  const [q, setQ] = useState(initialQuery.q || '');
  const [source, setSource] = useState(initialQuery.source || '');
  const [sort, setSort] = useState((initialQuery.sort as any) || 'date_desc');
  const [status, setStatus] = useState(initialQuery.status || '');
  const [data, setData] = useState<ScrapedPackageRow[] | null>(null);
  const [loading, setLoading] = useState(false);

  // block refetches while a run is happening
  const [isRunning, setIsRunning] = useState(false);

  const params = useMemo(() => {
    const sp = new URLSearchParams();
    if (q) sp.set('q', q);
    if (source) sp.set('source', source);
    if (status) sp.set('status', status);
    if (sort) sp.set('sort', sort);
    return sp.toString();
  }, [q, source, status, sort]);

  const load = useCallback(async () => {
    setLoading(true);
    try {
      const r = await fetch(`/api/scraped-packages?${params}`);
      const j = await r.json();
      setData(j);
    } finally {
      setLoading(false);
    }
  }, [params]);

  // normal refetch on params change, but NOT while a run is happening
  useEffect(() => {
    if (!isRunning) load();
  }, [load, isRunning]);

  const handleRunStart = () => setIsRunning(true);
  const handleRunDone = async () => {
    setIsRunning(false);
    await load(); // single fetch after everything is done
  };

  return (
    <div className="space-y-4">
      <ScrapersBar onRunStart={handleRunStart} onRunDone={handleRunDone} />

      <ScrapedToolbar
        q={q} onQ={setQ}
        source={source} onSource={setSource}
        status={status} onStatus={setStatus}
        sort={sort as any} onSort={setSort as any}
        loading={loading}
      />

      {!data?.length && !loading && (
        <div className="card p-8 text-center text-gray-400">No scraped packages.</div>
      )}

      <div className="cards-grid">
        {data?.map(pkg => (
          <ScrapedPackageCard key={pkg.id} pkg={pkg} />
        ))}
      </div>
    </div>
  );
}

```

---

## src/app/scraped-packages/ui/ScrapedPackageCard.tsx

```tsx
'use client';
import Link from 'next/link';
import { useMemo, useState } from 'react';
import { useRouter } from 'next/navigation';
import type { ScrapedPackageRow } from '../scraped-packages.client';

function ItemsHover({ names }: { names: string[] }) {
  const [open, setOpen] = useState(false);
  return (
    <div
      className="relative inline-flex"
      onMouseEnter={() => setOpen(true)}
      onMouseLeave={() => setOpen(false)}
    >
      <span className="cursor-default underline decoration-dotted underline-offset-4">
        Items: {names.length}
      </span>
      {open && (
        <div
          className="absolute right-0 top-full z-20 mt-2 w-72 max-w-[80vw] rounded-lg border p-2 text-xs shadow-xl"
          style={{ background: 'var(--color-surface)', borderColor: 'var(--color-border)' }}
        >
          <ul className="space-y-1">
            {names.map((n, i) => (
              <li key={i} className="text-gray-300 leading-snug">• {n}</li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

export default function ScrapedPackageCard({ pkg }: { pkg: ScrapedPackageRow }) {
  const router = useRouter();
  const itemNames = useMemo(() => pkg.items.map(i => i.title || '').filter(Boolean), [pkg.items]);

  const [status, setStatus] = useState(pkg.status);
  const [saving, setSaving] = useState(false);
  const [opening, setOpening] = useState(false);

  const isBlacklisted = status === 'Blacklist';
  const isProcessed = status === 'Processed';

  async function toggleBlacklist() {
    if (saving) return;
    setSaving(true);
    const prev = status;
    const next = isBlacklisted ? 'Todo' : 'Blacklist';
    setStatus(next); // optimistic UI

    try {
      const res = await fetch(`/api/scraped-packages/${pkg.id}/status`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status: next }),
      });
      if (!res.ok) throw new Error('save_failed');
    } catch {
      setStatus(prev); // rollback on error
    } finally {
      setSaving(false);
    }
  }

  async function openSessionForPackage() {
    if (opening) return;
    setOpening(true);
    try {
      // 1) Try to find an existing session for this package
      const findRes = await fetch(`/api/fill-sessions/by-package?packageId=${encodeURIComponent(pkg.id)}`, { cache: 'no-store' });
      if (findRes.ok) {
        const j = await findRes.json();
        router.push(`/inventory-filler?sessionId=${j.sessionId}`);
        return;
      }

      // 2) If none found and package is not Processed, create one
      if (!isProcessed) {
        const createRes = await fetch('/api/fill-sessions', {
          method: 'POST',
          body: JSON.stringify({ sourceType: 'ScrapedPackage', scrapedPackageId: pkg.id }),
        });
        const cj = await createRes.json();
        if (!createRes.ok) throw new Error(cj.error || 'Failed to create session');
        router.push(`/inventory-filler?sessionId=${cj.sessionId}`);
        return;
      }

      // 3) If Processed and still no session, inform
      alert('No existing session found for this processed package.');
    } catch (e: any) {
      alert(e?.message || 'Failed to open session');
    } finally {
      setOpening(false);
    }
  }

  return (
    <div className="card flex h-full flex-col overflow-hidden">
      {/* header */}
      <div className="flex items-center justify-between border-b px-3 py-2" style={{ borderColor: 'var(--color-border)' }}>
        <div className="text-xs uppercase tracking-wide text-gray-400">{pkg.source}</div>
        <div className="text-xs text-gray-400">{pkg.dateShipped ?? '—'}</div>
      </div>

      {/* body now fills remaining height */}
      <div className="flex flex-1 flex-col space-y-3 p-3">
        <div className="flex items-center justify-between">
          <div className="font-mono text-sm tracking-tight">{pkg.packageNumber}</div>
          <div className="text-xs text-gray-400">
            <ItemsHover names={itemNames} />
          </div>
        </div>

        {pkg.intlTrackingNumber && (
          <div className="truncate text-xs">
            <span className="text-gray-400">Tracking:</span>{' '}
            {pkg.intlTrackingUrl ? (
              <a className="text-blue-400 hover:underline" href={pkg.intlTrackingUrl} target="_blank" rel="noreferrer">
                {pkg.intlTrackingNumber}
              </a>
            ) : (
              <span className="font-mono">{pkg.intlTrackingNumber}</span>
            )}
          </div>
        )}

        {/* thumbnails */}
        <div className="grid grid-cols-3 md:grid-cols-4 gap-2">
          {pkg.items.slice(0, 8).map((it, i) => {
            const href = it.listingId
              ? `https://buyee.jp/item/jdirectitems/auction/${it.listingId}`
              : undefined;
            const img = it.listingId ? `/api/thumb/${it.listingId}` : '/placeholder-item.png';
            const el = (
              // eslint-disable-next-line @next/next/no-img-element
              <img
                src={img}
                alt={it.title || ''}
                className="h-full w-full object-cover"
                loading={i > 1 ? 'lazy' : undefined}
              />
            );
            return (
              <div
                key={it.id}
                className="relative aspect-square overflow-hidden rounded-md ring-1"
                style={{ background: '#0f1522', borderColor: 'transparent', boxShadow: 'inset 0 0 0 1px rgba(255,255,255,.04)' }}
              >
                {href ? (
                  <a href={href} target="_blank" rel="noreferrer" title={it.title || ''}>
                    {el}
                  </a>
                ) : el}
              </div>
            );
          })}
        </div>

        {/* footer pinned to bottom */}
        <div className="mt-auto flex items-center justify-end gap-2 pt-1">
          <button
            onClick={toggleBlacklist}
            disabled={saving}
            className={
              isBlacklisted
                ? 'btn bg-red-600 hover:bg-red-500 disabled:opacity-50'
                : 'btn disabled:opacity-50'
            }
            title={isBlacklisted ? 'Click to unblacklist (back to To-do)' : 'Blacklist this package'}
          >
            {isBlacklisted ? 'Blacklisted' : 'Blacklist'}
          </button>

          <button
            onClick={openSessionForPackage}
            disabled={opening}
            className="btn btn-success cursor-pointer disabled:opacity-50"
            title={isProcessed ? 'View existing fill session' : 'Start or resume fill session'}
          >
            {isProcessed ? 'View session' : 'Proceed'}
          </button>
        </div>
      </div>
    </div>
  );
}

```

---

## src/app/scraped-packages/ui/ScrapedToolbar.tsx

```tsx
'use client';

export default function ScrapedToolbar({
  q, onQ, source, onSource, status, onStatus, sort, onSort, loading,
}: {
  q: string; onQ: (v: string) => void;
  source: string; onSource: (v: string) => void;
  status: string; onStatus: (v: string) => void;
  sort: 'date_desc'|'date_asc'|'intl_desc'|'intl_asc'|'dom_desc'|'dom_asc'|'items_desc'|'items_asc';
  onSort: (v: any) => void;
  loading: boolean;
}) {
  return (
    <div className="card p-3">
      <div className="flex flex-col gap-3 sm:flex-row sm:items-center">
        <input
          value={q}
          onChange={e => onQ(e.target.value)}
          placeholder="Search package #, tracking, title, listing id…"
          className="field flex-1"
        />
        <select value={source} onChange={e=>onSource(e.target.value)} className="field">
          <option value="">All proxies</option>
          <option value="zenmarket">zenmarket</option>
          <option value="buyee">buyee</option>
          <option value="fromjapan">fromjapan</option>
        </select>
        <select value={status} onChange={e=>onStatus(e.target.value)} className="field">
          <option value="">All</option>
          <option value="todo">To process</option>
          <option value="processed">Processed</option>
          <option value="blacklisted">Blacklisted</option>
        </select>
        <select value={sort} onChange={e=>onSort(e.target.value as any)} className="field">
          <option value="date_desc">Date ↓</option>
          <option value="date_asc">Date ↑</option>
          <option value="items_desc">Items ↓</option>
          <option value="items_asc">Items ↑</option>
        </select>
        <button disabled={loading} className="btn btn-outline disabled:opacity-50">
          {loading ? 'Loading…' : 'Refresh'}
        </button>
      </div>
    </div>
  );
}

```

---

## src/app/scraped-packages/ui/ScrapersBar.tsx

```tsx
'use client';

import { useState } from 'react';

type Props = {
  onRunStart?: () => void;
  onRunDone?: () => void; // called exactly once after confirm+scrape finishes
};

async function post(url: string, body: any) {
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body ?? {}),
  });
  const json = await res.json().catch(() => ({}));
  return { ok: res.ok, json };
}

export default function ScrapersBar({ onRunStart, onRunDone }: Props) {
  const [maxPages, setMaxPages] = useState<number>(9999);
  const [zmUrl, setZmUrl] = useState<string>('https://zenmarket.jp/fr/profile/parcel.aspx?state=5');
  const [busy, setBusy] = useState<null | 'buyee' | 'fromjapan' | 'zenmarket'>(null);
  const [phase, setPhase] = useState<'idle'|'waiting'|'running'|'done'>('idle');
  const [current, setCurrent] = useState<null | 'buyee' | 'fromjapan' | 'zenmarket'>(null);
  const [msg, setMsg] = useState('');

  const endpoints = {
    buyee:     '/api/scrape/buyee-crawl',
    fromjapan: '/api/scrape/fromjapan-crawl',
    zenmarket: '/api/scrape/zenmarket-crawl',
  } as const;

  const payloadFor = (src: 'buyee'|'fromjapan'|'zenmarket') =>
    src === 'zenmarket' ? { pageUrl: zmUrl } : { startPage: 1, maxPages: Math.max(1, Number(maxPages) || 1) };

  const start = async (src: 'buyee'|'fromjapan'|'zenmarket') => {
    if (busy) return;
    onRunStart?.();                 // 🔹 mark running (prevents page refetch)
    setBusy(src); setCurrent(src); setMsg('Starting profile refresh…'); setPhase('waiting');

    const s = await post('/api/profile/refresh/start', { source: src });
    if (!s.ok) {
      setMsg(`Failed to start refresh: ${s.json?.error || 'error'}`);
      setBusy(null); setPhase('idle');
      onRunDone?.();                // unblock UI despite failure
      return;
    }
    setMsg('Profile refresh running. Complete login in the opened window, then click Confirm.');
  };

  const confirm = async () => {
    const src = current!;
    setMsg('Confirming refresh…');
    const c = await post('/api/profile/refresh/confirm', { source: src });
    if (!c.ok || !c.json?.ok) {
      setMsg(`Refresh confirm failed${c.json?.code !== undefined ? ` (code ${c.json.code})` : ''}.`);
      setBusy(null); setPhase('idle');
      onRunDone?.();
      return;
    }
    // 2) run scraper
    setPhase('running'); setMsg('Running scraper…');
    const run = await post(endpoints[src], payloadFor(src));

    if (run.ok && (run.json?.ok ?? true)) {
      setMsg('Done.'); setPhase('done');
    } else {
      setMsg(`Scraper failed${run.json?.error ? ` — ${run.json.error}` : ''}.`);
      setPhase('idle');
    }

    setBusy(null);
    onRunDone?.();                  // 🔹 fetch once now that we’re done
  };

  return (
    <div className="card p-3">
      <div className="flex flex-col gap-3 xl:flex-row xl:items-center">
        <div className="flex flex-1 items-center gap-2">
          <label className="text-xs text-gray-400 min-w-[6rem]">ZenMarket URL</label>
          <input className="field w-full" value={zmUrl} onChange={e => setZmUrl(e.target.value)} spellCheck={false}/>
        </div>
        <div className="flex items-center gap-2">
          <label className="text-xs text-gray-400">Max pages</label>
          <input type="number" min={1} className="field w-24"
                 value={maxPages} onChange={e => setMaxPages(Number(e.target.value || 1))}/>
        </div>
        <div className="flex flex-wrap items-center gap-2">
          <button className="btn btn-outline disabled:opacity-50" disabled={!!busy} onClick={() => start('buyee')}>
            {busy === 'buyee' && phase !== 'idle' ? 'Buyee…' : 'Refresh+Run Buyee'}
          </button>
          <button className="btn btn-outline disabled:opacity-50" disabled={!!busy} onClick={() => start('fromjapan')}>
            {busy === 'fromjapan' && phase !== 'idle' ? 'FromJapan…' : 'Refresh+Run FromJapan'}
          </button>
          <button className="btn btn-outline disabled:opacity-50" disabled={!!busy} onClick={() => start('zenmarket')}>
            {busy === 'zenmarket' && phase !== 'idle' ? 'ZenMarket…' : 'Refresh+Run ZenMarket'}
          </button>
          {phase === 'waiting' && (
            <button className="btn btn-primary" onClick={confirm}>I’ve logged in — Confirm</button>
          )}
        </div>
      </div>
      {msg && <div className="hr mt-3 pt-3 text-xs text-gray-400">{msg}</div>}
    </div>
  );
}

```

---

## src/app/tags/page.tsx

```tsx
// src/app/tags/page.tsx
export const dynamic = 'force-dynamic';

import TagsClient from './tags.client';

export default function TagsPage() {
  return <TagsClient />;
}

```

---

## src/app/tags/tags.client.tsx

```tsx
'use client';

import { useEffect, useMemo, useState } from 'react';

type TagNode = {
  placementId: string;
  tagId: string;
  name: string;
  description: string | null;
  parentPlacementId: string | null;
  children: TagNode[];
};

type TreePayload = {
  tree: TagNode[];
  parentCounts: Record<string, number>; // number of placements per tagId
  tags: Array<{ id: string; name: string; description: string | null }>;
};

async function fetchTreePayload(): Promise<TreePayload> {
  const res = await fetch('/api/tags?format=tree', { cache: 'no-store' });
  if (!res.ok) throw new Error('Failed to load tags');
  return res.json();
}

async function apiCreate(payload: { name: string; description?: string; parentPlacementId?: string | null }) {
  const res = await fetch('/api/tags', { method: 'POST', body: JSON.stringify(payload) });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error || 'Create failed');
  return data.placement as { id: string; tagId: string; parentPlacementId: string | null };
}
async function apiDeletePlacement(placementId: string) {
  const res = await fetch('/api/tags', { method: 'DELETE', body: JSON.stringify({ placementId }) });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error || 'Delete failed');
  return data as { ok: true; deletedPlacement: boolean; deletedTag: boolean };
}
async function apiPatchTag(payload: { tagId: string; name?: string; description?: string }) {
  const res = await fetch('/api/tags', { method: 'PATCH', body: JSON.stringify(payload) });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error || 'Update failed');
  return data.tag as { id: string; name: string; description: string | null };
}

export default function TagsClient() {
  const [tree, setTree] = useState<TagNode[] | null>(null);
  const [parentCounts, setParentCounts] = useState<Record<string, number>>({});
  const [nameIndex, setNameIndex] = useState<Map<string, string>>(new Map()); // lower(name) -> tagId
  const [expanded, setExpanded] = useState<Record<string, boolean>>({});
  const [selectedPlacementId, setSelectedPlacementId] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  const selected = useMemo(() => {
    if (!tree || !selectedPlacementId) return null;
    const stack = [...tree];
    while (stack.length) {
      const n = stack.pop()!;
      if (n.placementId === selectedPlacementId) return n;
      stack.push(...n.children);
    }
    return null;
  }, [tree, selectedPlacementId]);

  // helpers
  function idsInTree(nodes: TagNode[]): Set<string> {
    const s = new Set<string>();
    const st = [...nodes];
    while (st.length) {
      const n = st.pop()!;
      s.add(n.placementId);
      for (const c of n.children) st.push(c);
    }
    return s;
  }
  function findPath(nodes: TagNode[], targetPid: string): string[] | null {
    const stack: Array<{ node: TagNode; path: string[] }> = nodes.map(n => ({ node: n, path: [n.placementId] }));
    while (stack.length) {
      const { node, path } = stack.pop()!;
      if (node.placementId === targetPid) return path;
      for (const c of node.children) stack.push({ node: c, path: [...path, c.placementId] });
    }
    return null;
  }

  async function load(opts?: { preserveExpanded?: boolean; ensureExpandedPids?: string[]; selectPid?: string | null }) {
    setLoading(true);
    setErr(null);
    try {
      const payload = await fetchTreePayload();
      setTree(payload.tree);
      setParentCounts(payload.parentCounts || {});

      const idx = new Map<string, string>();
      for (const t of payload.tags || []) idx.set(t.name.toLowerCase(), t.id);
      setNameIndex(idx);

      const next: Record<string, boolean> = {};
      const existing = idsInTree(payload.tree);

      if (opts?.preserveExpanded) {
        for (const pid of Object.keys(expanded)) if (expanded[pid] && existing.has(pid)) next[pid] = true;
      } else {
        for (const r of payload.tree) next[r.placementId] = true; // expand roots initially
      }

      if (opts?.ensureExpandedPids) {
        for (const pid of opts.ensureExpandedPids) {
          const path = pid ? findPath(payload.tree, pid) : null;
          if (path) for (const anc of path.slice(0, -1)) next[anc] = true;
        }
      }

      setExpanded(next);

      if (opts?.selectPid !== undefined) {
        setSelectedPlacementId(opts.selectPid);
      } else if (selectedPlacementId && existing.has(selectedPlacementId)) {
        setSelectedPlacementId(selectedPlacementId);
      } else {
        setSelectedPlacementId(null);
      }
    } catch (e: any) {
      setErr(e.message || 'Load failed');
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    load({ preserveExpanded: false });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Top + : create root placement (new tag or existing by name warning)
  const addRoot = async () => {
    const raw = prompt('New root tag name:');
    const name = (raw || '').trim();
    if (!name) return;

    // If a tag already exists with this name, we still create a placement at root (link).
    try {
      const placement = await apiCreate({ name, parentPlacementId: null });
      await load({ preserveExpanded: true, ensureExpandedPids: [placement.id], selectPid: placement.id });
    } catch (e: any) {
      alert(e.message || 'Create failed');
    }
  };

  // + on a node: link existing by name or create new tag + placement — scoped to this branch
  const addChild = async (parent: TagNode) => {
    const raw = prompt(`Add under “${parent.name}”:\nEnter tag name (links if it already exists):`);
    const name = (raw || '').trim();
    if (!name) return;

    try {
      const placement = await apiCreate({ name, parentPlacementId: parent.placementId });
      await load({ preserveExpanded: true, ensureExpandedPids: [parent.placementId, placement.id], selectPid: placement.id });
    } catch (e: any) {
      alert(e.message || 'Add failed');
    }
  };

  // Delete placement. If it was the last placement of that tag and it's unused, server deletes the tag as well.
  const deleteNode = async (node: TagNode) => {
    const placementsForTag = parentCounts[node.tagId] ?? 0;
    const msg = placementsForTag > 1
      ? `Unlink “${node.name}” from this branch?`
      : `Delete “${node.name}” entirely? (It is not used elsewhere)`;
    if (!confirm(msg)) return;

    try {
      await apiDeletePlacement(node.placementId);
      const anchor = node.parentPlacementId ?? null;
      await load({ preserveExpanded: true, ensureExpandedPids: anchor ? [anchor] : [], selectPid: anchor });
    } catch (e: any) {
      alert(e.message || 'Delete failed');
    }
  };

  const saveDetails = async (payload: { name?: string; description?: string | null }) => {
    if (!selected) return;
    try {
      await apiPatchTag({ tagId: selected.tagId, ...payload });
      await load({ preserveExpanded: true, ensureExpandedPids: [selected.placementId], selectPid: selected.placementId });
    } catch (e: any) {
      alert(e.message || 'Save failed');
    }
  };

  return (
    <div>
      {/* Toolbar */}
      <div className="card p-3 mb-5">
        <div className="flex items-center gap-3">
          <div className="text-sm text-gray-400 flex-1">
            Add with <span className="font-medium">+</span> (links by name or creates new), delete removes this placement. Actions appear on row hover.
          </div>
          <button onClick={addRoot} className="btn btn-outline" title="Create root tag">+</button>
        </div>
      </div>

      {err && <div className="card p-3 mb-5 text-red-300">{err}</div>}
      {loading && <div className="card p-6 mb-5 text-gray-300">Loading…</div>}

      {!loading && tree && (
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-5">
          {/* Tree */}
          <div className="lg:col-span-2 card p-3">
            {tree.length === 0 ? (
              <div className="p-6 text-center text-gray-400">No tags yet. Use the + button to create your first root tag.</div>
            ) : (
              <ul className="space-y-1">
                {tree.map(n => (
                  <TreeNode
                    key={n.placementId}
                    node={n}
                    parentCounts={parentCounts}
                    expanded={expanded}
                    setExpanded={setExpanded}
                    selectedPlacementId={selectedPlacementId}
                    setSelectedPlacementId={setSelectedPlacementId}
                    onAddChild={addChild}
                    onDelete={deleteNode}
                  />
                ))}
              </ul>
            )}
          </div>

          {/* Details */}
          <div className="card p-3">
            <h2 className="text-sm font-semibold mb-3">Details</h2>
            {!selected ? (
              <div className="text-gray-400">Select a tag to view/edit.</div>
            ) : (
              <DetailsForm
                key={selected.placementId}
                node={selected}
                onSave={saveDetails}
              />
            )}
          </div>
        </div>
      )}
    </div>
  );
}

function TreeNode(props: {
  node: TagNode;
  parentCounts: Record<string, number>;
  expanded: Record<string, boolean>;
  setExpanded: React.Dispatch<React.SetStateAction<Record<string, boolean>>>;
  selectedPlacementId: string | null;
  setSelectedPlacementId: (pid: string) => void;
  onAddChild: (node: TagNode) => void;
  onDelete: (node: TagNode) => void;
}) {
  const { node, parentCounts, expanded, setExpanded, selectedPlacementId } = props;
  const isOpen = !!expanded[node.placementId];
  const hasChildren = node.children.length > 0;
  const isLinked = (parentCounts[node.tagId] ?? 0) > 1;

  return (
    <li>
      <div
        className={[
          'relative flex items-center gap-2 px-2 py-1 rounded-lg group/row',
          selectedPlacementId === node.placementId ? 'bg-white/10 border border-white/10' : 'hover:bg-white/5',
        ].join(' ')}
      >
        <button
          onClick={() => hasChildren && setExpanded(e => ({ ...e, [node.placementId]: !isOpen }))}
          className={[
            'h-6 w-6 grid place-items-center rounded-md border',
            hasChildren ? 'opacity-100' : 'opacity-40',
          ].join(' ')}
          style={{ borderColor: 'var(--color-border)' }}
          title={hasChildren ? (isOpen ? 'Collapse' : 'Expand') : 'No children'}
        >
          {hasChildren ? (isOpen ? '–' : '+') : '•'}
        </button>

        <button onClick={() => props.setSelectedPlacementId(node.placementId)} className="flex-1 text-left">
          <div className="font-medium flex items-center gap-1">
            <span>{node.name}</span>
            {isLinked && <span title="Tag appears in multiple branches">🔗</span>}
          </div>
          {node.description && <div className="text-xs text-gray-400">{node.description}</div>}
        </button>

        {/* Row-only hover actions */}
        <div className="absolute right-2 top-1/2 -translate-y-1/2 hidden gap-1 group-hover/row:flex">
          <button onClick={() => props.onAddChild(node)} className="btn btn-outline text-xs" title="Add child">+</button>
          <button onClick={() => props.onDelete(node)} className="btn btn-outline text-xs" title="Delete placement">🗑️</button>
        </div>
      </div>

      {hasChildren && isOpen && (
        <ul className="pl-6 mt-1 space-y-1">
          {node.children.map(c => (
            <TreeNode
              key={c.placementId}
              node={c}
              parentCounts={parentCounts}
              expanded={expanded}
              setExpanded={setExpanded}
              selectedPlacementId={selectedPlacementId}
              setSelectedPlacementId={props.setSelectedPlacementId}
              onAddChild={props.onAddChild}
              onDelete={props.onDelete}
            />
          ))}
        </ul>
      )}
    </li>
  );
}

function DetailsForm(props: {
  node: TagNode;
  onSave: (payload: { name?: string; description?: string | null }) => Promise<void>;
}) {
  const [name, setName] = useState(props.node.name);
  const [description, setDescription] = useState(props.node.description ?? '');
  const [saving, setSaving] = useState(false);
  const [msg, setMsg] = useState<string | null>(null);

  useEffect(() => {
    setName(props.node.name);
    setDescription(props.node.description ?? '');
  }, [props.node.tagId, props.node.name, props.node.description]);

  const save = async () => {
    setSaving(true);
    setMsg(null);
    try {
      await props.onSave({ name, description: description || null });
      setMsg('Saved.');
    } catch (e: any) {
      setMsg(e.message || 'Save failed');
    } finally {
      setSaving(false);
      setTimeout(() => setMsg(null), 1500);
    }
  };

  return (
    <div className="space-y-3">
      <div>
        <label className="block text-xs text-gray-400">Name</label>
        <input className="field mt-1 w-full" value={name} onChange={e => setName(e.target.value)} />
      </div>
      <div>
        <label className="block text-xs text-gray-400">Description</label>
        <textarea className="field mt-1 w-full min-h-[96px]" value={description} onChange={e => setDescription(e.target.value)} />
      </div>
      <div className="flex items-center gap-2">
        <button onClick={save} disabled={saving} className="btn btn-outline disabled:opacity-50">
          {saving ? 'Saving…' : 'Save changes'}
        </button>
        {msg && <span className="text-sm text-gray-400">{msg}</span>}
      </div>
      <div className="text-xs text-gray-500">
        Tag ID: <span className="font-mono">{props.node.tagId}</span> · Placement ID: <span className="font-mono">{props.node.placementId}</span>
      </div>
    </div>
  );
}

```

---

## src/components/AppShell.tsx

```tsx
// components/AppShell.tsx
'use client';

import { useState } from 'react';
import Sidebar from './Sidebar';

export default function AppShell({ children }: { children: React.ReactNode }) {
  const [open, setOpen] = useState(false);

  return (
    // On desktop we reserve a sidebar column; on mobile it's a single column
    <div className="min-h-screen lg:grid lg:grid-cols-[16rem_1fr]">
      <Sidebar open={open} onClose={() => setOpen(false)} />

      <div className="flex min-h-screen flex-col">
        <header className="sticky top-0 z-20 border-b border-gray-900 bg-gray-950/80 backdrop-blur">
          <div className="mx-auto max-w-7xl px-4 py-4 flex items-center gap-3">
            {/* mobile toggle only */}
            <button
              className="inline-flex h-9 w-9 items-center justify-center rounded-md border border-gray-800 bg-gray-900 text-gray-200 hover:bg-gray-800 lg:hidden"
              onClick={() => setOpen(v => !v)}
              aria-label="Toggle navigation"
            >
              ☰
            </button>
            <h1 className="text-lg font-semibold">
              {process.env.NEXT_PUBLIC_APP_NAME || 'Proxy Dashboard'}
            </h1>
          </div>
        </header>

        <main className="mx-auto max-w-7xl flex-1 px-4 py-6 min-w-0">
          {children}
        </main>
      </div>
    </div>
  );
}

```

---

## src/components/Sidebar.tsx

```tsx
// src/components/Sidebar.tsx
import Link from 'next/link';
// import { usePathname } from 'next/navigation'; // if you later want active states

export default function Sidebar() {
  return (
    <aside className="w-64 border-r border-white/5 bg-[#0b0f16] p-3">
      <div className="mb-3 px-2">
        <div className="text-xs uppercase tracking-wide text-gray-500">Navigation</div>
      </div>

      <nav className="space-y-1">
        <Link href="/dashboard" className="block px-2">
          <div className="group flex items-center gap-3 rounded-lg px-3 py-2 text-sm text-gray-300 hover:bg-white/5">
            <span>🏠</span><span>Dashboard</span>
          </div>
        </Link>

        <Link href="/scraped-packages" className="block px-2">
          <div className="group flex items-center gap-3 rounded-lg px-3 py-2 text-sm text-gray-300 hover:bg-white/5">
            <span>📦</span><span>Scraped Packages</span>
          </div>
        </Link>

        <Link href="/tags" className="block px-2">
          <div className="group flex items-center gap-3 rounded-lg px-3 py-2 text-sm text-gray-300 hover:bg-white/5">
            <span>🏷️</span><span>Tags</span>
          </div>
        </Link>
<Link href="/inventory-filler" className="block px-2">
          <div className="group flex items-center gap-3 rounded-lg px-3 py-2 text-sm text-gray-300 hover:bg-white/5">
            <span>🧮</span><span>Inventory filler</span>
          </div>
        </Link>
        {/* New: Inventory list */}
        <Link href="/inventory" className="block px-2">
          <div className="group flex items-center gap-3 rounded-lg px-3 py-2 text-sm text-gray-300 hover:bg-white/5">
            <span>📋</span><span>Inventory</span>
          </div>
        </Link>

        {/* Inventory filler (manual entry) — different icon from Scraped Packages */}
        
      </nav>
    </aside>
  );
}

```

---

## src/components/SingleTagPicker.tsx

```tsx
// src/components/SingleTagPicker.tsx
'use client';

import { useEffect, useMemo, useRef, useState } from 'react';

type TagFlat = { id: string; name: string; description?: string | null };

// Normalized node shape for the tree
type TagNode = {
  tagId: string;               // ALWAYS the tag id
  name: string;
  description?: string | null;
  placementKey: string;        // unique per placement/path (for React keys)
  placementId?: string;        // TagPlacement.id if available
  children?: TagNode[];
};

export default function SingleTagPicker({
  value,
  onChange,
  allTags,
  disabled,
}: {
  value: string | null | undefined;
  onChange: (sel: { tagId: string | null; placementId: string | null }) => void;
  allTags?: TagFlat[]; // optional; will self-fetch if absent
  disabled?: boolean;
}) {
  const [q, setQ] = useState('');
  const [tree, setTree] = useState<TagNode[] | null>(null);
  const [loadingTree, setLoadingTree] = useState(false);
  const [showTree, setShowTree] = useState(false);                   // 👈 restored modal state
  const [expanded, setExpanded] = useState<Record<string, boolean>>({}); // tree expand state

  // Local flat tags if parent didn't provide any
  const [localTags, setLocalTags] = useState<TagFlat[] | null>(null);
  const [loadingTags, setLoadingTags] = useState(false);

  // Remember exact branch chosen
  const [selectedPath, setSelectedPath] = useState<{ tagId: string; labels: string[] } | null>(null);

  // Suggestions dropdown
  const inputWrapRef = useRef<HTMLDivElement>(null);
  const [showSuggestions, setShowSuggestions] = useState(false);

  // Branch chooser for ambiguous picks (multiple placements)
  const [branchChoices, setBranchChoices] = useState<{
    tagId: string;
    options: { placementId: string | null; labels: string[] }[];
  } | null>(null);

  // Effective flat tags
  const effectiveTags: TagFlat[] = useMemo(() => {
    if (Array.isArray(allTags) && allTags.length) return allTags;
    return Array.isArray(localTags) ? localTags : [];
  }, [allTags, localTags]);

  // Fetch flat tags if not provided
  useEffect(() => {
    if (Array.isArray(allTags) && allTags.length) return;
    if (localTags !== null) return;
    (async () => {
      try {
        setLoadingTags(true);
        const r = await fetch('/api/tags?format=flat', { cache: 'no-store' });
        const j = await r.json();
        setLocalTags(Array.isArray(j.tags) ? j.tags : []);
      } catch {
        setLocalTags([]);
      } finally {
        setLoadingTags(false);
      }
    })();
  }, [allTags, localTags]);

  // Close suggestions on outside click
  useEffect(() => {
    const onDoc = (e: MouseEvent) => {
      if (!inputWrapRef.current) return;
      if (!inputWrapRef.current.contains(e.target as Node)) setShowSuggestions(false);
    };
    document.addEventListener('mousedown', onDoc);
    return () => document.removeEventListener('mousedown', onDoc);
  }, []);

  // If parent clears value, clear path memory
  useEffect(() => {
    if (!value) setSelectedPath(null);
  }, [value]);

  // Ensure we have the tree (optionally open modal immediately)
  async function ensureTree(openModal = false): Promise<TagNode[] | null> {
    if (tree) {
      if (openModal) setShowTree(true);
      return tree;
    }
    try {
      setLoadingTree(true);
      const res = await fetch('/api/tags?format=tree', { cache: 'no-store' });
      const j = await res.json();
      const raw = (j.tree || j.tags || []) as any[];
      const norm = normalizeTree(raw, 'root');
      setTree(norm);
      if (openModal) setShowTree(true);          // 👈 open modal after load
      return norm;
    } catch {
      return null;
    } finally {
      setLoadingTree(false);
    }
  }

  // Load tree silently when we already have a selected value (for path fallback)
  useEffect(() => {
    if (!value || tree || loadingTree) return;
    void ensureTree(false);
  }, [value, tree, loadingTree]);

  // Fallback path if selection came from outside OR no stored path for this tag
  const fallbackPath = useMemo(() => {
    if (!value || !tree) return null;
    if (selectedPath && selectedPath.tagId === value) return null;
    return findPathLabelsByTagId(tree, value);
  }, [value, tree, selectedPath]);

  const selectedObj = value ? effectiveTags.find(t => t.id === value) : undefined;
  const selectedName = useMemo(() => {
    if (selectedPath && selectedPath.tagId === value) {
      const labels = selectedPath.labels;
      return labels[labels.length - 1];
    }
    if (selectedObj) return selectedObj.name;
    if (fallbackPath?.length) return fallbackPath[fallbackPath.length - 1];
    return value ?? undefined;
  }, [selectedPath, value, selectedObj, fallbackPath]);

  // Suggestions list
  const suggestions = useMemo(() => {
    const s = q.trim().toLowerCase();
    if (!s) return [] as TagFlat[];
    return effectiveTags.filter(t => t.name.toLowerCase().includes(s)).slice(0, 20);
  }, [q, effectiveTags]);

  // Pick from suggestions
  async function pickFromSuggestions(tagId: string) {
    const t = await ensureTree(false);
    if (!t) {
      onChange({ tagId, placementId: null });
      setSelectedPath(null);
      setShowSuggestions(false);
      return;
    }
    const placements = collectPlacementsByTagId(t, tagId);
    if (placements.length <= 1) {
      const only = placements[0] ?? { placementId: null, labels: [selectedObj?.name ?? tagId] };
      onChange({ tagId, placementId: only.placementId });
      setSelectedPath({ tagId, labels: only.labels });
      setShowSuggestions(false);
    } else {
      setBranchChoices({ tagId, options: placements });
      setShowSuggestions(false);
    }
  }

  return (
    <div className="w-full">
      {/* Selected pill */}
      <div className="mb-2">
        {value ? (
          <span className="px-2 py-1 rounded bg-white/10 text-xs">
            {selectedName ?? value}
            {!disabled && (
              <button
                className="ml-2 opacity-70 hover:opacity-100"
                onClick={() => { onChange({ tagId: null, placementId: null }); setSelectedPath(null); }}
              >
                ×
              </button>
            )}
          </span>
        ) : (
          <span className="text-xs text-gray-400">No tag selected</span>
        )}
      </div>

      {/* Input + suggestions + browse */}
      <div className="flex gap-2">
        <div className="relative flex-1" ref={inputWrapRef}>
          <input
            className="field w-full"
            placeholder={loadingTags ? 'Loading tags…' : 'Type to search tags…'}
            value={q}
            onChange={e => { setQ(e.target.value); setShowSuggestions(true); }}
            onFocus={() => suggestions.length && setShowSuggestions(true)}
            disabled={disabled || loadingTags}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && suggestions.length > 0) {
                e.preventDefault();
                void pickFromSuggestions(suggestions[0].id);
              }
              if (e.key === 'Escape') setShowSuggestions(false);
            }}
          />
          {showSuggestions && suggestions.length > 0 && (
            <div className="absolute left-0 right-0 top-full z-50 mt-1 rounded-lg border border-white/10 bg-[#0b0f16] shadow-xl overflow-hidden">
              {suggestions.map((t) => (
                <button
                  key={t.id}
                  className="w-full text-left px-3 py-2 hover:bg-white/5 flex items-center justify-between"
                  onClick={() => void pickFromSuggestions(t.id)}
                  disabled={disabled}
                  title={t.description || ''}
                >
                  <span className="text-sm">{t.name}</span>
                  <span className="text-xs text-gray-400">select</span>
                </button>
              ))}
            </div>
          )}
        </div>

        <button
          className="btn btn-outline"
          onClick={() => void ensureTree(true)}         // 👈 open modal
          disabled={disabled || loadingTree}
          title="Browse full hierarchy"
        >
          {loadingTree ? 'Loading…' : 'Browse tree…'}
        </button>
      </div>

      {/* Selected tag full path */}
      <div className="mt-2 text-xs text-gray-300 min-h-[1.5rem]">
        {value ? (
          selectedPath && selectedPath.tagId === value ? (
            <span>Path: {selectedPath.labels.join(' › ')}</span>
          ) : tree ? (
            fallbackPath?.length ? (
              <span>Path: {fallbackPath.join(' › ')}</span>
            ) : (
              <span className="text-gray-500">This tag may exist in multiple branches. Use the tree to pick an exact branch.</span>
            )
          ) : (
            <span className="text-gray-500">Path will appear once the tree is loaded.</span>
          )
        ) : (
          <span className="text-gray-500">Pick a tag to see its full path.</span>
        )}
      </div>

      {/* Tree modal (restored) */}
      {showTree && (
        <div className="fixed inset-0 z-50 grid place-items-center bg-black/60 p-4" onClick={() => setShowTree(false)}>
          <div className="card w-full max-w-3xl p-4" onClick={e => e.stopPropagation()}>
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold">Pick a tag</div>
              <button className="btn btn-outline text-xs" onClick={() => setShowTree(false)}>Close</button>
            </div>
            <div className="max-h-[65vh] overflow-auto">
              {tree ? (
                <Tree
                  nodes={tree}
                  expanded={expanded}
                  onToggle={(k) => setExpanded(e => ({ ...e, [k]: !e[k] }))}
                  onPick={(tagId, pathLabels, placementId) => {
                    setSelectedPath({ tagId, labels: pathLabels });
                    onChange({ tagId, placementId: placementId ?? null });
                    setShowTree(false);
                  }}
                  parentKey="root"
                  parentPathLabels={[]} // start empty
                  query={q} // reuse the input text to filter inside modal
                />
              ) : (
                <div className="text-sm text-gray-400">Loading…</div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Branch chooser (if a tag has multiple placements) */}
      {branchChoices && (
        <div className="fixed inset-0 z-50 grid place-items-center bg-black/60 p-4" onClick={() => setBranchChoices(null)}>
          <div className="card w-full max-w-xl p-4" onClick={e => e.stopPropagation()}>
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold">Choose branch</div>
              <button className="btn btn-outline text-xs" onClick={() => setBranchChoices(null)}>Close</button>
            </div>
            <div className="space-y-2 max-h-[60vh] overflow-auto">
              {branchChoices.options.map((opt, i) => (
                <button
                  key={`${opt.placementId ?? 'none'}#${i}`}
                  className="w-full text-left px-3 py-2 hover:bg-white/5 rounded-md border border-white/10"
                  onClick={() => {
                    onChange({ tagId: branchChoices.tagId, placementId: opt.placementId });
                    setSelectedPath({ tagId: branchChoices.tagId, labels: opt.labels });
                    setBranchChoices(null);
                  }}
                >
                  {opt.labels.join(' › ')}
                </button>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

/* ---------- helpers ---------- */

function normalizeTree(rawNodes: any[], parentKey: string): TagNode[] {
  return (rawNodes || []).map((node, idx) => {
    const tagId: string =
      node.tagId ??
      node.tag?.id ??
      node.tag_id ??
      node.tagID ??
      node.id; // fallback

    const name: string =
      node.name ??
      node.tag?.name ??
      node.title ??
      node.label ??
      '(untitled)';

    const description: string | null | undefined =
      node.description ?? node.tag?.description ?? null;

    const placementId: string | undefined = node.placementId ?? node.id;
    const placementKey: string = String(placementId ?? `${tagId}-${idx}`);

    const children = normalizeTree(node.children || [], `${parentKey}/${placementKey}`);

    return { tagId, name, description, placementKey, placementId, children };
  });
}

// Find first path to tagId (labels only) — fallback only
function findPathLabelsByTagId(nodes: TagNode[], tagId: string): string[] | null {
  for (const n of nodes) {
    if (n.tagId === tagId) return [n.name];
    if (n.children?.length) {
      const down = findPathLabelsByTagId(n.children, tagId);
      if (down) return [n.name, ...down];
    }
  }
  return null;
}

// Collect all placements (paths) for a tag id
function collectPlacementsByTagId(
  nodes: TagNode[],
  tagId: string,
  parentPath: string[] = []
): { placementId: string | null; labels: string[] }[] {
  const out: { placementId: string | null; labels: string[] }[] = [];
  for (const n of nodes) {
    const path = [...parentPath, n.name];
    if (n.tagId === tagId) {
      out.push({ placementId: n.placementId ?? null, labels: path });
    }
    if (n.children?.length) {
      out.push(...collectPlacementsByTagId(n.children, tagId, path));
    }
  }
  return out;
}

/* ---------- Tree (recursive) ---------- */

function Tree({
  nodes,
  expanded,
  onToggle,
  onPick,
  parentKey,
  parentPathLabels,
  query,
}: {
  nodes: TagNode[];
  expanded: Record<string, boolean>;
  onToggle: (nodeKey: string) => void;
  onPick: (tagId: string, pathLabels: string[], placementId?: string) => void;
  parentKey: string;
  parentPathLabels: string[];
  query: string; // filter inside modal
}) {
  const filteredNodes = useMemo(() => {
    const s = query.trim().toLowerCase();
    if (!s) return nodes;
    const match = (n: TagNode): boolean =>
      n.name.toLowerCase().includes(s) || (n.children?.some(match) ?? false);
    return nodes.filter(match);
  }, [nodes, query]);

  return (
    <ul className="space-y-1">
      {filteredNodes.map((n, idx) => {
        const nodeKey = `${parentKey}/${n.placementKey}#${idx}`; // unique key per placement path
        const hasKids = !!(n.children && n.children.length);
        const open = !!expanded[nodeKey];
        const pathLabels = [...parentPathLabels, n.name];

        return (
          <li key={nodeKey}>
            <div className="flex items-center gap-2">
              {hasKids ? (
                <button
                  className="h-6 w-6 grid place-items-center rounded-md border border-white/10"
                  onClick={() => onToggle(nodeKey)}
                  title={open ? 'Collapse' : 'Expand'}
                >
                  {open ? '▾' : '▸'}
                </button>
              ) : (
                <span className="h-6 w-6 grid place-items-center text-gray-500">•</span>
              )}
              <button
                className="btn btn-outline text-xs"
                onClick={() => onPick(n.tagId, pathLabels, n.placementId)}
                title={n.description || ''}
              >
                {n.name}
              </button>
            </div>

            {hasKids && open && (
              <div className="ml-6 mt-1">
                <Tree
                  nodes={n.children!}
                  expanded={expanded}
                  onToggle={onToggle}
                  onPick={onPick}
                  parentKey={nodeKey}
                  parentPathLabels={pathLabels}
                  query={query}
                />
              </div>
            )}
          </li>
        );
      })}
    </ul>
  );
}

```

---

## src/components/WeightSliders.tsx

```tsx
// src/components/WeightSliders.tsx
'use client';

import { useMemo, useState } from 'react';
import { equalizeUnlockedPPM, normalizeWithLocksPPM, percentToPpm, ppmToPercent, setWeightAtIndexWithLocksPPM } from '@/lib/weights';

export type WeightRow = {
  id: string;
  label: string;
  ppm: number;
  locked?: boolean;
  rightHint?: React.ReactNode; // optional preview (e.g., ¥ value)
};

export default function WeightSliders(props: {
  title: string;
  rows: WeightRow[];
  onChange: (rows: WeightRow[]) => void;
  help?: string;
}) {
  const { title, help } = props;

  // Keep lock states locally (simple & ergonomic). You can lift this up if you want to persist locks.
  const [locks, setLocks] = useState<Record<string, boolean>>(() =>
    Object.fromEntries(props.rows.map(r => [r.id, !!r.locked]))
  );

  const sumPercent = useMemo(() => {
    const totalPpm = props.rows.reduce((a, r) => a + r.ppm, 0);
    return (totalPpm / 10_000).toFixed(1);
  }, [props.rows]);

  const toggleLock = (id: string) => {
    setLocks(prev => ({ ...prev, [id]: !prev[id] }));
  };

  const apply = (nextPpm: number[]) => {
    const next = props.rows.map((r, i) => ({ ...r, ppm: nextPpm[i] }));
    props.onChange(next);
  };

  const onChangeIdx = (idx: number, newPercent: number) => {
    const ppm = props.rows.map(r => r.ppm);
    const locked = props.rows.map(r => !!locks[r.id]);
    const next = setWeightAtIndexWithLocksPPM(ppm, idx, percentToPpm(newPercent), locked);
    apply(next);
  };

  const onNormalize = () => {
    const ppm = props.rows.map(r => r.ppm);
    const locked = props.rows.map(r => !!locks[r.id]);
    apply(normalizeWithLocksPPM(ppm, locked));
  };

  const onEqualize = () => {
    const ppm = props.rows.map(r => r.ppm);
    const locked = props.rows.map(r => !!locks[r.id]);
    apply(equalizeUnlockedPPM(ppm, locked));
  };

  return (
    <div className="rounded-xl border border-white/10 p-3">
      <div className="flex items-center justify-between mb-2">
        <div className="font-semibold">{title}</div>
        <div className="flex items-center gap-2">
          <span className={`text-xs ${sumPercent === '100.0' ? 'text-emerald-400' : 'text-amber-400'}`}>
            Total: {sumPercent}%
          </span>
          <button className="btn btn-outline text-xs" onClick={onEqualize}>Equalize</button>
          <button className="btn btn-outline text-xs" onClick={onNormalize}>Normalize</button>
        </div>
      </div>
      {help && <div className="text-xs text-gray-400 mb-3">{help}</div>}

      <div className="space-y-3">
        {props.rows.map((r, i) => {
          const percent = ppmToPercent(r.ppm);
          const isLocked = !!locks[r.id];
          return (
            <div key={r.id} className="grid grid-cols-12 gap-3 items-center">
              <div className="col-span-4">
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => toggleLock(r.id)}
                    className={`h-6 w-6 grid place-items-center rounded-md border ${isLocked ? 'bg-white/10' : ''}`}
                    title={isLocked ? 'Unlock' : 'Lock'}
                    style={{ borderColor: 'var(--color-border)' }}
                  >
                    {isLocked ? '🔒' : '🔓'}
                  </button>
                  <div className="font-medium truncate" title={r.label}>{r.label}</div>
                </div>
              </div>

              <div className="col-span-6">
                <input
                  type="range"
                  min={0}
                  max={1000} // 0.1% steps
                  step={1}
                  value={Math.round(percent * 10)}
                  onChange={(e) => onChangeIdx(i, Number(e.target.value) / 10)}
                  disabled={isLocked}
                  className="w-full"
                />
              </div>

              <div className="col-span-2">
                <div className="flex items-center gap-1">
                  <input
                    type="number"
                    step={0.1}
                    className="field w-20"
                    value={percent.toFixed(1)}
                    onChange={(e) => onChangeIdx(i, parseFloat(e.target.value || '0'))}
                    disabled={isLocked}
                  />
                  <span className="text-xs">% </span>
                </div>
              </div>

              {r.rightHint && <div className="col-span-12 text-right text-xs text-gray-400">{r.rightHint}</div>}
            </div>
          );
        })}
      </div>
    </div>
  );
}

```

---

## src/lib/fx.client.ts

```ts
export async function getJpyToEurRate(dateISO: string): Promise<number | null> {
  try {
    const r = await fetch(`/api/fx?date=${encodeURIComponent(dateISO)}&base=JPY&quote=EUR`, { cache: 'no-store' });
    const j = await r.json();
    if (!r.ok) {
      console.error('FX API error', j);
      return null;
    }
    const rate = typeof j.rate === 'string' ? parseFloat(j.rate) : j.rate;
    if (!isFinite(rate)) {
      console.error('FX API returned invalid rate', j);
      return null;
    }
    return rate;
  } catch (e) {
    console.error('FX fetch failed', e);
    return null;
  }
}

// Safe multiply using integers to dodge FP noise where it matters in UI
// yen is Decimal(12,2) in backend; in UI we usually have a JS number
export function yenToEuro(yen: number, rate: number | null): number {
  if (!rate || !isFinite(rate)) return 0;
  const eur = yen * rate;
  // Round to 2 decimals for display
  return Math.round(eur * 100) / 100;
}

```

---

## src/lib/prisma.ts

```ts
import { PrismaClient } from '@prisma/client';

// Prevent creating many clients in dev (Next.js hot reload)
const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: ['warn', 'error'], // add 'query' if you want verbose logs
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

---

## src/lib/refresh-runner.ts

```ts
import { spawn, ChildProcessWithoutNullStreams } from 'node:child_process';

type Source = 'buyee' | 'zenmarket' | 'fromjapan';

type ProcMap = Map<Source, ChildProcessWithoutNullStreams>;
declare global {
  // eslint-disable-next-line no-var
  var __refreshProcs__: ProcMap | undefined;
}
const procs: ProcMap = globalThis.__refreshProcs__ ?? new Map<Source, ChildProcessWithoutNullStreams>();
globalThis.__refreshProcs__ = procs;

const SCRIPT_BY_SOURCE: Record<Source, string> = {
  buyee:     'src/scripts/save-buyee-auth.ts',
  zenmarket: 'src/scripts/save-zenmarket-auth.ts',
  fromjapan: 'src/scripts/save-fromjapan-auth.ts',
};

function norm(src: string): Source {
  const s = src.toLowerCase() as Source;
  if (s !== 'buyee' && s !== 'zenmarket' && s !== 'fromjapan') throw new Error('invalid_source');
  return s;
}

export function getRunning(source: string) {
  return procs.get(norm(source));
}

export function startRefresh(source: string) {
  const s = norm(source);
  const prev = procs.get(s);
  if (prev && !prev.killed) {
    try { prev.kill('SIGTERM'); } catch {}
  }

  const script = SCRIPT_BY_SOURCE[s];
  const cmd = process.platform === 'win32' ? 'npx.cmd' : 'npx';

  const child = spawn(cmd, ['tsx', script], {
    cwd: process.cwd(),
    env: { ...process.env, FORCE_COLOR: '1' },
    stdio: ['pipe', 'pipe', 'pipe'],
    shell: true,
  });

  procs.set(s, child);

  // Optional: helpful logs in server console
  child.stdout.on('data', d => process.stdout.write(`[auth:${s}] ${d}`));
  child.stderr.on('data', d => process.stderr.write(`[auth:${s}:ERR] ${d}`));

  const cleanup = () => { if (procs.get(s) === child) procs.delete(s); };
  child.on('exit', cleanup);
  child.on('close', cleanup);

  return { pid: child.pid ?? 0 };
}

export async function confirmRefresh(source: string) {
  const s = norm(source);
  const p = procs.get(s);
  if (!p) return { ok: false, error: 'no_process' };
  try { p.stdin.write('\n'); } catch {}
  const code: number = await new Promise((resolve) => {
    const done = (c: number | null) => resolve(c ?? 0);
    p.once('exit', done);
    p.once('close', done);
  });
  return { ok: code === 0, code };
}

export function abortRefresh(source: string) {
  const s = norm(source);
  const p = procs.get(s);
  if (!p) return { ok: false };
  try { p.kill('SIGTERM'); } catch {}
  procs.delete(s);
  return { ok: true };
}

```

---

## src/lib/scrape.ts

```ts
export type BuyeeItem = {
  orderNumber: string;
  title: string;
  itemUrl: string;
  listingId?: string;
  priceYen?: number;            // from Invoice Information → Subtotal
};

export type BuyeePackage = {
  dateShipped?: string;         // YYYY-MM-DD
  intlTrackingNumber?: string;  // e.g., CL072455942JP
  intlTrackingUrl?: string;
  packageNumber?: string;       // e.g., G2505289472
  items: BuyeeItem[];
  internationalShippingFeeYen?: number;
  domesticShippingFeeYen?: number;
};

export type BuyeeShippedResult = {
  proxyName: 'buyee';
  pageUrl: string;
  packages: BuyeePackage[];
};

export function yenToNumber(txt?: string): number | undefined {
  if (!txt) return;
  const cleaned = txt
    .replace(/[^\d.,-]/g, '')
    .replace(/,(?=\d{3}(\D|$))/g, '')        // remove thousands commas
    .replace(/(\d),(?=\d{1,2}$)/, '$1.');    // 1,23 => 1.23 (safety)
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : undefined;
}
```

---

## src/lib/translate.ts

```ts
type Provider = 'deepl' | 'libre' | undefined;

export async function translateJaToEn(texts: string[]): Promise<string[]> {
  const cleaned = texts.map(t => (t || '').trim());
  if (!cleaned.length) return [];

  const provider: Provider = (process.env.TRANSLATE_PROVIDER as Provider) || undefined;
  if (!provider) return cleaned; // no-op if not configured

  if (provider === 'deepl') return deeplTranslate(cleaned);
  if (provider === 'libre') return libreTranslate(cleaned);

  return cleaned;
}

async function deeplTranslate(texts: string[]): Promise<string[]> {
  const key = process.env.DEEPL_API_KEY;
  if (!key) return texts;

  const body = new URLSearchParams();
  texts.forEach(t => body.append('text', t));
  body.append('source_lang', 'JA');
  body.append('target_lang', 'EN');

  const resp = await fetch('https://api-free.deepl.com/v2/translate', {
    method: 'POST',
    headers: {
      'Authorization': `DeepL-Auth-Key ${key}`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: body.toString(),
  });
  if (!resp.ok) return texts;

  const data: any = await resp.json();
  return (data.translations || []).map((r: any) => r.text ?? '');
}

async function libreTranslate(texts: string[]): Promise<string[]> {
  const base = process.env.LIBRE_TRANSLATE_URL || 'http://localhost:5000';
  const out: string[] = [];
  for (const t of texts) {
    const resp = await fetch(`${base}/translate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ q: t, source: 'ja', target: 'en', format: 'text' }),
    });
    if (!resp.ok) { out.push(t); continue; }
    const data: any = await resp.json();
    out.push(data.translatedText || t);
  }
  return out;
}
```

---

## src/lib/weights.ts

```ts
// src/lib/weights.ts
export const PPM_DENOM = 1_000_000; // 100%

export function percentToPpm(percent: number): number {
  if (!isFinite(percent)) return 0;
  return Math.max(0, Math.min(PPM_DENOM, Math.round(percent * 10_000)));
}

export function ppmToPercent(ppm: number): number {
  return ppm / 10_000;
}

/** Linked sliders without locks: redistribute proportionally to keep total == DENOM */
export function setWeightAtIndexPPM(ppm: number[], idx: number, newValue: number): number[] {
  return setWeightAtIndexWithLocksPPM(ppm, idx, newValue, new Array(ppm.length).fill(false));
}

/** Lock-aware redistribution (true = locked). Keeps exact sum == DENOM. */
export function setWeightAtIndexWithLocksPPM(
  ppm: number[],
  idx: number,
  newValue: number,
  locked: boolean[]
): number[] {
  const n = ppm.length;
  const clamp = (x: number) => Math.max(0, Math.min(PPM_DENOM, x | 0));

  // Treat edited row as unlocked (editing implicitly unlocks it)
  const effLocked = locked.slice();
  effLocked[idx] = false;

  const current = ppm.slice();
  const sumLocked = current.reduce((a, v, j) => a + (effLocked[j] ? v : 0), 0);

  // Available budget for unlocked rows
  const budget = PPM_DENOM - sumLocked;
  const newI = clamp(Math.min(newValue, budget)); // cannot exceed the free budget

  const unlockedOthers = [];
  let oldUnlockedOthersSum = 0;
  for (let j = 0; j < n; j++) {
    if (!effLocked[j] && j !== idx) {
      unlockedOthers.push(j);
      oldUnlockedOthersSum += current[j];
    }
  }

  const next = current.slice();
  next[idx] = newI;

  const newRema = budget - newI;

  if (unlockedOthers.length === 0) {
    // No degrees of freedom; everything else locked. Force the edited value to consume all budget.
    next[idx] = budget;
    // Sum is exact by construction.
    return next;
  }

  // Proportional scale unlocked others to fill newRema
  if (oldUnlockedOthersSum === 0) {
    // Split equally among unlocked others
    const each = Math.floor(newRema / unlockedOthers.length);
    for (const j of unlockedOthers) next[j] = each;
    // fix residue
    let diff = newRema - each * unlockedOthers.length;
    for (let k = 0; diff > 0; k = (k + 1) % unlockedOthers.length) {
      next[unlockedOthers[k]]++;
      diff--;
    }
  } else {
    for (const j of unlockedOthers) {
      next[j] = Math.floor(current[j] * (newRema / oldUnlockedOthersSum));
    }
    // fix rounding residue across unlocked others
    const diff = budget - next.reduce((a, b, j) => a + (effLocked[j] ? 0 : b), 0);
    if (diff !== 0) {
      const order = unlockedOthers
        .slice()
        .sort((a, b) => current[b] - current[a]); // bias bigger buckets
      let k = 0, remain = Math.abs(diff);
      while (remain--) {
        next[order[k]] += Math.sign(diff);
        k = (k + 1) % order.length;
      }
    }
  }
  return next;
}

/** Normalize unlocked rows so total == DENOM (respect locks, keep proportions) */
export function normalizeWithLocksPPM(ppm: number[], locked: boolean[]): number[] {
  const n = ppm.length;
  const sumLocked = ppm.reduce((a, v, j) => a + (locked[j] ? v : 0), 0);
  const budget = PPM_DENOM - sumLocked;

  const unlockedIdxs = [];
  let sumUnlocked = 0;
  for (let j = 0; j < n; j++) if (!locked[j]) { unlockedIdxs.push(j); sumUnlocked += ppm[j]; }

  const next = ppm.slice();
  if (unlockedIdxs.length === 0) return next;
  if (sumUnlocked === 0) {
    const each = Math.floor(budget / unlockedIdxs.length);
    for (const j of unlockedIdxs) next[j] = each;
    let diff = budget - each * unlockedIdxs.length;
    for (let k = 0; diff > 0; k = (k + 1) % unlockedIdxs.length) { next[unlockedIdxs[k]]++; diff--; }
    return next;
  }

  for (const j of unlockedIdxs) next[j] = Math.floor(ppm[j] * (budget / sumUnlocked));
  const diff = budget - unlockedIdxs.reduce((a, j) => a + next[j], 0);
  let k = 0, remain = Math.abs(diff);
  while (remain--) {
    next[unlockedIdxs[k]] += Math.sign(diff);
    k = (k + 1) % unlockedIdxs.length;
  }
  return next;
}

/** Equal split across unlocked rows (respect locks) */
export function equalizeUnlockedPPM(ppm: number[], locked: boolean[]): number[] {
  const n = ppm.length;
  const sumLocked = ppm.reduce((a, v, j) => a + (locked[j] ? v : 0), 0);
  const budget = PPM_DENOM - sumLocked;

  const unlockedIdxs = [];
  for (let j = 0; j < n; j++) if (!locked[j]) unlockedIdxs.push(j);

  const next = ppm.slice();
  if (unlockedIdxs.length === 0) return next;

  const each = Math.floor(budget / unlockedIdxs.length);
  for (const j of unlockedIdxs) next[j] = each;
  let diff = budget - each * unlockedIdxs.length;
  for (let k = 0; diff > 0; k = (k + 1) % unlockedIdxs.length) { next[unlockedIdxs[k]]++; diff--; }
  return next;
}

```

---

## src/scrapers/buyee.ts

```ts
import fs from 'fs';
import path from 'path';
import { chromium, type Page } from 'playwright';
import { BuyeeShippedResult, BuyeePackage, yenToNumber } from '@/lib/scrape';

const PROFILE_DIR = process.env.BUYEY_PROFILE_DIR || '.secrets/buyee-profile';
const DEBUG = process.env.DEBUG_SCRAPER === '1';

export async function scrapeBuyeeShippedList(url: string): Promise<BuyeeShippedResult> {
      const absProfile = path.resolve(PROFILE_DIR);
if (!fs.existsSync(absProfile)) {
    throw new Error(`Buyee profile not found at ${absProfile}. Run the profile initializer first.`);
  }
 const context = await chromium.launchPersistentContext(absProfile, {
    channel: 'chrome',        // IMPORTANT: use real Chrome
    headless: false,          // start visible first; switch to true later if it still works
    viewport: { width: 1366, height: 900 },
    locale: 'en-US',
    userAgent:
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
      '(KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36',
    extraHTTPHeaders: { 'Accept-Language': 'en-US,en;q=0.9,ja;q=0.8' },
  });
  const page = await context.newPage();
  try {
    // Prime a buyee tab so cookies attach to the correct domain
    await page.goto('https://buyee.jp/', { waitUntil: 'domcontentloaded' });
    await page.goto(url, { waitUntil: 'domcontentloaded' });

    // Detect not-logged-in redirect
    const currentUrl = page.url();
    if (/\/login\b/i.test(currentUrl)) {
      await page.screenshot({ path: '/tmp/buyee-login.png', fullPage: true }).catch(()=>{});
      throw new Error('Not logged in (redirected to /login). Check cookies file. Screenshot: /tmp/buyee-login.png');
    }

    // Try to locate shipped entries
    const entries = await page.locator('li.luggageInfo.shipped').count();
    if (DEBUG) console.log(`[scraper] found ${entries} shipped entries on ${currentUrl}`);

    if (entries === 0) {
      await page.screenshot({ path: '/tmp/buyee-empty.png', fullPage: true }).catch(()=>{});
      throw new Error('No shipped entries found. Selectors may need adjustment or cookies invalid. Screenshot: /tmp/buyee-empty.png');
    }

    // ... (leave the rest of the extraction code as we wrote before)
    const packages: BuyeePackage[] = await page.locator('li.luggageInfo.shipped').evaluateAll((nodes) => {
      const parseYen = (s?: string) => {
        if (!s) return undefined;
        const cleaned = s.replace(/[^\d.,-]/g, '').replace(/,(?=\d{3}(\D|$))/g, '').replace(/(\d),(?=\d{1,2}$)/, '$1.');
        const n = Number(cleaned);
        return Number.isFinite(n) ? n : undefined;
      };

      return nodes.map((li) => {
        const pick = (sel: string) => (li.querySelector(sel)?.textContent || '').trim();

        const dateRaw = pick('.luggageInfo_header .date_shipped');
        const dateShipped = (dateRaw.match(/\d{4}-\d{2}-\d{2}/) || [])[0];

        const intlA = li.querySelector('.luggageInfo_header .i18n_shipping_number a') as HTMLAnchorElement | null;
        const intlTrackingNumber = intlA?.textContent?.trim();
        const intlTrackingUrl = intlA?.href || undefined;

        const pkgRaw = pick('.luggageInfo_header .package_number');
        const packageNumber = pkgRaw.replace(/^Package number/i, '').trim() || undefined;

        const items: any[] = [];
        li.querySelectorAll('.luggageInfo_order tr').forEach((tr, idx) => {
          if (idx === 0) return;
          const tds = tr.querySelectorAll('td');
          if (tds.length < 3) return;
          const orderNumber = (tds[1]?.textContent || '').trim();
          const a = tds[2]?.querySelector('a') as HTMLAnchorElement | null;
          const title = (a?.textContent || '').trim();
          const itemUrl = a?.href || '';
          const listingId = itemUrl ? itemUrl.split('/').filter(Boolean).pop() : undefined;
          if (orderNumber || title) items.push({ orderNumber, title, itemUrl, listingId });
        });

        let internationalShippingFeeYen: number | undefined;
        let domesticShippingFeeYen: number | undefined;
        const fee = li.querySelector('.amount_info_container');
        if (fee) {
          const dts = Array.from(fee.querySelectorAll('dt'));
          const dds = Array.from(fee.querySelectorAll('dd'));
          for (let i = 0; i < dts.length; i++) {
            const label = (dts[i].textContent || '').replace(/\s+/g, ' ').trim();
            const value = (dds[i]?.textContent || '').trim();
            if (/^International Shipping Fee/i.test(label)) internationalShippingFeeYen = parseYen(value);
            if (/^Domestic Shipping Fee/i.test(label)) domesticShippingFeeYen = parseYen(value);
          }
        }

        const invoice = li.querySelector('.delivery_info_container .invoice_info table')
                      || li.querySelector('.invoice_info table');
        if (invoice) {
          const subtotals: number[] = [];
          invoice.querySelectorAll('tr').forEach((tr, idx) => {
            if (idx === 0) return;
            const tds = tr.querySelectorAll('td');
            if (tds.length >= 3) {
              const subTxt = (tds[2]?.textContent || '').trim();
              const n = parseYen(subTxt);
              if (typeof n === 'number') subtotals.push(n);
            }
          });
          for (let i = 0; i < items.length && i < subtotals.length; i++) {
            items[i].priceYen = subtotals[i];
          }
        }

        return {
          dateShipped,
          intlTrackingNumber,
          intlTrackingUrl,
          packageNumber,
          items,
          internationalShippingFeeYen,
          domesticShippingFeeYen,
        };
      });
    });

    const result: BuyeeShippedResult = { proxyName: 'buyee', pageUrl: url, packages };
    if (DEBUG) console.log('[scraper] result sample:', JSON.stringify(result.packages[0], null, 2));
    return result;
  } finally {
    await page.close();
    await context.close();
  }
}
```

---

## src/scrapers/fromjapan.ts

```ts
import path from 'path';
import fs from 'fs';
import { chromium } from 'playwright';

export type FJItem = {
  listingId?: string;     // auction ID / item_id
  orderNumber?: string;   // not exposed in JSON; leave undefined for now
  title: string;
  itemUrl: string;
  priceYen?: number;      // Charge 1 (c1_total)
};

export type FJPackage = {
  packageNumber: string;            // unique per physical package (shipmentNo#i if multi)
  baseShipmentNumber: string;       // original Shipment No. (or iid fallback)
  dateShipped?: string;             // shipped_date (YYYY-MM-DD part)
  trackingNumbers: string[];        // one or more tracking numbers
  items: FJItem[];
  internationalShippingFeeYen?: number; // Charge 2 (c2_total) split evenly across packages
  domesticShippingFeeYen?: number;      // always 0 per spec
};

export type FJShippedResult = {
  proxyName: 'fromjapan';
  pageUrl: string;
  packages: FJPackage[];
};

const PROFILE_DIR = process.env.FJ_PROFILE_DIR || '.secrets/fj-profile';
const DEBUG = process.env.DEBUG_SCRAPER === '1';

function decodeUrlMaybe(u?: string): string {
  if (!u) return '';
  try {
    return decodeURIComponent(u);
  } catch {
    return u;
  }
}

export async function scrapeFromJapanShippedList(url: string): Promise<FJShippedResult> {
  const absProfile = path.resolve(PROFILE_DIR);
  if (!fs.existsSync(absProfile)) {
    throw new Error(`FromJapan profile not found at ${absProfile}. Run the profile initializer to login first.`);
  }

  const context = await chromium.launchPersistentContext(absProfile, {
    channel: 'chrome',
    headless: false, // keep visible while stabilizing; try true later if it still works
    viewport: { width: 1366, height: 900 },
    locale: 'en-US',
    userAgent:
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36',
    extraHTTPHeaders: { 'Accept-Language': 'en-US,en;q=0.9,ja;q=0.8' },
  });

  const page = await context.newPage();
  try {
    await page.goto(url, { waitUntil: 'domcontentloaded' });

    // Wait for the embedded data blob to exist (it's a hidden script tag)
    await page.waitForSelector('script#bData', { state: 'attached', timeout: 20000 });

    // Pull and parse the JSON embedded in #bData
    const shipments = await page.evaluate(() => {
      const script = document.querySelector<HTMLScriptElement>('script#bData');
      if (!script) return [];

      let data: any = {};
      try {
        // The content is base64 JSON
        const b64 = script.textContent || '';
        const decoded = atob(b64);
        data = JSON.parse(decoded);
      } catch (e) {
        return [];
      }

      // Each entry in data.list is a shipment
      const list: any[] = Array.isArray(data.list) ? data.list : [];
      const result: any[] = [];

      for (const shp of list) {
        // Prefer shipment_no; fallback to iid (numeric stable id)
        const shipmentNo: string | undefined =
          (shp.shipment_no_str as string) ||
          (shp.shipment_no as string) ||
          (shp.iid != null ? String(shp.iid) : undefined);

        if (!shipmentNo) continue;

        // Date shipped (YYYY-MM-DD from shipped_date)
        let dateShipped: string | undefined;
        if (typeof shp.shipped_date === 'string') {
          const m = shp.shipped_date.match(/\d{4}-\d{2}-\d{2}/);
          if (m) dateShipped = m[0];
        }

        // Tracking numbers: keys of ship_no object
        const trackingNumbers: string[] = [];
        if (shp.ship_no && typeof shp.ship_no === 'object') {
          for (const key of Object.keys(shp.ship_no)) {
            if (key && typeof key === 'string') trackingNumbers.push(key.trim());
          }
        }

        // Shipment-level shipping cost (Charge 2)
        const charge2Total: number = typeof shp.c2_total === 'number' ? shp.c2_total : 0;

        // Items
        const itemsRaw: any[] = Array.isArray(shp.items) ? shp.items : [];
        const items = itemsRaw.map((it) => {
          const title = (it.item_name as string) || '';
          const itemUrl = decodeURIComponent((it.item_url as string) || '');
          const listingId = (it.item_id as string) || undefined; // Yahoo auction ID, etc.
          const priceYen = typeof it.c1_total === 'number' ? it.c1_total : undefined; // Charge 1

          return {
            listingId,
            orderNumber: undefined, // not available in the JSON
            title,
            itemUrl,
            priceYen,
          };
        });

        result.push({
          dateShipped,
          shipmentNo,
          trackingNumbers,
          items,
          charge2Total,
        });
      }

      return result;
    });

    // Expand multi-package:
    // - Split Charge 2 evenly per package
    // - DISTRIBUTE ITEMS across packages (no duplication, no price division)
    const packages: FJPackage[] = [];
    for (const s of shipments as any[]) {
      if (!s.shipmentNo) continue;

      const nPkgs = Math.max(1, s.trackingNumbers?.length || 1);
      const perPkgShip = s.charge2Total ? s.charge2Total / nPkgs : 0;

      // copy items and KEEP their full prices
      const allItems: FJItem[] = (s.items || []).map((it: any) => ({
        listingId: it.listingId,
        orderNumber: it.orderNumber,
        title: it.title,
        itemUrl: it.itemUrl,
        priceYen: typeof it.priceYen === 'number' ? it.priceYen : undefined,
      }));

      // Even block distribution: first packages get the extra items
      const m = allItems.length;
      const base = Math.floor(m / nPkgs);
      const extra = m % nPkgs;
      let cursor = 0;

      for (let i = 0; i < nPkgs; i++) {
        const pkgCount = base + (i < extra ? 1 : 0);
        const pkgItems = allItems.slice(cursor, cursor + pkgCount);
        cursor += pkgCount;

        const pkgSuffix = nPkgs > 1 ? `#${i + 1}` : '';
        const packageNumber = `${s.shipmentNo}${pkgSuffix}`;
        const tracking = s.trackingNumbers?.[i] ? [s.trackingNumbers[i]] : (s.trackingNumbers || []);

        packages.push({
          packageNumber,
          baseShipmentNumber: s.shipmentNo,
          dateShipped: s.dateShipped,
          trackingNumbers: tracking,
          items: pkgItems,
          internationalShippingFeeYen: perPkgShip,
          domesticShippingFeeYen: 0,
        });
      }
    }

    if (DEBUG) console.log(`[FJ] scraped shipments=${shipments.length}, packages=${packages.length}`);
    return { proxyName: 'fromjapan', pageUrl: url, packages };
  } finally {
    await page.close();
    await context.close();
  }
}
```

---

## src/scrapers/zenmarket.ts

```ts
import path from 'path';
import fs from 'fs';
import { chromium } from 'playwright';

type ZMItemRow = {
  titleJa: string;
  itemUrl: string;
  listingId?: string | null;
  priceYen?: number;
  // used only to compute domestic total; not persisted per item
  localShipYen?: number;
};

type ZMItemsNested = {
  create: Array<{
    orderNumber?: string | null;
    titleJa?: string | null;
    titleEn?: string | null;
    itemUrl?: string | null;
    listingId?: string | null;
    priceYen?: number | null;
  }>;
};

export type ZMPackage = {
  proxyName: 'zenmarket';
  pageUrl: string;

  packageNumber: string;          // pid (unique)
  displayNumber?: string;         // e.g. "#2"

  dateShipped?: string;           // YYYY-MM-DD
  trackingNumber?: string | null;
  trackingUrl?: string | null;

  internationalShippingFeeYen?: number;
  domesticShippingFeeYen?: number;

  items?: ZMItemsNested;          // Prisma nested create
  raw?: any;
};

const PROFILE_DIR = process.env.ZM_PROFILE_DIR || '.secrets/zm-profile';
const DEBUG = process.env.DEBUG_SCRAPER === '1';

function yenToNumber(txt: string | null | undefined): number {
  if (!txt) return 0;
  const n = txt.replace(/[^0-9.-]/g, '');
  const v = Number(n);
  return Number.isFinite(v) ? v : 0;
}

// supports auction.aspx?itemCode=XXXX and pretty “/auction/XXXX”
function parseListingIdFromUrl(url: string): string | null {
  try {
    const m0 = url.match(/[?&]itemCode=([A-Za-z0-9]+)/i);
    if (m0) return m0[1];
    const m = url.match(/auction\/([A-Za-z0-9]+)/i);
    if (m) return m[1];
    const m2 = url.match(/mercari\.com\/.*\/item\/([A-Za-z0-9]+)/i);
    if (m2) return m2[1];
  } catch {}
  return null;
}

export async function scrapeZenMarketParcels(
  url = 'https://zenmarket.jp/fr/profile/parcel.aspx?state=5'
): Promise<ZMPackage[]> {
  const absProfile = path.resolve(PROFILE_DIR);
  if (!fs.existsSync(absProfile)) {
    throw new Error(`ZenMarket profile not found at ${absProfile}. Log in once with a persistent context.`);
  }

  const context = await chromium.launchPersistentContext(absProfile, {
    channel: 'chrome',
    headless: false,
    viewport: { width: 1366, height: 900 },
    userAgent:
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36',
    locale: 'fr-FR',
    extraHTTPHeaders: { 'Accept-Language': 'fr-FR,fr;q=0.9,en;q=0.8,ja;q=0.7' },
  });

  const page = await context.newPage();
  try {
    await page.goto(url, { waitUntil: 'domcontentloaded' });
    await page.waitForSelector('div.parcel', { timeout: 20000 });

    // -------- Discover parcels by walking .parcel cards --------
    const parcels = await page.evaluate(() => {
      const toNum = (s?: string | null) => {
        if (!s) return 0;
        const n = s.replace(/[^0-9.-]/g, '');
        const v = Number(n);
        return Number.isFinite(v) ? v : 0;
      };

      const normDate = (t: string): string | undefined => {
        const a = t.match(/\b(\d{4}-\d{2}-\d{2})\b/);
        if (a) return a[1];
        const b = t.match(/\b(\d{2}\/\d{2}\/\d{4})\b/);
        if (b) {
          const [dd, mm, yyyy] = b[1].split('/');
          return `${yyyy}-${mm}-${dd}`;
        }
        return undefined;
      };

      // Pull number from the parent <div> that contains `<span>Envoi:</span>` or `<span>Shipping:</span>`
      const extractIntlShipping = (card: HTMLElement): number => {
        const labelSpan = Array.from(card.querySelectorAll('span')).find(sp => {
          const t = (sp.textContent || '').trim();
          return t.startsWith('Envoi:') || t.startsWith('Shipping:');
        });
        if (!labelSpan) return 0;

        const container = labelSpan.parentElement as HTMLElement | null;
        if (!container) return 0;

        // The amount is the remaining text in the same container after removing the label text.
        let txt = (container.textContent || '').replace(labelSpan.textContent || '', '').trim();
        // e.g. "¥6,100"
        return toNum(txt);
      };

      const results: Array<{
        pid: string;
        displayNumber?: string;
        dateShipped?: string;
        trackingNumber?: string | null;
        trackingUrl?: string | null;
        intlShipping?: number;
      }> = [];

      document.querySelectorAll<HTMLDivElement>('div.parcel').forEach(card => {
        const link = card.querySelector<HTMLAnchorElement>('a[data-parcelid]');
        if (!link) return;
        const pid = link.getAttribute('data-parcelid');
        if (!pid) return;

        // e.g. "#2"
        const displayNumber =
          card.innerText.split('\n').map(s => s.trim()).find(s => /^#\d+\b/.test(s)) || undefined;

        const dateShipped = normDate(card.innerText);

        // Tracking (JP Post example in snippet)
        let trackingNumber: string | null = null;
        let trackingUrl: string | null = null;
        const links = Array.from(card.querySelectorAll('a[href]')) as HTMLAnchorElement[];
        const tlink = links.find(x => /[A-Z]{2}\d{9}[A-Z]{2}|\b\d{10,14}\b|JJD/i.test(x.textContent || ''));
        if (tlink) {
          trackingNumber = (tlink.textContent || '').trim() || null;
          trackingUrl = tlink.href || null;
        }

        const intlShipping = extractIntlShipping(card);

        results.push({ pid, displayNumber, dateShipped, trackingNumber, trackingUrl, intlShipping });
      });

      return results;
    });

    if (DEBUG) console.log('[ZM] found pids:', parcels.map((p: any) => p.pid));

    const packages: ZMPackage[] = [];

    for (const p of parcels) {
      if (!p.pid) continue;

      // Fetch parcel items
      const payload = { pid: Number(p.pid) };
      const resp = await page.evaluate(async (body) => {
        const r = await fetch('/profile/parcel.aspx/getParcelContent', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json; charset=UTF-8',
            'X-Requested-With': 'XMLHttpRequest',
          },
          body: JSON.stringify(body),
          credentials: 'same-origin',
        });
        return await r.json();
      }, payload);

      // JSON-first parse into ZMItemRow[]
      let rows: ZMItemRow[] = [];
      try {
        const raw = typeof resp?.d === 'string' ? resp.d : (resp?.d ? JSON.stringify(resp.d) : '[]');
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          rows = arr.map((it: any) => ({
            titleJa: String(it?.ProductName ?? '').trim(),
            itemUrl: String(it?.ProductURL ?? '').trim(),
            priceYen: yenToNumber(it?.Price) + yenToNumber(it?.Tax),
            localShipYen: yenToNumber(it?.LocalShippingPrice),
            listingId: null, // fill below outside evaluate()
          }));
        }
      } catch {}

      // Fill listingId client-side and compute domestic total
      let domesticTotal = 0;
      const rawItemsReady: ZMItemRow[] = rows.map(r => {
        const listingId = parseListingIdFromUrl(r.itemUrl || '') ?? null;
        domesticTotal += (r.localShipYen || 0);
        return { ...r, listingId };
      });

      // Convert to Prisma nested create shape (duplicate titleEn from titleJa)
      const itemsNested: ZMItemsNested | undefined =
        rawItemsReady.length > 0
          ? {
              create: rawItemsReady.map(r => ({
                orderNumber: null,
                titleJa: r.titleJa ?? null,
                titleEn: r.titleJa ?? null,  // duplicate JP into EN
                itemUrl: r.itemUrl ?? null,
                listingId: r.listingId ?? null,
                priceYen: (r.priceYen ?? 0),
              })),
            }
          : undefined;

      const pkg: ZMPackage = {
        proxyName: 'zenmarket',
        pageUrl: url,
        packageNumber: String(p.pid),
        displayNumber: p.displayNumber,
        dateShipped: p.dateShipped,
        trackingNumber: p.trackingNumber ?? null,
        trackingUrl: p.trackingUrl ?? null,
        internationalShippingFeeYen: p.intlShipping ?? 0,
        domesticShippingFeeYen: domesticTotal || 0,
        items: itemsNested,
        raw: { parcelMeta: p, response: resp },
      };

      packages.push(pkg);
    }

    if (DEBUG) console.log(`[ZM] scraped packages=${packages.length}`);
    return packages;
  } finally {
    await page.close();
    await context.close();
  }
}

```

---

## src/scripts/build-summary.mjs

```js
// scripts/build-summary.mjs
import fs from 'node:fs';
import path from 'node:path';
import { execSync } from 'node:child_process';
import url from 'node:url';

const repoRoot = process.cwd();
const OUT_FILE = (process.argv.includes('--out')
  ? process.argv[process.argv.indexOf('--out') + 1]
  : 'docs/codebase-summary.md');

const WATCH = process.argv.includes('--watch');

// allow-list of file extensions we’ll include in the summary
const TEXT_EXTS = new Set([
  // code
  '.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs',
  '.css', '.scss', '.sass',
  '.htm',
  '.mdx',
  '.yml', '.yaml', '.toml', '.ini', '.conf',
  '.prisma',
  '.sh', '.bash', '.zsh',
  '.py', '.rb', '.go', '.rs', '.kt', '.java',
  '.m', '.mm', '.swift',
  '.txt',
  // project config
  '.env.example', '.gitignore', '.gitattributes', '.editorconfig',
  '.tsconfig', '.eslintrc', '.prettierrc', '.npmrc',
]);

// soft size cap (skip huge text files)
const MAX_FILE_BYTES = 512 * 1024; // 512 KB

function languageFromExt(p) {
  const ext = path.extname(p).toLowerCase();
  switch (ext) {
    case '.ts': return 'ts';
    case '.tsx': return 'tsx';
    case '.js': case '.mjs': case '.cjs': return 'js';
    case '.jsx': return 'jsx';
    case '.css': return 'css';
    case '.scss': case '.sass': return 'scss';
    case '.html': case '.htm': return 'html';
    case '.json': return 'json';
    case '.yml': case '.yaml': return 'yaml';
    case '.toml': return 'toml';
    case '.sql': return 'sql';
    case '.prisma': return 'prisma';
    case '.md': case '.mdx': return 'md';
    case '.sh': case '.bash': case '.zsh': return 'bash';
    case '.py': return 'python';
    case '.rb': return 'ruby';
    case '.go': return 'go';
    case '.rs': return 'rust';
    case '.kt': return 'kotlin';
    case '.java': return 'java';
    case '.swift': return 'swift';
    default: return ''; // plain fence
  }
}

function getGitFiles() {
  // includes tracked + staged + untracked (but not ignored) files
  const out = execSync('git ls-files --cached --others --exclude-standard -z', { cwd: repoRoot });
  return out.toString('utf8').split('\0').filter(Boolean);
}

function getRepoMeta() {
  let commit = '';
  let when = '';
  let origin = '';
  try { commit = execSync('git rev-parse HEAD', { cwd: repoRoot }).toString('utf8').trim(); } catch {}
  try { when = execSync('git show -s --format=%ci HEAD', { cwd: repoRoot }).toString('utf8').trim(); } catch {}
  try { origin = execSync('git config --get remote.origin.url', { cwd: repoRoot }).toString('utf8').trim(); } catch {}
  return { commit, when, origin };
}

function isTextFile(p) {
  const ext = path.extname(p).toLowerCase();
  if (!TEXT_EXTS.has(ext)) return false;
  try {
    const st = fs.statSync(path.join(repoRoot, p));
    if (st.size > MAX_FILE_BYTES) return false;
    return true;
  } catch {
    return false;
  }
}

function buildOnce() {
  const files = getGitFiles().filter(isTextFile);

  const { commit, when, origin } = getRepoMeta();
  const header =
`# Codebase Summary

> Generated: ${new Date().toISOString()}
> Commit: ${commit || 'n/a'}
> Date: ${when || 'n/a'}
> Remote: ${origin || 'n/a'}

This file concatenates important text/code files in the repo so a single raw URL can be shared.

---

`;

  let out = header;

  for (const rel of files.sort()) {
    const abs = path.join(repoRoot, rel);
    let content = '';
    try {
      content = fs.readFileSync(abs, 'utf8');
    } catch {
      continue;
    }
    const lang = languageFromExt(rel);
    out += `\n---\n\n## ${rel}\n\n\`\`\`${lang}\n${content.replace(/\`\`\`/g, '```')}\n\`\`\`\n`;
  }

  const outAbs = path.join(repoRoot, OUT_FILE);
  fs.mkdirSync(path.dirname(outAbs), { recursive: true });
  fs.writeFileSync(outAbs, out, 'utf8');

  const relOut = path.relative(repoRoot, outAbs);
  console.log(`[summary] Wrote ${relOut} (${files.length} files)`);
}

async function main() {
  if (!WATCH) {
    buildOnce();
    return;
  }

  // Watch mode (uses chokidar if available; else falls back to periodic rebuild)
  try {
    const chokidar = (await import('chokidar')).default;
    const watcher = chokidar.watch(['**/*'], {
      ignored: [
        '**/.git/**',
        '**/node_modules/**',
        '**/.next/**',
        '**/dist/**',
        '**/build/**',
        '**/coverage/**',
        '**/.turbo/**',
        '**/.vercel/**',
        '**/.idea/**',
        '**/.vscode/**',
         '**/.sql/**',
         '**/package-lock.json/**',
         '**/debug-final.html/**',
        OUT_FILE,
      ],
      ignoreInitial: true,
    });

    let timer = null;
    const schedule = () => {
      clearTimeout(timer);
      timer = setTimeout(buildOnce, 200);
    };

    buildOnce();
    watcher.on('add', schedule).on('change', schedule).on('unlink', schedule);
    console.log('[summary] Watching for changes… (Ctrl+C to stop)');
  } catch (e) {
    console.warn('[summary] chokidar not installed. Run: npm i -D chokidar');
    // fallback: rebuild once
    buildOnce();
  }
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});

```

---

## src/scripts/migrate-tags-to-placement.ts

```ts
/* scripts/migrate-tags-to-placements.ts
   Migrates from TagRelation (DAG) to TagPlacement (branch-local tree),
   and builds PlacementClosure. Safe to re-run (idempotent).
*/
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

type Relation = { parentId: string; childId: string };
type Placement = { id: string; tagId: string; parentPlacementId: string | null };

async function main() {
  console.log('--- Migration: TagRelation -> TagPlacement ---');

  // 1) Read tags and relations
  const [tags, rels] = await Promise.all([
    prisma.tag.findMany({ select: { id: true } }),
    prisma.tagRelation.findMany({ select: { parentId: true, childId: true } }),
  ]);
  console.log(`Tags: ${tags.length}, Relations: ${rels.length}`);

  // Build adjacency + reverse adjacency
  const childrenByTag = new Map<string, string[]>();
  const parentsByTag = new Map<string, string[]>();
  for (const r of rels) {
    (childrenByTag.get(r.parentId) ?? childrenByTag.set(r.parentId, []).get(r.parentId)!).push(r.childId);
    (parentsByTag.get(r.childId) ?? parentsByTag.set(r.childId, []).get(r.childId)!).push(r.parentId);
  }

  // 2) Ensure root placements for tags with no parents OR isolated tags
  const tagIds = new Set(tags.map(t => t.id));
  const childSet = new Set(rels.map(r => r.childId));
  const parentSet = new Set(rels.map(r => r.parentId));

  const roots: string[] = [];
  for (const tid of tagIds) {
    if (!parentsByTag.has(tid)) roots.push(tid);
  }
  console.log(`Root tags detected: ${roots.length}`);

  // Helper: ensure placement exists under given parentPlacementId
  async function ensurePlacement(tagId: string, parentPlacementId: string | null): Promise<Placement> {
    const existing = await prisma.tagPlacement.findFirst({
      where: { tagId, parentPlacementId },
      select: { id: true, tagId: true, parentPlacementId: true },
    });
    if (existing) return existing as Placement;

    const created = await prisma.tagPlacement.create({
      data: { tagId, parentPlacementId },
      select: { id: true, tagId: true, parentPlacementId: true },
    });
    return created as Placement;
  }

  // Create root placements
  const rootPlacements: Placement[] = [];
  for (const rootTagId of roots) {
    const p = await ensurePlacement(rootTagId, null);
    rootPlacements.push(p);
  }
  console.log(`Root placements created/verified: ${rootPlacements.length}`);

  // 3) Expand placements down the DAG: for each placement of a parent tag,
  //    create a child placement per TagRelation edge (parentTag -> childTag) under that *placement*.
  // We'll BFS over placements.
  const queue: Placement[] = [...rootPlacements];
  let createdCount = 0;

  // Build quick lookup for children
  function getChildren(tagId: string): string[] {
    return childrenByTag.get(tagId) ?? [];
  }

  while (queue.length) {
    const p = queue.shift()!;
    const parentTagId = p.tagId;
    const childTagIds = getChildren(parentTagId);
    if (childTagIds.length === 0) continue;

    for (const childTagId of childTagIds) {
      const childPlacement = await ensurePlacement(childTagId, p.id);
      // If it was newly created in this run, we have no way to know except by trying to find it first.
      // We still push to queue so deeper descendants get created.
      queue.push(childPlacement);
      createdCount++;
    }
  }
  console.log(`Placement expansion completed. (Created/verified edges: ${createdCount})`);

  // 4) Rebuild PlacementClosure from TagPlacement parent links
  console.log('Rebuilding PlacementClosure…');
  await prisma.placementClosure.deleteMany({});

  const allPlacements = await prisma.tagPlacement.findMany({
    select: { id: true, parentPlacementId: true },
  });

  // Self links
  if (allPlacements.length) {
    await prisma.placementClosure.createMany({
      data: allPlacements.map(p => ({
        ancestorPlacementId: p.id,
        descendantPlacementId: p.id,
        depth: 0,
      })),
      skipDuplicates: true,
    });
  }

  // Build adjacency for placements
  const childrenByPlacement = new Map<string, string[]>();
  for (const p of allPlacements) {
    if (p.parentPlacementId) {
      const arr = childrenByPlacement.get(p.parentPlacementId);
      if (arr) arr.push(p.id);
      else childrenByPlacement.set(p.parentPlacementId, [p.id]);
    }
  }

  // BFS from each placement as ancestor
  const pairs: { ancestorPlacementId: string; descendantPlacementId: string; depth: number }[] = [];
  for (const anc of allPlacements) {
    const seen = new Set<string>([anc.id]);
    const q: Array<{ id: string; depth: number }> = [{ id: anc.id, depth: 0 }];
    while (q.length) {
      const { id, depth } = q.shift()!;
      const kids = childrenByPlacement.get(id) ?? [];
      for (const kid of kids) {
        if (!seen.has(kid)) {
          seen.add(kid);
          pairs.push({
            ancestorPlacementId: anc.id,
            descendantPlacementId: kid,
            depth: depth + 1,
          });
          q.push({ id: kid, depth: depth + 1 });
        }
      }
    }
  }

  // Insert closure in manageable chunks
  const chunkSize = 5000;
  for (let i = 0; i < pairs.length; i += chunkSize) {
    const chunk = pairs.slice(i, i + chunkSize);
    await prisma.placementClosure.createMany({ data: chunk, skipDuplicates: true });
    if ((i / chunkSize) % 20 === 0) console.log(`…closure progress ${i + chunk.length}/${pairs.length}`);
  }

  console.log('PlacementClosure rebuild done.');
  console.log('--- Migration complete ---');
}

main()
  .catch((e) => {
    console.error('Migration failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

```

---

## src/scripts/pruneorphan.ts

```ts
// scripts/prune-orphan-tags.ts
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
async function main() {
  await prisma.$executeRawUnsafe(`
    DELETE FROM "Tag" t
    WHERE NOT EXISTS (SELECT 1 FROM "TagPlacement" p WHERE p."tagId" = t."id")
      AND NOT EXISTS (SELECT 1 FROM "ItemTag" it WHERE it."tagId" = t."id");
  `);
  console.log('Pruned orphan tags.');
}
main().finally(() => prisma.$disconnect());
```

---

## src/scripts/reset-tags.ts

```ts
import { prisma } from '@/lib/prisma';

async function main() {
  console.log('Wiping ItemTag, TagClosure, TagRelation, Tag …');
  await prisma.$transaction([
    prisma.itemTag.deleteMany({}),
    prisma.tagClosure.deleteMany({}),
    // If you’re on the new DAG schema, keep this; otherwise it’s harmless if the table doesn’t exist:
    prisma.$executeRawUnsafe(`DO $$ BEGIN
      IF to_regclass('public."TagRelation"') IS NOT NULL THEN
        DELETE FROM "TagRelation";
      END IF;
    END $$;`),
    prisma.tag.deleteMany({}),
  ]);
  console.log('Done.');
}

main().catch(e => {
  console.error(e);
  process.exit(1);
}).finally(async () => prisma.$disconnect());
```

---

## src/scripts/save-buyee-auth.ts

```ts
import { chromium } from 'playwright';
import path from 'path';
import fs from 'fs';

(async () => {
  const profileDir = path.resolve('/home/oulette/.proxy-profiles/buyee-profile'); // persisted session directory
  fs.mkdirSync(profileDir, { recursive: true });

  const context = await chromium.launchPersistentContext(profileDir, {
    channel: 'chrome',         // use your real Chrome, not bundled Chromium
    headless: false,           // visible window so you can log in
    viewport: { width: 1280, height: 900 },
    locale: 'en-US',
    userAgent:
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
      '(KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36',
    acceptDownloads: false,
    permissions: [],
    extraHTTPHeaders: { 'Accept-Language': 'en-US,en;q=0.9,ja;q=0.8' },
  });

  const page = await context.newPage();
  console.log('Opening Buyee. Please log in, then press ENTER here to save profile…');
  await page.goto('https://buyee.jp/', { waitUntil: 'domcontentloaded' });

  process.stdin.resume();
  process.stdin.on('data', async () => {
    await context.close(); // this writes state into the profile dir
    console.log('Profile saved at', profileDir);
    process.exit(0);
  });
})();
```

---

## src/scripts/save-fromjapan-auth.ts

```ts
import { chromium } from 'playwright';
import path from 'path';
import fs from 'fs';

(async () => {
  const profileDir = path.resolve('/home/oulette/.proxy-profiles/fj-profile');
  fs.mkdirSync(profileDir, { recursive: true });

  const ctx = await chromium.launchPersistentContext(profileDir, {
    channel: 'chrome',
    headless: false,
    viewport: { width: 1280, height: 900 },
  });
  const page = await ctx.newPage();
  console.log('Opening FromJapan. Log in, then press ENTER here to save profile…');
  await page.goto('https://www.fromjapan.co.jp/japan/en/member/history/ship/list', { waitUntil: 'domcontentloaded' });

  process.stdin.resume();
  process.stdin.on('data', async () => {
    await ctx.close();
    console.log('Saved profile at', profileDir);
    process.exit(0);
  });
})();
```

---

## src/scripts/save-zenmarket-auth.ts

```ts
import { chromium } from 'playwright';
import path from 'path';
import fs from 'fs';

(async () => {
  const profileDir = path.resolve('/home/oulette/.proxy-profiles/zm-profile');
  fs.mkdirSync(profileDir, { recursive: true });

  const ctx = await chromium.launchPersistentContext(profileDir, {
    channel: 'chrome',
    headless: false,
    viewport: { width: 1280, height: 900 },
  });
  const page = await ctx.newPage();
  console.log('Opening FromJapan. Log in, then press ENTER here to save profile…');
  await page.goto('https://zenmarket.jp', { waitUntil: 'domcontentloaded' });

  process.stdin.resume();
  process.stdin.on('data', async () => {
    await ctx.close();
    console.log('Saved profile at', profileDir);
    process.exit(0);
  });
})();
```
